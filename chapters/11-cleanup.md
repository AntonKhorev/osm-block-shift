---
title: Поправки геометрии после сдвига
---

Итак, мы справились с перемещением квартала на нужное место. Сделали мы это либо вручную, либо скриптом, в последнем случае у нас остались вспомогательные построения в виде осевых и направляющих линий. Тем не менее, наше дело может быть ещё не закончено. Так может быть по *внутренним* или *внешним* относительно квартала причинам.

*Внутренние причины* заключаются в том, что, несмотря на выполненный сдвиг, мы всё равно недовольны геометрией квартала. В ней есть помехи для добавления тех данных, ради которых мы и выполняли сдвиг. Сдвиг при этом являлся лишь первым этапом редактирования геометрии, позволяющим улучшить данные для всего квартала в среднем. Далее нам надо выполнить изменения, касающиеся уже меньших частей квартала, таких как его сторон или отдельных зданий. В основном это выравнивания сторон по линиям и сдвиги объектов на контурах зданий.

*Внешние причины* наших дальнейших действий объясняются тем, что квартал имеет какие-либо связи с тем, что находится за его пределами. Явными связями будут линии, соединяющие точки внутри и точки снаружи квартала. В первую очередь это соединения внутриквартальных проездов с улицами. Также связи могут быть в виде пересечений геометрии. В результате сдвига они могут нежелательно возникнуть, например, в виде появившихся наложений зданий на тротуары и прочие объекты, или, что бывает реже, исчезнуть, например, в виде выхода объектов за пределы landuse.

Согласно заявляемому в этой записи принципу *в первую очередь не испортить введённые до нас данные*, нам следовало бы сначала вносить исправления по внешним причинам. Именно они соответствуют привнесённым нами ошибкам, в то время как внутренним причинам соответствуют ошибки, имевшиеся и до нас. Однако некоторые из внешних исправлений легче делать после внутренних. В первую очередь это снова касается проездов, исправлять линии которых гораздо удобнее после выравнивания сторон зданий.

При достаточно высокой сложности и низкой точности данных квартала, а также при некоторых способах его сдвига, последующие исправления могут стать самой трудоёмкой частью всей операции. Трудоёмкость объясняется количеством действий, которые необходимо выполнить, а не сложностью каждого отдельного из них. Тем не менее, мы постараемся минимизировать временны́е затраты на каждое отдельное действие, чтобы минимизировать и их сумму. Соответственно, речь часто будет идти не о том, как что-либо сделать в принципе, а о том, как сделать это побыстрее. Без этого вам может не захотеться выполнять рассматриваемые поправки, так как они являются дополнительной задачей, образующейся после того, как основная задача сдвига квартала уже выполнена.

## Нужно ли выравнивание сторон

Сначала рассмотрим внутренние исправления. Наиболее специфичным для сдвига квартала видом внутренних исправлений является выравнивание сторон. Именно для этой операции у нас могут иметься готовые вспомогательные построения. Есть ли они на самом деле, зависит от того, как мы выполняли сдвиг. Если сдвиг производился вручную, перетаскиванием мышкой выделенного множества элементов, вспомогательных построений у нас, скорее всего, нет. Если мы двигали квартал скриптом, построения, скорее всего, есть в виде *направляющих линий*. Более того, углы квартала уже находятся на этих линиях в результате сдвига, и остаётся лишь выстроить в прямую точки между углами.

Выравнивание нам делать точно не понадобится, если в реальности ровно по одной линии ни здания, ни какие-либо другие объекты не расположены. Обычно при рассматриваемых в данной записи условиях такое расположение всё-таки есть, и относительно него мы [ранее рисовали направляющую](../9-guides/#guide-location), если использовали метод сдвига по ней. Почему тогда в данных здания могут быть не выстроены по линии? Для перемещения квартала мы пользовались такими средствами, которые бы подобное построение сохранили, если оно существовало до того. Значит, если здания стоят криво, так их нарисовали до нас. Причин у этого могло быть много, но в целом можно сказать, что рисовавший здания участник не видел смысла стараться рисовать ровно. Мы же можем такой смысл увидеть.

Согласно предполагаемым причинам, почему мы взялись двигать квартал, мы хотим нарисовать что-то рядом с его границей. Этим чем-то может быть линия тротуара. То, насколько криво нарисованы стены зданий, будет заметно по-разному. Если рядом с ними ничего нет, то заметно это не так сильно, чем когда рядом что-то есть. Если мы добавим линию тротуара, которой раньше не было, все неровности зданий будут выставлены напоказ. Примерно то же будет, если мы подвинем на своё место линию тротуара, ранее располагавшуюся дальше от зданий, чем нужно. Сама линия тротуара, скорее всего, прямая и проходит или должна проходить очень близко от зданий. При кривых зданиях расстояние между линией и зданиями будет существенно различаться по протяжённости линии, что будет очень заметно. В худшем случае здания будут закрывать собой то место, где должна проходить линия. Мы пытались переместить квартал так, чтобы эта ситуация не возникала, но, если мы даже и пользовались сдвигом по направляющим, мы пока что совместили с нужным положением только углы квартала. Теперь настало время совместить и стороны между углами.

С точки зрения рисования тротуара эволюция данных выглядит так. Рисовавший здания участник рисовал их без учёта того, что кто-то будет проводить рядом с ними линии тротуара. Возможно, он вообще не думал о том, что линии тротуара будут где-либо проводиться, и считал такие линии излишними. Линию до нас никто так и не провёл, либо она была проведена на большем расстоянии от зданий, чем нужно. В последнем случае на большем расстоянии она была проведена намеренно, чтобы не столкнуться с кривой геометрией смещённого квартала. Был ли смысл рисовать тротуар не на своём месте? Определённый смысл был, например топологический. Даже к смещённому тротуару можно пририсовать пешеходные переходы в примерно правильных местах и получить осмысленный граф для пешеходной маршрутизации. После наших действий положение тротуара станет возможно уточнить, в результате чего он, скорее всего, приблизится к зданиям.

Кстати, подобная картина наблюдается и для ещё одной разновидности линий по краям квартала, о которой мы уже говорили. Это границы landuse, внутри которых находится либо весь квартал, либо его часть. Разница по сравнению с линией тротуара заключается в том, что правильное положение линии landuse - более спорный вопрос. Различные взгляды по этому поводу были описаны выше, в [главе про landuse](../7-landuse/). С расстояниями же линии от зданий можно заметить ту же тенденцию: со временем линию начинают рисовать ближе. Рисовать её близко при кривых зданиях было бы так же неудобно, как и рисовать тротуар. Мы тоже можем хотеть подправить эту линию, или добавить её там, где её не было. Мы могли уже начать это делать, когда рисовали полигон вокруг области выделения.

Может быть, рисование линий вдоль краёв квартала нас не интересует. Есть ли какие-нибудь другие причины выравнивать его стороны? Мы уже обещали, что так будет легче выполнять другие исправления. Вкратце про это можно сказать, что двигать точки вдоль направления стороны квартала легче при наличии линии, соответствующей этому направлению, а эту линию мы в результате выравнивания и получаем. Более непосредственной причиной будет желание нарисовать объект на стене здания, например, почтовый ящик. В этом случае вы наверняка захотите, чтобы хотя бы у этого здания стена была прямая и в нужном месте. Геометрия стены зависит в том числе и от примыкающих зданий, которые зависят от других примыкающих зданий и так далее. В итоге окажется легче разобраться со всей стороной квартала, чем выравнивать отдельное здание.

Возможно, здания нарисованы не слишком криво, мы не собираемся пририсовывать рядом с ними прямые линии, и все исправления после сдвига квартала заключаются в поправке пары искривившихся проездов. Тогда мы действительно можем оставить выравнивание сторон на потом или вообще его не делать. В этом случае можно переходить к следующему виду поправок (или вообще их заканчивать). Далее в следующих разделах мы будем считать, что на выравнивание мы решились. Также мы будем смотреть только на одну сторону квартала, за исключением работы с некоторыми разновидностями его углов. С остальными сторонами можно будет проделать то же самое, хотя решить, стоит ли этим всем заниматься, можно отдельно для каждой из сторон.

## Выравнивание крайних точек стороны

Начнём выравнивать сторону квартала. У нас есть множество точек, которые мы хотим расположить на одной прямой. Этими точками являются углы и *предугловые точки* зданий, входы и прочее, что нарисовано на стенах. Также это могут быть углы заборов, ворота и прочее, что располагается на одной прямой со стенами зданий. Помимо реальных точек в множество входят и вспомогательные, если мы их нарисовали, а именно *целевые контрольные* точки. Прежде, чем выстраивать по прямой всё множество, проверим, как расположены две его *крайние* точки. С остальными, *внутренними* точками множества мы разберёмся после крайних.

Если мы пользовались сдвигом по направляющим, крайними точками будут целевые контрольные точки, и расположены они будут так, как нам и надо. Сразу после сдвига квартала на одном месте с ними будут стоять бывшие исходные точки. В роли исходных точек могут выступать либо реальные углы зданий, либо временно восстановленные углы, полученные с помощью скрипта CornerRestore или другими средствами. Если нам мешает то, что одно место занимают две разные точки, мы их можем объединить. Это легче всего сделать, выделив обе точки прямоугольником (S) или лассо (SS), и выполнив их объединение (M). После этого наши проблемы с крайними точками решены.

Дела будут обстоять сложнее, если направляющими для сдвига мы не пользовались. В роли крайних точек тогда будут выступать угловые или предугловые точки зданий или других объектов. Нас интересует, будет ли условная соединяющая их прямая идти в нужном нам направлении. Обычно мы хотим, чтобы эта прямая была параллельна оси улицы. Потом, после того, как мы разберёмся с крайними точками, мы сделаем так, чтобы всё множество точек оказалось на этой условной прямой. Иными словами, мы хотим, чтобы угловые точки были на одинаковом от оси расстоянии, чтобы поставить на одинаковом расстоянии и прочие точки. Насколько точно мы этого хотим, зависит от нас и наших дальнейших действий.

Самый простой вариант - прикинуть на глаз, устраивает ли нас расположение крайних точек, и решить, что сойдёт. Сможем ли мы улучшить данные при таком неточном подходе? Сможем, во всяком случае сделаем не хуже, чем было. Как мы уже знаем, ошибка в направлении прямой линии будет тем меньше, чем больше было расстояние между точками, по которым она строилась. В имеющихся данных эта ошибка больше, так как она есть для каждого меньшего участка стены отдельно нарисованных зданий. Мы же все эти участки выстроим в одну прямую.

Поступить так может быть приемлемо, если мы не собираемся проводить рядом со зданиями линии, которые должны быть параллельны оси улицы. Если мы будем проводить такие линии, например, тротуар или газоны на нём, то неточность направления может оказаться видна. Но раз у нас откуда-то взялось *правильное* направление, несовпадающее с имеющимся неправильным, мы могли бы его использовать для исправления данных. То есть, у нас снова возникает причина нарисовать направляющую линию. Поскольку теперь она не будет использоваться для сдвига, мы можем позволить себе рисовать её менее точно, ведь исправления по ней затронут не весь квартал, а только одну его сторону. Менее точно мы сможем задать смещение направляющей, а также мы сможем менее тщательно проверять правильность *правильного* направления.

Получив направляющую, мы готовы сделать то, что мы уже рассматривали в [главе про причины неудач сдвига вручную](../8-manual/) - мы можем подравнять геометрию зданий по линии. Начнём мы этот процесс с двух крайних точек, которые мы хотим поставить на направляющую. Главной сложностью является необходимость передвигать их вдоль направления смежных сторон квартала. Это нужно для того, чтобы не изменить направление вдоль смежной стороны стены здания или стороны другого объекта, с которым мы работаем. Со смежной стороны мы могли уже совершить аналогичное выравнивание, и теперь нам не следует его портить.

{% TODO %}рисунок: направление рабочей и смежных сторон{% endTODO %}

### Углы { #corners }

Разным количеством сложностей для нас обернётся и характер каждой из крайних точек. Проще нам будет иметь дело с обычной угловой точкой объекта, которой чаще всего бывает несрезанный угол здания. Если же крайняя точка - это предугловая точка срезанного угла, то мы получим дополнительные сложности - нам придётся что-то делать и с остальными находящимися на углу точками. Для начала разберёмся с несрезанными углами и обычными угловыми точками.

Посмотрим на угол квартала и на находящийся там объект, граница которого проходит через крайнюю точку. Будем считать, что этим объектом является здание. Пока мы считаем, что крайняя точка находится прямо на углу здания и на углу квартала. Нарисованная нами направляющая линия делит пространство на две части: ту, в которой находится весь или почти весь квартал, и ту, в которую попадает область за пределами квартала с выравниваемой стороны. Мы их будем называть *внутренней* и *внешней* сторонами. Крайняя точка находится на одной из этих сторон, а мы хотим переместить её на их границу.

Если крайняя точка находится на внешней стороне, то направляющая проходит сквозь здание и пересекает его стену по смежной с выравниваемой стороне. Тогда нам надо поставить точку на место этого пересечения и переместить в неё угловую точку с помощью объединения (M). Если же крайняя точка находится на внутренней стороне, направляющая, скорее всего, проходит за пределами здания и уж точно не пересекает ту стену. В этом случае легче всего стену продлить, так чтобы она пересекла направляющую, а потом поступить так же, как и в предыдущем случае. Продлить стену мы можем перетаскиванием угловой точки по направлению отрезка стены. Для этого можно использовать режим X так, как раньше было описано при обсуждении перемещения остановок: в этом режиме надо нажать Ctrl и тащить точку в нужном направлении.

Если угол срезан или скруглён и нарисован несколькими точками, подвинуть одну из них, то есть предугловую точку, будет недостаточно. В этом случае нам удобнее работать именно с углом здания и квартала из нескольких точек, а не отдельно с его обеими сторонами. Что именно нам лучше сделать зависит от того, насколько мы стремимся сохранить уже нарисованную форму угла. Часто углы бывают нарисованы плохо, и их имеет смысл перерисовать. С другой стороны, точная форма угла нас может в данный момент не интересовать, и тратить время на неё мы не захотим.

Итак, поскольку мы хотим работать с углом, прежде, чем его трогать, решим какие из образующих его сторон квартала мы будем выравнивать. Все относящиеся к углу направляющие, которых у нас будет либо одна, либо две, мы нарисуем до того, как будем что-либо двигать. Дальше у нас есть три варианта: переделать весь угол, сохранить его примерно и сохранить его точно. В целом примерное сохранение будет самым простым вариантом действий. В точном сохранении смысла вообще может не быть, так как мы всё равно меняем направление примыкающих к углу стен.

Допустим, мы решили угол перерисовать или, наоборот, точно сохранить его. Тогда первым делом мы восстановим несрезанный угол скриптом CornerRestore, так же, как это делалось при получении исходной контрольной точки. Этот восстановленный угол мы будем считать новой *крайней* точкой, а обе предугловые точки этого звания лишаются, становятся *внутренними* точками, и с ними мы разберёмся в [следующим разделе](#align-internal-nodes). Теперь поставим на одну направляющую или на пересечение двух направляющих аналог целевой контрольной точки. Следующим нашим действием будет совмещение аналога исходной точки, то есть восстановленного угла и аналога целевой.

Самым простым способом это сделать будет использование команды слияния точек (M). При этом, правда, пропадает смысл от предшествующего использования CornerRestore, так как аналогичного результата мы могли бы добиться просто рисованием аналога целевой точки на направляющих и объявлением его новой крайней точкой выравниваемых множеств точек. Линии от предугловых точек до восстановленного таким образом угла мы легко можем пририсовать и без скриптов.

В принципе, только что рассмотренный способ может нас устраивать, если мы не собираемся отказываться от полной перерисовки угла. Но есть и другой способ, при котором аналогию со сдвигом по направляющим мы проводим дальше. Выделим все точки угла, то есть предугловые точки, всё, что между ними, и восстановленный CornerRestore угол, затем применим к ним [скрипт Move](../9-guides/#move-script). Это будет сдвигом по одной паре контрольных точек, где в качестве исходной мы укажем восстановленный угол, а в качестве целевой - точку на направляющих. Так мы переместим весь угол без искажений. В этот момент мы можем посмотреть, попали ли передвинутые предугловые точки на направляющие линии. Если эти точки с достаточной для нас точностью находятся на направляющих, это повод отказаться от перерисовки угла. При этом единственной предстоящей модификацией угла будет небольшое перемещение предугловых точек вместе с другими внутренними точками сторон. Если же предугловые точки на направляющие не попали, угол мы перерисуем, но сделаем мы это после выравнивания сторон.

Теперь вернёмся к оставшемуся способу корректировки срезанного угла, когда мы не стараемся точно сохранить его форму, но и выбрасывать её не собираемся. В этом случае мы не будем использовать CornerRestore и ставить вспомогательные точки-аналоги контрольных. Мы просто выделим все уже существующие точки угла и перетащим их вручную, ориентируясь по направляющим. Целью перетаскивания будет совмещение предугловых точек с соответствующими им направляющими линиями. Для всего квартала целиком подобную операцию мы бы выполнить не смогли, так как нам бы не удалось следить за всеми его углами одновременно, из-за чего приходится идти на более сложные способы перемещения элементов. За одним же углом следить вполне реально, так что этим способом мы, скорее всего, и захотим действовать.

Можно заметить, что и разница с предыдущим способом, когда использовался скрипт Move, практически отсутствует. И тогда, и сейчас мы перемещали предугловые точки на направляющие, и делали мы это примерно. Разница только в том, что тогда предугловые точки мы уже не считали крайними, и их точное позиционирование откладывали на потом. Сейчас же предугловые точки всё ещё являются крайними, так как никакой другой замены для них в данном качестве мы не добавили. Значит, нам придётся их точно совместить с направляющими уже сейчас. Сделать это легче всего выделив точку и вызвав команду {% action "MoveNodeWay" %}проецирования точки на линию{% endaction %} (N), которая переместит точку на ближайшую линию. Ближайшей линией должна быть направляющая.

### Команда N

Командой проецирования точки на линию мы, возможно, будем активно пользоваться при выравнивании внутренних точек стороны квартала, так что имеет смысл рассмотреть её подробнее. Также это поможет нам разобраться с некоторыми техническими и историческими причинами, не обязательно актуальными в данный момент, из-за которых мы, возможно, избегали использования этой команды ранее. Команда N особенная в том смысле, что её результат зависит не только от того, какие данные загружены в редактор и какие элементы выделены, но и от того, как мы на них смотрим. Команда обычно перемещает точку в линию, которая находится *рядом*. "Рядом" - это понятие относительное, зависящее от масштаба окна редактирования. Увеличивая изображение в окне редактирования, мы относительно отдаляем элементы данных друг от друга, а уменьшая - приближаем. Это повлияет на работу команды. При достаточно большом увеличении *рядом* с точкой не будет ни одной линии, не считая тех, в которые точка уже входит, и команда не сделает ничего. Если же изображение уменьшить, линий рядом окажется несколько. Нам же *удобнее*, если рядом будет только одна линия - та, в которую мы хотим поместить точку. Именно такой ситуации мы и хотим добиться.

Если мы охарактеризовали команду как перемещение точки в линию *рядом*, а *рядом* линий несколько, то что должно произойти при вызове команды? Можно предположить, что из линий будет выбрана ближайшая, и точка окажется в ней. В текущих версиях [JOSM](https://wiki.openstreetmap.org/wiki/RU:JOSM) это предположение окажется почти верным. Вставка точки сразу в несколько линий произойдёт, если эти линии проходят ровно по одному месту, в частности, если у них есть общий отрезок, в который и вставляется точка.[^11-common] Такая вставка в несколько линий вполне ожидаема, хотя делающая её возможной ситуация не возникнет *перед* интересующим нас применением команды N. Мы хотим провести несколько линий по одному месту *в результате* применения команды, то есть совместить отрезки контуров зданий и направляющую. Пока что мы занимаемся лишь предугловыми точками, но скоро мы рассмотрим совмещение с направляющей и прочих точек контуров зданий.

[^11-common]: Под общим отрезком подразумевается отрезок между парой точек, каждая из которых входит во все линии. Провести линии ровно по одному месту можно и без таких точек, например, сначала нарисовав две линии через общие точки, а потом точки разделив. Вставка с помощью N всё равно произойдёт в обе линии.

Однако ещё недавно, в 2019 году, команда N вела себя совсем по-другому, пытаясь вставить точку сразу во все находящиеся рядом линии, даже если они проходили по разным местам. Сделать так, чтобы одна точка-элемент оказалась сразу в нескольких линиях, которые все вместе не сходятся в одной геометрической точке, нельзя, не изменив формы линий. Изменение формы линий ожидаемым результатом работы команды не являлось, так что работать правильно она не могла. Позже это привело к появлению [бага](https://josm.openstreetmap.de/ticket/18189), вызывающего ещё более странное поведение. После исправления бага разработчики JOSM отказались и от вставки точки в несколько несовпадающих линий, так что это больше не является проблемой.

Поскольку теперь команда N вставляет точку только в одну линию, или в несколько проходящих ровно по одному месту, нам уже не важно, сколько линий окажется *рядом* с точкой. Поэтому выше мы и заявили, что нам всего лишь *удобнее*, а не *обязательно*, чтобы рядом оказалось не более одной линии - направляющей, на которую мы и хотим сдвинуть точку. Правда теперь мы можем задаться вопросом, зачем команда требует, чтобы линия была *рядом*. Не проще ли было бы вставлять точку просто в ближайшую линию, не глядя на то, как далеко она находится? Не исключено, что этим же вопросом зададутся и разработчики JOSM, после чего они, возможно, снова поменяют принципы работы команды. Надеюсь, что это произойдёт не раньше, чем я закончу эту запись, чтобы мне не пришлось снова переписывать данное её место.

Хоть количество линий рядом теперь и не является проблемой, "лишние" линии могут оказаться проблемами само по себе. Произойдёт это, конечно, если они будут находиться ближе к точке, чем направляющая, что при нашем сценарии использования команды N весьма вероятно. Наиболее вероятными "лишними" линиями будут тротуары и landuse, которые проведены весьма близко к зданиям, а в результате ранее нами выполненных преобразований они могли стать и ещё ближе. Приклеивать точки зданий мы к ним не хотим, но команда N при нашей невнимательности может сделать именно это. Да и внимательность нам может оказаться проявить затруднительно: до применения команды надо увидеть, какая из рядом проходящих линий проходит более рядом. Легче внимательность проявить уже по факту результата работы команды: если точка вставилась не в ту линию, действие надо отменить.

Отмена команды N сама по себе проблемы "лишней" ближайшей линии не решит, так как при повторном применении команды мы получим тот же результат. Тут мы могли бы подправить сами "лишние" линии, чтобы они оказались подальше от контуров зданий, ведь в конечном итоге после всех наших действий это и должно произойти. Но такие исправления может оказаться удобнее делать позже, или мы можем не хотеть их выполнять вообще. К счастью, есть довольно простой, правда недокументированный способ заставить команду N проигнорировать все линии, кроме той, в которую мы хотим вставить точку. Для этого перед запуском команды достаточно помимо точки выделить также и нужную линию. Это, кстати, не гарантирует, что команда обязательно сработает, так как линия всё равно должна быть достаточно близко к точке на экране. Зато теперь мы можем спокойно последовать совету из вики "Если не работает, просто уменьшите масштаб и повторите", зная, что после уменьшения команда не зацепит лишние линии. Ещё можно заметить, что команда N игнорирует отфильтрованные линии, но это нам вряд ли пригодится, потому что добавить к выделению направляющую проще, чем подобрать и включить подходящий фильтр.

## Выравнивание внутренних точек стороны очевидным способом { #align-internal-nodes }

Теперь мы находимся в ситуации, когда для отдельно взятой стороны квартала её крайние точки - реальные или восстановленные углы или предугловые точки - находятся там, где нам надо. Возможно они находятся на направляющей линии, если мы решились её нарисовать для сдвига всего квартала или только для выравнивания его стороны. Также возможно, что никакой направляющей у нас нет, но положение крайних точек нас всё равно устраивает. Не устраивает нас положение остальных, внутренних точек стороны, и их выравниванием мы и намерены заняться.

Правильное положение крайних точек даёт очевидную возможность использования команды выстраивания точек по прямой (L). Для этого нам потребуется выделить вместе с крайними и внутренние точки, а затем вызвать указанную команду. Этим способом я пользуюсь чаще всего, но у него есть несколько недостатков. Во-первых само *выделение необходимого множества элементов - это отдельная задача*. Когда нам надо было решать её для всего квартала, мы могли прибегнуть к рисованию вспомогательных линий. Сейчас задача стоит попроще, так как и точек нужно выбрать меньшее количество, и пропустить какие-то из них сложнее. Достаточно двигаться вдоль стороны квартала и выделять все точки, которым следует оказаться на одной прямой. Даже если какие-то из точек окажутся пропущенными, их положение можно исправить без отмены выстраивания в линию всех остальных. Тем не менее, процесс выделения всех точек стороны занимает время, за которое выделение можно потерять, так что понадобится всё повторить. Кроме того, можно выделить и лишние точки, результат чего не будет сразу заметен.

Заметен результат неправильного выделения будет только после выполнения выравнивания всей стороны. Это второй недостаток использования команды L - *отсутствие промежуточных результатов*. Если бы мы действовали самым примитивным способом, то есть двигали каждую точку отдельно, такие результаты бы имелись. До менее примитивного варианта этого способа мы доберёмся ниже. В принципе, на сказанное выше можно дать возражение. Для использования команды L не обязательно выделять все точки выравниваемой стороны. Достаточно выделить две крайние точки и произвольный набор внутри. После применения команды этот набор выстроится в линию, и можно будет проверить и скорректировать затронутые данные как нам угодно, а затем выделить другой набор и повторить операцию. Так выравнивание всей стороны может быть поделено на меньшие этапы, с которыми легче иметь дело.

Проблема тут в том, что выбор точек для команды в сумме становится ещё более трудоёмким. Представим себе, что сторона квартала идёт слева направо. У нас в окне редактирования открыт её левый край, и мы сначала хотим выровнять только самое левое здание. Мы выделяем крайнюю левую точку и все точки здания на краю квартала. Дальше нам надо добавить к выделению крайнюю правую точку стороны, для чего нам придётся прокрутить до её места окно редактирования. Потом нам надо прокрутить окно обратно, чтобы увидеть результат выполнения команды. Дальше, если мы захотим обработать следующее здание, нам понадобится выделить его точки и снова прокрутить окно до крайней правой точки, чтобы выделить и её. Действуя подобным образом на протяжённости всей стороны нам придётся неоднократно прокручивать вид в окне туда-сюда. Единственное используемое нами при этом облегчение - это возможность не выделять крайнюю левую точку, так как вместо неё можно использовать любую из уже выстроенных по прямой точек.

При определённых условиях мы можем облегчить задачу и дальше. Мы можем заметить, что если в множестве выделенных точек помимо крайних находятся и другие точки, уже выстроенные по прямой, то на результат работы команды это никак не повлияет. Этими уже выстроенными точками будут те, к которым мы только что применили команду L. Значит, чтобы применить команду к новому набору точек, нам достаточно добавить этот набор к уже выделенным. Поскольку крайняя правая точка уже входит в выделение, нам не понадобится за ней скроллиться. Последовательность действий в результате получается такая: выделяем крайнюю правую точку, добавляем к выделению крайнюю левую точку, добавляем к выделению первую порцию выравниваемых точек, запускаем команду L, добавляем к выделению вторую порцию, запускаем L и так далее. Если всё пройдёт без заминок, конечный результат будет таким же, как и раньше, когда все точки выделялись перед единственным применением L.

Заминки при только что рассмотренном способе действий, конечно же, возможны. Они возникнут, если выделение будет случайно или специально сброшено. Сбрасывать нам его придётся, если мы захотим подредактировать только что выровненный участок стороны квартала. После этого последовательность действий придётся "перезапустить". При этом, конечно, не обязательно выделять все уже выстроенные точки, достаточно будет выделить любую одну из них, чтобы она выступила в роли крайней левой.

При случайном сбросе выделения можно вспомнить про такую команду, как {% action "UndoSelection" %}восстановление выделения{% endaction %}. Проблема с ней в том, что после её применения нужно убедиться, восстановилось ли выделение как вам надо. Стала ли снова выделенной крайняя правая точка, которая в окно редактирования не попадает? Чтобы это узнать, придётся прокрутить окно до неё, а это то, чего мы хотели избежать.

У использования команды L есть и третья проблема: *оно не совсем правильно перемещает точку*. Когда выше мы говорили о выравнивании крайних точек, мы заметили, что к направляющей их лучше перемещать вдоль смежной стороны квартала. Целью этого было сохранить направление стены здания вдоль смежной стороны, так как ранее мы уже могли потратить время на то, чтобы его точно задать. Стены, идущие вдоль границ квартала, являются самыми важными с точки зрения задания направлений. Но у зданий есть и другие стены, направление которых тоже было бы лучше сохранить. Часть из внутренних выравниваемых точек также находится на углах зданий, в том числе на границах примыкающих друг к другу зданий, следовательно, перемещение этих точек затронет также и направление стен, смежных со стенами, идущими вдоль улицы.

Чтобы при дальнейших рассуждениях было понятно, о какой из стен здания идёт речь, введём для них названия. Эти названия мы зададим относительно той стороны квартала, с которой мы в данный момент работаем, и применимы они будут ко зданиям, расположенным достаточно близко к этой стороне. Стены, находящиеся у края квартала и идущие вдоль его стороны, мы будем называть *передними*. Они обычно будут соответствовать фасадам зданий. Стены, обычно примерно перпендикулярные передним, имеющие с последними общий угол и уходящие вглубь квартала, мы будем называть *боковыми*. *Задними* мы будем называть все прочие стены.

Последний термин мы не стараемся задавать слишком строго, потому что соответствующие ему стены нас интересуют в меньшей степени. Хорошо понятно, как мы назовём стены прямоугольного здания: у него мы найдём одну переднюю стену, две боковые и одну заднюю, которая будет параллельна передней. В общем же случае задняя стена может быть не одна, и никаких ограничений на её направление нет, причины чего мы увидим позже, при рассмотрении поправок проездов. Если у здания есть внутренний двор, задней стеной мы можем назвать любую из стен этого двора, даже перпендикулярную передней. В наших рассуждениях нас будет интересовать только одна из этих стен, нам будет понятно, какая именно, и именно её мы будем называть *задней*. Но это будет позже, а сейчас нас интересуют *передние* и *боковые* стены.

Зададим аналогичные термины и для углов зданий. Углы, [инцидентные](https://ru.wikipedia.org/wiki/Глоссарий_теории_графов#инцидентность) передним стенам, мы тоже будем называть *передними*. Получается, что линия передней стены соединяет точки двух передних углов. *Задними* мы будем называть все прочие углы здания, которые окажутся в глубине квартала. Так линии задних стен будут соединять точки задних углов, а линии боковых стен будут идти от точек передних углов к точкам задних. Мы ввели наши термины для реальных объектов, а не для соответствующих им осмовских элементов или их частей. Для краткости, как и при рассмотрении прочих реальных объектов и соответствующих им элементов, мы можем называть введённым термином и сам элемент. Например, вместо "точка переднего угла", мы можем сказать просто "передний угол", понимая под этим соответствующий элемент-точку.

Вернёмся к тому, что мы делаем с помощью команды L. Выполняемое нами выравнивание стороны квартала применительно к зданиям заключается в перемещении их передних стен посредством перемещения передних углов и прочих точек, входящих в эти стены. Третьей же проблемой команды L является то, что при этих перемещениях могут поменяться направления боковых стен, а мы бы хотели их сохранить. Для сохранения направлений боковых стен их передние углы должны перемещаться вдоль их линий. Следовательно, у нас возникает вопрос, в каком направлении команда L перемещает углы зданий.

Команда L перемещает углы, как и все прочие точки, в направлении, перпендикулярном прямой между крайними из переданных ей точек, то есть перпендикулярно краю квартала и получившемуся после её применения направлению передних стен. Совпадает ли такое направление перемещения с направлениями боковых стен? Может быть оно совпадает в достаточной степени, а может быть и нет, это зависит от геометрии конкретных зданий. Нередко боковые стены перпендикулярны улице, и тогда всё в порядке. В отдельных же случаях угол между боковой стеной и улицей сильно отличается от прямого, но и тогда нам может повезти. Если точка сдвигается на небольшое расстояние, на направление стен здания это повлияет не сильно.

Значит, неприятности нас ждут только в случае достаточно большого расстояния между передним углом здания и направляющей одновременно с достаточным отклонением от перпендикулярного направления соответствующей боковой стены. Неприятности эти легко поправить после выравнивания стороны квартала, чем мы займёмся позже. Впрочем, при неудачных снимках, затрудняющих определение контуров зданий, исправлять направление стен после того, как мы сами его подпортим, будет не так легко. Тогда мы можем решить их сохранить, для чего нам придётся выравнивать сторону квартала другим способом. С другой стороны, мы можем решить и не отказываться от рассмотренного способа, предполагая, что при плохих снимках и исходные контуры зданий были не слишком хороши.

## Выравнивание внутренних точек стороны альтернативными способами

Если нас оттолкнули недостатки использования команды L для всей стороны квартала, какими ещё способами мы можем воспользоваться? Альтернативой использованию L является выравнивание каждой внутренней точки отдельно. Конечно, мы можем выравнивать точки отдельно и с помощью L, но делать это слишком долго, потому что для каждой внутренней точки придётся выделять не только её, но и две крайние точки. Так первая проблема с выделением элементов лишь усугубляется, давая решение второй проблемы в виде промежуточных результатов, но никак не помогая с третьей. Мы бы хотели разбираться с каждой точкой без необходимости обращаться к углу квартала. Раз мы не собираемся указывать в качестве ориентира крайние точки, нам нужен другой ориентир, которым, конечно же, является направляющая линия. Однако, могло так случиться, что направляющей мы до сих пор не нарисовали. Тогда нам придётся это сделать сейчас, а сейчас это более простая задача. Нам достаточно соединить прямой две крайние точки стороны квартала, про которые мы уже решили, что стоят они правильно.

Как поставить точку на линию, выделяя при этом только точку, нам уже известно. Сделать это можно командой вставки точки в ближайшую линию (N). Также нам известны и недостатки этой команды: зависимость от масштаба и от проведённых рядом посторонних линий. Нам придётся проверять каждое применение этой команды, а, возможно даже, и убирать в сторону мешающие линии типа landuse. Особых потерь данных в таком временном перемещении данных не будет, потому что landuse мы потом всё равно перерисуем.

Но, может быть, мы не собирались перерисовывать landuse, и теперь мы создаём себе дополнительную работу? Скорее всего нет, потому что речь идёт только о таких линиях границ landuse, какие могли бы помешать поставить точки стен зданий на направляющую. Для этого линии landuse должны быть ближе или, по крайней мере, не намного дальше от стен, чем направляющая. Так близко к кривым стенам могут быть кривые же границы landuse, которые всё равно придётся выпрямлять. Выпрямление мы начнём прямо сейчас, удаляя из них ненужные точки, повторяющие несуществующие в реальности изгибы стен зданий. К этому придётся добавить отодвигание углов landuse от углов квартала, но это будет временной операцией. После выравнивания стен и возможной перерисовки углов мы поставим на место и углы landuse. Правда, наше понимание о том, где им на самом деле место, может отличаться от понимания наших предшественников, о чём было написано в [главе про landuse](../7-landuse/).

Нам также известна и возможность команды N игнорировать лишние линии, при использовании которой не понадобится убирать их в сторону. Для того, чтобы воспользоваться этой возможностью, перед вызовом команды помимо перемещаемой точки надо выделить и линию, на которую команде следует обращать внимание. Остальные линии команда проигнорирует, из чего, правда, не следует, что точка обязательно будет перемещена в выделенную линию. Произойдёт ли хоть что нибудь, по прежнему зависит от масштаба окна редактирования. Очевидный способ использования команды N при этом такой: выделяем очередную точку из выравниваемого множества, добавляем к выделению направляющую линию, выполняем команду, повторяем, пока не выровняем все точки. У этого способа есть недостаток - надо многократно повторять выделение направляющей. Это выделение может быть затруднено тем, что рядом проходят и другие линии, из-за которых мы и решились на рассматриваемый способ. От команды L мы отказались в том числе и из-за повторных выделений одного и того же, так что не хотелось бы повторять это и здесь.

Впрочем, для L мы придумали и в некотором роде решение проблемы повторных выделений, которое для N подойдёт ещё лучше. Основывается оно на том, что уже выровненные точки, находящиеся в выделении, не помешают выравнивать новые точки. Следовательно, надо постараться не сбрасывать выделение, пока мы не разберёмся со всеми точками выравниваемой стороны квартала. Тогда действовать мы будем так: в самом начале выделим направляющую, добавим к выделению точку, вызовем N, не сбрасывая выделения добавим к нему следующую точку, вызовем N, добавим следующую точку и так далее. Затруднений тут будет поменьше, чем с аналогичным способом для L. Если выделение сбросится так, что его будет не восстановить, нам не понадобится скроллиться к углу квартала. Достаточно будет снова выделить направляющую, которая идёт вдоль всей выравниваемой стороны, и продолжать так, как будто ничего не произошло.

Возможно, что неудобства команды N окажутся достаточными, чтобы мы отказались от её использования. Кроме того, она не решает и третьей проблемы команды L, так как направления боковых стен всё ещё не учитывается при перемещении углов зданий. Тогда мы можем сначала разобраться со всеми передними углами зданий примерно так же, как мы это делали ранее с крайними точками на углах квартала, если мы не использовали выравнивание всего квартала по направляющим. Посмотрим на передний угол здания. К нему подходят две стены: передняя и боковая. Передняя стена встанет на нужное место, как только мы переместим её точки на направляющую. Боковую же стену мы сильно перемещать не хотим, мы хотим лишь продлить или сократить её до направляющей, не меняя направления. Сократить её мы сможем без особых проблем, так как в этом случае направляющая пересекает отрезок стены. Нам достаточно поставить точку на место пересечения и объединить с этой точкой передний угол здания (M). Если стену надо наоборот удлинить, то и в этом случае подходящие действия нам известны. Стену сначала можно удлинить так, чтобы она пересеклась с направляющей, двигая передний угол здания в режиме X, удерживая Ctrl. После этого мы оказываемся в предыдущем случае, когда стену надо сократить.

Часто нам приходится иметь дело с точками, которые соответствуют сразу двум передним углам находящихся вплотную друг к другу зданий, и с примыкающими к таким точкам отрезками линий, по которым проходят одновременно две боковые стены. С ними мы можем поступать точно также, как с углами и стенами, не соприкасающимися с другими зданиями. Проблема будет только в случае идущих в разных направлениях боковых стен разных зданий, сходящихся в одной точке, которую мы решили подвинуть. Проблема эта обычно является лишь формальностью, выражающейся в том, что мы не можем сдвинуть точку пересечения двух линий, не поменяв направления этих линий, при том, что их направления мы собирались сохранять. Большинство подобного вида геометрических конфигураций зданий являются, скорее, результатами неаккуратного рисования, когда для примыкающих друг к другу зданий некоторые их точки были объединены, а некоторые - нет. Стараться сохранять то, что было криво нарисовано, нам не нужно, так что углы, в которых сходятся разнонаправленные стены, мы можем перемещать любым удобным для нас способом. Лучше, конечно, перерисовывать такие места так, чтобы они соответствовали реальности, но мы можем отложить это на потом.

Как только мы разобрались с обоими передними углами здания, можно выстроить в линию и находящиеся между ними прочие точки передней стены. Это можно сделать с помощью команды L, хотя нам доступны и другие средства. Так, если от повсеместного использования команды N мы отказались только для сохранения направлений стен, а не потому что эта команда вставляла точки в неправильную линию, то вместо L можно использовать и N. В этом случае мы можем сразу двигать точки, не откладывая этого до выравнивания обоих передних углов здания.

Используемый здесь способ продления или сокращения линий до пересечения с направляющей можно использовать не только для стен зданий и не только для сторон прочих полигонов. Способ годится и для прочих линий, подходящих к границе квартала или пересекающих её, направление которых нам хотелось бы сохранить. Самыми очевидным представителем таких линий являются проезды, хотя для них толк от способа будет весьма ограничен. Их направление, скорее всего, было уже испорчено перемещением квартала и неперемещением того, с чем они квартал соединяют. Так что разбираться с проездами нам предстоит другим способом.

### Команда M { #merge-nodes }

Поскольку и здесь, и ранее мы могли использовать команду {% action "MergeNodes" %}объединения точек{% endaction %} (M), рассмотрим её поподробнее. Мы прибегали к ней в трёх различных ситуациях:
1. объединения двух точек, находящихся на одном месте;
2. перемещения временной точки на место другой временной точки;
3. перемещения уже существующей в данных точки на место временной точки.

В каждой из этих ситуаций мы выделяли две точки и запускали команду M. С первой ситуацией всё понятно: на месте двух точек останется одна. Вторая же ситуация должна вызвать у незнакомых с принципами работы этой команды вопрос: где окажется точка-результат объединения? Это зависит от порядка выделения точек.[^11-setting] Да, оказывается для команды имеет значение не только выбранное множество элементов, но и то, в каком порядке они были выделены. Для использования M в качестве средства перемещения надо при пустом множестве выделенных объектов добавить в него сначала исходную точку, а затем целевую. Исходная точка переместится на целевую и сольётся с ней.

[^11-setting]: На самом деле в JOSM есть настройка, влияющая на поведение команды, но вряд ли вы меняли её значение.

В первой ситуации нам было неважно, какая из точек является исходной, так что мы могли их обе выделить прямоугольником или лассо. Вопрос: какая из точек окажется исходной, если выделить прямоугольником или лассо точки в разных местах? Ответ: фиг его знает, так что не надо это делать. Может быть, вы решили увидеть ответ на этот вопрос справа, в окне Selection, в порядке перечисления в нём элементов? Зря, этот порядок не зависит от порядка с точки зрения команды M.

В только что рассмотренной третьей ситуации мы вставляли в контур здания новую точку, которая должна стать заменой старой. Почему мы просто не удалили после этого старую точку, а решили переместить её командой M? Решили мы так, чтобы сохранить историю редактирования точки и её идентификатор. Так вместо создания новой точки и удаления старой у нас будет перемещение одной точки, а то, что для этого была создана другая точка, в историю не попадёт. В плане того, чья история сохранится, команда M работает вполне определённым способом: если вы объединяете ей несколько точек, сохранится история самой старой из них.

На самом деле мы тут несколько упростили описание решения, принимаемого командой M на счёт того, историю какой точки сохранить. Сделали мы это потому, что при наших применениях команды такое его описание вполне подходит, и оно гораздо проще настоящего. На самом же деле в некоторых случаях возможно сохранение истории более молодой точки. Произойти это может, потому что команда учитывает, есть ли у точки *родители*. Под родителями подразумеваются либо линии, проходящие через точку, либо отношения, содержащие точку в качестве члена. Замена точки с родителями вызвала бы необходимость изменения и самих родителей, чего команда старается избежать. Также команда учитывает, выгружена ли уже точка, так как невыгруженная точка, имеющая родителей, в любом случае вызовет изменение родителей.[^11-negative] Итого, решение о том, чью историю среди выделенных точек сохранить, принимается согласно следующим приоритетам:
1. Сохраняется самая старая выгруженная точка, имеющая родителей.
2. Если такой нет, сохраняется самая старая выгруженная точка.
3. Если выгруженных точек нет, то и истории ни у какой из них нет, а значит, не имеет значения, какую из временных точек сохранить.

[^11-negative]: В терминологии JOSM невыгруженная точка, то есть та, которая была создана в редакторе, но не была отправлена на сервер, называется точкой с отрицательным идентификатором. Выгруженная называется точкой с положительным идентификатором. В на сервере присутствуют только положительные идентификаторы, отрицательные бывают лишь во временных данных клиента.

Надо также заметить, что команда M не учитывает, выгружен ли сам родитель, хотя это имело бы смысл делать. Значит, проведя через более молодую точку даже временную линию, можно добиться от команды M сохранения именно её, а не более старой точки-сироты. Такие подробности работы команды M нам обычно учитывать не нужно, но есть ситуации, при которых они могут проявиться. Например, ниже речь пойдёт о точках [POI](https://wiki.openstreetmap.org/wiki/RU:Точки_интереса), привязанных к линиям проходов. Разработчикам редакторов такие связи почему-то не нравятся, и редактор, особенно [iD](https://wiki.openstreetmap.org/wiki/RU:ID), пытается подтолкнуть пользователя к извлечению точек POI из линий. Извлечённые точки уже не имеют родителей, так что их повторная вставка в линию командой M снесёт их историю.

Непосредственному вызову команды M есть альтернатива. Если в режиме S начать выполнять обычное перетаскивание точки, дотащить её до другой точки, нажать Ctrl и отпустить кнопку мыши, то произойдёт такое же объединение двух точек. Возможно этот способ вам покажется более удобным, хотя у него есть недостаток: бывает сложно понять, достаточно ли близко перетаскиваемая точка находится от целевой, чтобы произошло объединение. Кстати, можете поэкспериментировать с завершением перетаскивания у точки при нажатом Ctrl с различными наборами выделенных элементов. Чтобы результат отличался от обычного перетаскивания, в перемещаемом множестве элементов должна быть хотя бы одна точка. Но в нём может быть и несколько точек, и не только точки. В результате экспериментов можно обнаружить способ отчасти повторить функциональность скрипта Move, если нас интересует перемещение только линий целиком, а не отдельных точек на линиях или вне них. Что именно для этого надо сделать, и каковы особенности работы этого способа, мы рассмотрим ниже, когда он нам пригодится.

## Поправки расположения точек POI

Выстраивание точек контуров зданий по прямой меняет их форму. Это изменение, хоть оно обычно и незначительное, влияет на относительное расположение объектов внутри зданий. Ещё в начале записи мы приводили крайний пример такого влияния, когда находящиеся внутри здания объекты оказывались снаружи после изменения его контура. При нашем способе действий такое менее вероятно, потому что мы сначала двигаем всё здание целиком вместе с его содержимым, и лишь потом корректируем контур отдельно от содержимого. Но теоретически даже после нашей не столь значительной корректировки что-то может оказаться по другую сторону границы здания. Этого мы точно не хотим, так что нам придётся просмотреть всю границу квартала, все здания на ней на предмет подобных происшествий. Впрочем, не заметить подобного мы могли, только если выравнивали всю сторону одним махом - командой L. В любом случае, мы ещё успеем внимательно осмотреть края квартала в процессе выполняемых нами исправлений, и подобные ошибки от нашего взгляда не уйдут.

Какие объекты внутри зданий могут нам попасться? В основном это точки POI, то есть магазины, общепит и прочее подобное. Конечно, внутри здания может быть много чего, но не обо всём осмерам как сторонним наблюдателям известно, и не всё они считают достаточно значимым, чтобы отмечать. POI же на то и являются *точками интереса*, чтобы быть отмеченными при любой появившейся у осмера возможности. Итак, наиболее вероятная картина, ожидающая нас внутри здания - это пустота, потому что там ничего интересного нет или ничего ещё не отметили, и тогда у нас нет и проблем с тем, что могло бы быть внутри. Вторая же по вероятности картина - это одна или несколько точек POI. Точки эти могут быть расположены хаотично или по какому-нибудь принципу.

В случае хаотичного расположения точек основной целью вносившего их участника было показать, что POI находятся где-то внутри здания. Конкретное же положение соответствующих им объектов точки могут обозначать лишь весьма примерно. Это самый простой для нас случай, потому что нам обычно ничего не нужно делать с такими точками. Только если после сдвига контура здания точка оказалась на улице, нам её придётся подвинуть обратно внутрь. Как именно мы её подвинем - не важно, никакой точности здесь соблюдать не требуется.

Тут нас может ждать небольшая проблема: мы можем не знать, на самом ли деле точки были расположены хаотично. Может быть, их пытались ставить по центрам заведений, а при различной форме и при различных взглядах на то, что включать в площадь заведения, итоговое расположение точек может показаться беспорядочным. Даже если дело обстоит так, мы практически не сможем установить куда надо точно ставить точку. К тому же, мы можем посчитать, что точно её при корявых зданиях поставить было нельзя, следовательно, до нас она точно не стояла. В итоге наш способ исправления POI остаётся таким же: подвинуть оказавшуюся за пределами здания точку так, чтобы она оказалась внутри, неважно каким способом. К этому можно добавить только то, что лучше постараться подвинуть точку на как можно меньшее расстояние, чтобы она не слишком сильно отклонилась от своего принципа расстановки, каким бы он ни был.

Различные способы расстановки точек POI рассматривались в записи [Как я отмечаю POI – Геометрия](https://www.openstreetmap.org/user/Anton%20Khorev/diary/45247). Там же был указан способ, которым обычно пользуюсь я - ставить точки у входа на определённом, то есть обычно одинаковом, расстоянии от передней стены. Ясно, что этот способ совсем не похож на хаотичную расстановку, и перепутать его с ней нельзя. То, что он благодаря своей строгости заметен, можно посчитать за преимущество - встретившись с подобной расстановкой точек мы точно будем знать, что должно получиться после внесённых нами изменений геометрии. Отсюда же следует и недостаток - любой сдвиг передней стены отдельно от всего здания нарушит расстановку точек. Именно такими сдвигами мы и занимались, когда выравнивали стены по прямой. Точки POI были тоже расставлены по линии, и линия эта была параллельна прежнему краю зданий. Теперь, поскольку этот край мы изменили, линия POI уже ему не параллельна, да и расстояние от края поменялось.

Поменяем расстановку точек так, чтобы она соответствовала новым контурам зданий. Как можно догадаться, процесс расстановки точек POI не слишком отличается от расстановки точек контуров зданий, и его можно провести подобными средствами. Поскольку точки POI обычно не входят в линии, у нас не будет сложностей, связанных с необходимостью сохранять направления линий. То есть, точки мы сможем двигать по кратчайшему направлению к той прямой, по которой мы хотим их расположить. Именно так и работают команды L и N, которыми мы можем воспользоваться. Сначала нам надо определиться, на каком расстоянии от стены должны оказаться точки. Тот способ расстановки, который использую я, подразумевает конкретное расстояние, а именно два метра. Поскольку вам, скорее всего, придётся иметь дело не с моими правками, то расстояние может быть другим, поэтому рассмотрим сначала расстановку по произвольному расстоянию.

Первым делом надо выяснить, какое именно расстояние было использовано. Делать это надо было до изменения геометрии, но тогда мы могли об этом не подумать. Если данные изменены уже настолько, что обнаружить в них исходное расстояние невозможно, то это не слишком большая проблема. Поскольку мы собираемся только измерять расстояния на старых данных, а не редактировать их, можно загрузить их ещё раз в новый временный слой. Как собственно производить измерение в режиме параллельных линий, мы уже рассматривали. В роли исходной линии, относительно которой строится измерительная линия-"рейсшина", может выступать контур здания.

Нам, конечно, будет лень возиться с разными слоями только лишь для измерения расстояния точек от стены. Да и вряд ли они очень точно на заданном расстоянии стоят. Проще будет измерять не затронутое место, а аналогичное место рядом с ним. Наверняка POI есть и в соседнем квартале, и расставлены они там, видимо, по такому же принципу. Если принцип был другой, не лучше ли и в редактируемом месте использовать его же? Можно даже вообще ничего не измерять, а решить заново, какое расстояние лучше. Ведь если ваши предшественники и следовали расстановке на определённое расстояние, сам его выбор произошёл, скорее всего, спонтанно. Так что вы можете сказать, что лучше знаете, где именно должна проходить линия для точек.

Тут, конечно, мы можем пойти дальше, и начать сомневаться, важно ли вообще восстанавливать какое-либо определённое расстояние между POI и стенами зданий. Если POI после наших поправок контуров всё ещё остались внутри своих зданий, то это действительно не так важно. По крайней мере, можно оставить это на потом, и выровнять POI по-новой после выполнения всех шагов нашей операции перемещения квартала. Впрочем, потом нам это может оказаться делать лень, и быстрее решить вопрос сразу, пока мы всё ещё держим в уме расположения соответствующих точек и линий.

Важность выравнивания будет тем выше, чем лучше в расположении проглядывается определённая линия, то есть, чем чаще идут стоящие на ней точки и чем длиннее образуемая ими последовательность. Различие в направлении этой линии и линий улицы, тротуара и зданий может стать достаточно заметным. Поскольку о правильности линии зданий мы только что позаботились, можно привести в соответствие с ней и линию POI. Сделать мы это можем проведя настоящую временную линию по тому месту, где мы желаем видеть точки заведений.

В результате всех предыдущих манипуляций у нас есть направляющая линия для стороны квартала. Из неё мы в режиме параллельных линий получим линию для POI. Как мы знаем, по умолчанию расстояние между параллельными линиями изменяется по полуметровым шагам. Этого будет, скорее всего, достаточно, чтобы провести линию на нужном для POI расстоянии. Если нам понадобится задать произвольное расстояние, при перетаскивании параллельной линии надо удерживать Ctrl. Впрочем, делать это почти никогда не понадобится, так как сами POI имеют размеры, превышающие полметра. Отмечая POI точками, мы пренебрегаем их размерами, что гораздо существеннее их общего сдвига на несколько сантиметров. Можно заметить, что и вся наша возня с POI - это тоже сдвиг на несколько сантиметров. Как уже было сказано, смысл в нём есть, когда мы двигаем всю условную линию из точек POI. Отклонений от этой линии на несколько сантиметров туда-сюда для каждой отдельной точки нам избежать важнее, чем отклонения всей линии целиком, если направление линии правильное.

Как поставить точки POI на только что проведённую линию? Как уже было сказано, сделать это можно аналогично перемещению точек контуров зданий, только без дополнительных сложностей, связанных со вхождением точек в элементы-линии. Случаи, когда точки POI входят в элементы-линии, а не просто выстроены в линию без вхождения в какой-либо элемент, или когда POI обозначаются не точками, а полигонами, встречаются гораздо реже. Отдельно стоящие точки POI можно переместить на линию парой способов:
* одним махом, выделив точки концов линии и все точки POI, затем применив команду L;
* по отдельности перемещая точки на линию командой N.
Во втором способе нам может понадобиться выделить и саму линию по уже известным причинам.

Лично мне выравниванием POI по линиям командами L или N приходится заниматься лишь в исключительных случаях. Как рассказано в упомянутой выше записи про POI, у меня есть скрипт PoiAlign, устанавливающий точки на нужное расстояние. Он годится и для перемещения точек после изменения контуров зданий. Чтобы его использовать для POI, надо выделить контур здания и одну или несколько находящихся внутри него точек POI, затем запустить скрипт. Если же какая-нибудь точка оказалась вне здания, перед вызовом скрипта её придётся сначала переместить любым способом внутрь, то есть просто перетащить, либо примерно на то место, где она должна находиться, либо как можно ближе ко входу в POI, если известно его положение.

Основным ограничением PoiAlign является то, что он ставит точки на расстояние именно два метра. Что, если нам нужно другое расстояние? Можно соответствующим образом модифицировать скрипт или написать аналогичный. Почему не передавать расстояние как ещё один аргумент скрипта? Скрипты для плагина CommandLine гораздо легче вызывать, когда у них только один аргумент. Если этот единственный аргумент является набором осмовских элементов, как и есть для PoiAlign, повторный вызов скрипта можно осуществить выделением нужных элементов и двойным нажатием на Enter. Двойной Enter вызывает последний использованный скрипт, выделенные элементы передаются ему в качестве первого аргумента, и, поскольку других аргументов нет, скрипт сразу запускается. Поскольку в процессе исправления стороны квартала выравнивать точки приходится неоднократно, все применения скрипта, кроме самого первого, выглядят так: выделяется контур здания и нужный набор точек в нём, нажимается два раза Enter, выделяется следующий контур и следующий набор точек, нажимается два раза Enter и так далее.

Допустим, что разобраться с обычным набором точек мы сумеем. Что нас может ждать внутри зданий помимо него? В первую очередь это могут быть проходы, ведущие или не ведущие к POI и POI в виде полигонов. Более изощрённым вариантом будут помещения, отрисованные по схеме [Simple Indoor Tagging](https://wiki.openstreetmap.org/wiki/RU:Simple_Indoor_Tagging), в которых тоже могут быть POI, ещё более вероятно обозначенные полигонами. Ясно, что поступать с подобными данными так же, как с отдельными несвязанными точками, уже не получится. Тут даже не выйдет назвать какого-либо общего метода действий. Для нас удобно, что с подобными данными придётся иметь дело гораздо реже, потому что если геометрия здания неправильная, у участников будет гораздо меньше желания вырисовывать подробности внутри. Тем не менее, у особо важных зданий типа вокзалов или крупных торговых комплексов могут оказаться нарисованными внутренние проходы даже при корявом внешнем контуре. Обычно это означает, что и внутренности нарисованы коряво. Раз так, то нам не нужно сильно стараться их исправлять. Если же исправить их хочется, то сразу сделать это всё равно не получится: предстоит экспедиция на место, так как на спутниковых снимках ничего из внутренних деталей не видно.

## Исправления на контурах зданий

После выстраивания стен зданий по прямой у нас появляется возможность двигать по этой прямой находящиеся на ней точки. Этими точками могут быть:
1. углы зданий, сдвиг которых приведёт к изменению формы зданий;
2. неугловые точки, входящие помимо контуров зданий в ещё какие-то линии, возможно даже выходящие за пределы зданий;
3. неугловые точки, ни с чем не связанные кроме контура здания.

Все эти точки мы уже могли двигать поперёк направляющей в рамках выравнивания сторон, теперь же у нас есть возможность или необходимость двигать их вдоль. Можно даже сформулировать смысл выравнивания сторон зданий по прямой в свете перечисленных точек. Выравнивание создало такую ситуацию, что *перемещение вдоль края квартала всех упомянутых разновидностей точек, кроме первой, не приведёт к изменению формы зданий*. Любая точка, входящая в полигон, формально является его углом. Мы сделали так, что точки, не относящиеся к первой разновидности, стали *развёрнутыми* углами, что позволяет нам их собственно углами не считать.

Про перечисленные разновидности точек можно сказать, что ранее выполненными действиями мы их не ухудшили, при одном обычно выполняющимся условии. Тогда если точки в результате оказались неправильно расположены, то это потому, что так было и до нас, и исправлять мы их не обязаны. Если нашей целью является только сдвиг квартала, мы можем не делать ничего из того, про что написано в данном разделе. Условие для сказанного выше такое: точки должны быть в целом поставлены относительно квартала. Точки, конечно, ставятся относительно других точек и относительно зданий, а здания - относительно других зданий, но все вместе они должны быть поставлены относительно квартала в тех границах, в каких мы его весь взяли и передвинули.

Это условие нарушается, когда кто-то рисует отдельную часть квартала по отличающемуся от всего прочего смещению. Мы уже говорили, что так могут поступать те, кто занимается уточнениями по вновь появившимся снимкам. Новый снимок может быть выровнен по-новому, причём гораздо лучше. В этом случае уточнённые места лучше было бы не двигать вместе со всем кварталом, но их может быть трудно отделить от элементов, которые двигать надо. Сдвинув их, мы с определённой точки зрения их ухудшили. Если эти места включают в себя точки на краю квартала, мы можем посчитать нужным поправить их положение. В общем же случае для поправки их положения могут обнаружиться и другие причины.

Необходимость выполнить сдвиг вероятно была обусловлена желанием нарисовать что-то на зданиях или очень близко к ним. Для этого мы в первую очередь хотим, чтобы сами здания имели правильную протяжённость вдоль улицы. Нас может не интересовать правильность формы зданий целиком, потому что мы не залезали вглубь квартала, но нам не обойтись без правильности расположения их передних углов. Передние углы как раз и являются первой из перечисленных выше разновидностей точек. То, что мы не ухудшили положение этих точек уже выполненными действиями, теперь не будет хорошей причиной ничего не трогать, если протяжённость зданий была и осталась неправильной. Нам её понадобится исправить независимо от того, откуда взялась эта ошибка.

Переместив угол здания, мы можем ухудшить относительные положения точек прочих разновидностей, так что придётся заняться и ими. Под *относительностью положения* точки имеется в виду такое её местонахождение на прямом отрезке между двумя углами здания, что точка делит отрезок на две части *в определённой пропорции*. Самым важным видом такого положения является нахождение точки ровно по середине отрезка. Ясно, что после сдвига переднего угла такая точка окажется уже не по середине отрезка со сдвинутым углом, и что следовало бы это исправить. Середина является самой простой и заметной пропорцией, но, в принципе, пропорции могут быть любыми, и любая точка отрезка соответствует какой-то из них. Однако мы не можем ожидать, что все точки внутри отрезка были расположены относительно него, то есть, что соответствующие пропорции кто-то *сознательно определял*. Следовательно, нам придётся разбираться, стоит ли двигать каждую из точек, и если да, то как и куда.

Ко второй разновидности относятся точки, входящие в линии внутриквартальных проездов, особенно тех из них, которые проходят через арки в зданиях. Собственно, мы начнём пользоваться словом *арка* в данной записи для обозначения подобных точек, а именно точек пересечения линии проезда и контура здания. Наверняка мы будем пользоваться этим словом совсем неправильно с архитектурной точки зрения, потому что нас не будет волновать, действительно ли то, через что проходит проезд, конструктивно является аркой. Также мы не будем называть аркой всю протяжённость проезда в площади здания, для этого мы воспользуемся термином *тоннель*, соответствующим осмовскому тегу {% tag "tunnel=*" %}. Точки же арок мы дальше поделим на *передние* и *задние*, подобно тому, как мы поступили ранее с углами зданий. Во вторую разновидность исправляемых точек попадают именно *передние арки*.

К передним аркам и прочим точкам пересечения проездов и края квартала у нас будет особое отношение. Хотя мы и заявили, что наши предыдущие действия не ухудшили положение точек, они могли ухудшить геометрию содержащих их линий проездов. Это могло произойти за счёт того, что мы не сдвинули точки соединения с улицей или тротуаром вместе со всем кварталом. Но мы могли некоторые из них и сдвинуть, в частности, мы могли сдвинуть весь тротуар вокруг квартала. Тогда имеет смысл отнести ко второй разновидности и точки пересечения проезда с тротуаром, особенно, если тротуар был выпрямлен, как и стены зданий.

В некотором смысле причиной рассмотрения сдвигов точек вдоль направляющей именно в этой записи является необходимость исправить проезды. Если бы не вносимые перемещением квартала искажения проездов, подобные сдвиги мы могли бы объявить отдельной задачей, рассмотрению которой здесь не место. Поправка же проездов может потребовать не только перемещения точек за пределами квартала, которых мы пока не трогали, но и дополнительного сдвига точек на границе и внутри него, в первую очередь арок. Из-за необходимости в добавок к этому сохранения относительного положения арок, нам может понадобится сдвигать и углы зданий, ведь относительность может требовать не только упомянутого ранее сдвига арок в результате сдвига углов, но и противоположного - сдвига углов в результате сдвига арок. Перемещение же углов и арок может вызвать необходимость двигать точки третьей разновидности и даже точки внутри здания. Как бы нам ни хотелось отложить эти сдвиги, обычно обнаруживается та или иная причина выполнить их прямо сейчас.

Точки третьей разновидности для нас наименее важны. Если нас не вынудили заняться ими перемещения точек, упомянутых ранее, то разбираться с ними мы станем, только если они в своём текущем положении мешают нам дорисовать какие-либо детали. Зато с такими точками иметь дело легче всего, особенно, если между их текущим и целевым положением нет других точек. Поэтому мы и начнём рассматривать такие перемещения точек, когда им ничто не мешает, и каждую точку можно двигать отдельно. Сложности, которые нам могут помешать, мы рассмотрим позже.

### Перемещение отдельных точек

Способы перемещения отдельных точек вдоль стены здания можно поделить на *зависимые* и *независимые относительно отрезка стены*. Начнём с *независимых* перемещений, которые используются, когда точку надо поставить относительно снимка или gps-координат. Первый способ, который может прийти в голову тому, кто не читал этой записи - это просто перетащить точку в режиме S. Такое перемещение искривит линию стены, поэтому сразу после него линию надо снова выпрямить. Это можно сделать, выделив точку и две соседние точки с обеих сторон от неё, затем вызвав команду L. Если вы запись читали, то вы знаете, что это не лучший способ, и перемещать отдельные точки лучше по-другому. Однако его вариация далее нам пригодится для перемещения нескольких точек сразу.

Способ, который читателям данной записи уже хорошо известен, таков: перейти в режим X и перетащить точку вдоль линии, удерживая Ctrl. Линия при этом не искривится, и исправлять её командой L не понадобится. Именно так мы и станем перемещать точки, когда для этого не будет препятствий. Правда, одно ограничение мы уже указали: так нельзя перемещать несколько точек одновременно. Предварительное выделение точек не поможет, так как в режиме X выделения просто игнорируются.

Перемещения, *зависимые* от отрезка, используются, когда точку надо поставить в соответствии с какой-нибудь пропорцией. Самый простой вариант - это когда точку надо поставить ровно по середине отрезка. В более общем случае точку надо поставить ровно по середине между двумя заданными точками. Если перемещаемая точка уже находится примерно между двумя точками концов отрезка (или двумя заданными точками), достаточно выделить все три эти точки и использовать команду {% action "DistributeNodes" %}распределения точек{% endaction %} (Shift+B). Если перемещаемая точка не находится между теми двумя, относительно которых мы хотим её поставить, её туда можно примерно передвинуть обычным перетаскиванием в режиме S. Прямоту линии стены восстановит последующий вызов команды Shift+B. При типичном развитии событий, если под отрезком подразумевается вся стена здания, точка всегда будет находиться примерно между концов отрезка, и выполнять обычное перетаскивание не понадобится. В других случаях, когда отрезок определяется двумя произвольными точками на стене, применению Shift+B может предшествовать ручное независимое перемещение в режиме X и точек-концов, и точки-середины.

Что, если точку надо переместить не на середину отрезка, а на треть? Допустим, мы хотим, чтобы слева от точки была одна треть отрезка, а справа - две. Мы всё ещё можем добиться подобного результата с помощью команды Shift+B, только теперь нам не хватит трёх точек. Поскольку команда расставляет выделенные точки так, что между ними будут одинаковые расстояния, а расстояние справа от перемещаемой точки должно быть вдвое больше расстояния слева, нам придётся добавить туда ещё одну точку. Мы добавим новую точку справа от перемещаемой так, чтобы после действия команды она бы разбила вдвое большее расстояние пополам, после чего все расстояния между соседними точками станут одинаковыми.

Справа от перемещаемой новую точку можно поставить лишь примерно. Более того, её удобнее не включать в линию отрезка стены, то есть поставить немного сбоку от него. Точка это временная, так что после вызова команды её следует удалить. Не включив временную точку в линию, мы не создадим новой версии этой линии, не затронем лишний элемент. Конечно, нам будет удобнее, если найдётся реальная точка, которую надо поставить на треть отрезка с другой стороны. Тогда мы сможем использовать её вместо временной и переместить обе точки за один вызов команды Shift+B.

Метод с использованием команды Shift+B можно обобщить для перемещения точки на любое место отрезка, выражаемое рациональной дробью между 0 и 1. Например, если мы хотим, чтобы слева от перемещаемой точки было 3/5 отрезка, а справа - 2/5, нам надо поставить слева две временные точки, а справа - одну. Конечно, с ростом знаменателя дроби такой способ действий становится всё менее и менее практичным. Ради перемещения одной точки нам не слишком захочется добавлять десяток, который мы сразу удалим. Необходимость использовать большое количество временных точек может быть вызвана именно необходимостью поставить определённым образом друг относительно друга существенного количества настоящих точек. Тогда между настоящими точками по определённому принципу вставляются временные и ко всему множеству точек применяется Shift+B.

Если настоящих точек мало, то мало и смысла получать точную дробь для Shift+B. Проще будет подвинуть эти точки в режиме X, не особо заботясь о точности их установки. Поскольку пока мы говорим о перемещении только одной точки, дальнейшие рассуждения про Shift+B нам придётся отложить. Расстановку же большого количества точек с помощью этой команды мы в этой записи рассматривать не будем, так как это выходит за рамки решаемой нами сейчас задачи. При выполнении поправок после сдвига квартала, Shift+B мы чаще всего будем использовать для установки точки посередине без помощи временных точек. Точкой, устанавливаемой посередине, обычно будет арка или вход в здание.

Если у нас есть серьёзная необходимость поставить точку на место в отрезке, выраженное дробью или пропорцией, а много временных точек ставить не хочется, есть другой способ. Можно вызвать скрипт NodeProportion из моего набора, который принимает три аргумента: точку начала отрезка, точку конца отрезка и выражение места для точки относительно отрезка. Точки начала и конца надо передавать последовательно, так как их порядок важен. То есть, не надо запускать скрипт при уже выделенных двух точках, лучше перед его запуском вообще ничего не выделять. Третий аргумент надо передать либо в виде дроби формата `a/b`, либо в виде пропорции `c:d`, где вместо букв будут числа. Для приведённого выше примера с установкой точки на 3/5 длины отрезка третьим аргументом должно быть либо 3/5, либо 3:2.

Результатом работы скрипта будет создание точки в нужном месте. Точка эта не будет включена в линию, потому что о линии скрипт не знает, да и наличие линии не обязательно для его работы. Не обязательно даже наличие осмовских элементов-точек, выступающих началом и концом реальной или предполагаемой линии, но при нашем сценарии использования они существовать будут. Правда, для нас и не важно, входит ли добавленная скриптом точка в линию или нет. Нам достаточно переместить интересующую нас точку на добавленную слиянием с помощью команды M. На самом деле, нам вряд ли понадобится пользоваться этим скриптом при решении нашей текущей задачи. Точной установкой точек можно заняться и потом, а сейчас нас должно интересовать лишь исправление явных ошибок из-за перемещения квартала, и то, что легко сделать заодно.

### Перемещение углов здания

Таковы основные доступные нам средства перемещения отдельных точек вдоль стен зданий. Но, как мы знаем, точки могут быть не вполне отдельны, и тогда перечисленные средства не вполне подойдут. В чистом виде эти средства годятся для точек третьей разновидности, но они для нас наименее важны. Самой важной является первая разновидность точек, то есть те точки, перемещение которых вызовет изменение формы зданий. Какие бы точки мы в итоге не решились двигать, начинать нам лучше именно с первой разновидности.

Мы уже говорили про сохранение направления стен достаточное количество раз, чтобы читателям сразу стало понятно: перетаскивать лишь один передний угол у здания - не слишком хорошая идея. Если здание имеет прямоугольную форму, перетаскивать надо две точки, соответствующие боковой стене, то есть ещё и задний угол. Если мы их будем двигать точно параллельно улице, то мы не повернём ни перемещаемую стену, ни перпендикулярные ей. Описанные выше способы для такого перемещения двух точек без соответствующих модификаций не годятся. Некоторые из них вообще бессмысленны для текущей задачи. Перемещения относительно отрезка передней стены нам не подойдут, потому что мы собираемся изменить сам этот отрезок. Значит, из рассмотренного у нас остаётся обычное перетаскивание в режиме S и перетаскивание в режиме X. К этому мы можем добавить один уже известный нам скрипт.

Рассмотрим сначала режим S. Довольно очевидно, как в нём перетащить сразу две точки: их надо предварительно выделить. Также понятно, как перетащить и большее количество точек. Та сторона здания, которую мы хотим сдвинуть, не обязательно состоит из одной прямой стены. Более того, мы можем захотеть сдвинуть и прочие объекты, не входящие в контур здания, но определённым способом относительно него расположенные. Среди этих объектов может быть что угодно, расположенное рядом с перемещаемой стеной или выстроенное параллельно ей, особенно, если оно находится со стеной на одной прямой. Достаточно всё это выделить и вместе перетащить.

Перетаскивая так несколько точек, мы сохраним их взаимное расположение и направление проходящих между ними линий. Направление же линий, включающих помимо перемещаемых точек и другие, мы можем исказить. К таким возможно искажаемым линиям относятся передние стены зданий, направленные вдоль улицы, а искажать их мы вовсе не хотим. Правда, из описанного выше аналогичного перетаскивания лишь одной точки, мы знаем как их выпрямить обратно. В итоге способ действий выглядит так:
- определяем множество точек, которое необходимо подвинуть;
- выделяем его;
- перетаскиваем его так, чтобы стены вдоль улицы как можно меньше отклонились от прямой, по которой мы их выравнивали;
- сбрасываем выделение;
- поскольку идеально перетащить не получится, выделяем только что перемещённую точку, которая должна быть на прямой; этой точкой обычно является передний угол здания;
- добавляем к выделению две точки с двух сторон от только что выделенной, которые точно на прямой;
- используем команду L, чтобы выпрямить стены вдоль улицы.

Стараться двигать передний угол здания вдоль прямой, несмотря на то, что стены мы там потом выпрямим, надо ради других стен, которые погнутся. Например, если здание прямоугольное, то помимо стены вдоль улицы у него есть параллельная ей стена сзади, которая точно так же изогнётся. Однако исправить её с помощью команды L уже, скорее всего, не выйдет, потому что здания с задней стороны по линии уже не выстроены. Здания могут быть разной ширины, и даже совсем не прямоугольные. Однако, мы можем предположить, что вряд ли наши предшественники их так точно рисовали, что наш сдвиг их существенно испортил. Более важную переднюю стену мы после сдвига исправляем, а про менее важные задние говорим, что и так сойдёт.

Что, если говорить, что и так сойдёт, не хочется? Мы можем попытаться поправить задние стены после сдвига точек вдоль улицы или выполнить сдвиг по-другому. Если мы хотим, чтобы задняя стена тоже была параллельна улице, мы можем поправить её плагином AlignWays. Проще всего нам будет, если здание на самом деле прямоугольное, или, хотя бы все его углы прямые. В результате сдвига некоторые углы станут непрямыми, далее мы командой L выпрямим стену вдоль улицы, а затем можно сделать прямыми все углы командой Q. Нам нужен вариант этой команды с выравниванием относительно заданной прямой. Этой прямой будет, конечно, линия стены вдоль улицы, которую мы только что снова выпрямили. Прямая задаётся двумя точками, добавленными к выделению модифицируемых командой линий. Точки эти останутся на месте, что нам и нужно. Получается, что нам нужно выделить контур здания и два его передних угла, а затем выполнить команду Q.

Команда Q нам ещё пригодится для более простых случаев исправления проездов. Использовать же её для зданий нужно осторожно. Ещё в главе [*Аргументы против*](../3-counter/) приводились примеры необоснованной регуляризации, когда командой Q удалялись реальные детали зданий. Одной из причин этого является реализация команды в JOSM, которая превращает все углы либо в прямые, либо в развёрнутые. Затрагивает команда даже углы, весьма далёкие от кратных 90 градусам, что отличается, например, от реализации аналогичной команды в [Vespucci](https://wiki.openstreetmap.org/wiki/RU:Vespucci). Но как бы эта команда реализована ни была, возможность испортить данные с её помощью всё равно будет существовать.

Из сказанного выше следует, что если у здания есть непрямые углы, применять к нему команду Q нельзя ни для каких целей. Тут мы, конечно, говорим не про само здание, а про его представление в осме. Если в реальности непрямые углы у здания есть, но их никто не нарисовал, и вместо этого имеется приближённая форма только с прямыми углами, то использованию Q это не помешает. Часто непрямые углы есть только у мелких деталей, которые нашими предшественниками были сочтены незначимыми, хотя, скорее, их просто не заметили. Зато если эти детали были нарисованы, их нужно заметить уже нам. Если их не видно сразу, можно временно применить команду Q к зданию ещё до того, как мы внесём в него какие-либо изменения. Так, если мы заметим, что что-то где-то сдвинулось, то там есть непрямой угол. Возможно, и даже скорее всего, это будет следствием неаккуратного рисования, так что нам ещё нужно будет решить, стоит ли пытаться сохранить именно такую геометрию здания.

Можно придумать ещё много способов сделать отрезки контура здания параллельными улице, если Q нам не подходит. Можно даже заставить работать команду Q с отдельными частями контура, нарисовав для них отдельные линии, или разрезав на них контур, {% action "OrthogonalizeShape#Complexbuildings" %}как показано в справке к команде{% endaction %}. Как видно, весь вопрос в том, сколько мы готовы возиться с каждым отдельным зданием. Скорее всего, в данный момент мы не очень готовы, потому что мы всё ещё не завершили более важное действие - сдвиг всего квартала, и поправки к нему мы собираемся делать либо самые простые, либо реально необходимые. Команда Q в тех случаях, когда она применима, и является простой для использования поправкой, этакой кнопкой "сделать лучше". Хотя мы не всегда можем её использовать, для действительно прямоугольных зданий она является очевидным выбором.

Вернёмся к выполнению перемещения набора точек так, чтобы не исказить направления отрезков, соединяющих этот набор и точки, которые мы не трогаем. При одинаковом перемещении произвольного набора точек не исказить соединяющие отрезки возможно, только если все они параллельны друг другу. Применительно к нашей ситуации это значит, что все соединяющие отрезки параллельны линии, по которой были выровнены здания. Команду Q выше мы пытались использовать в ещё более ограниченных условиях, которые касались не только соединяющих, а вообще всех отрезков, то есть всей линии контура здания целиком. Сейчас у нас будет больше свободы, и приведённое выше условие можно пересказать так: надо, чтобы задняя стена здания была параллельна передней.

Перемещение мы можем осуществить уже известным нам скриптом Move. Сначала нам надо поставить точку в то место, куда мы хотим переместить передний угол здания. Мы вставим временную точку в стену здания или в направляющую линию, либо поставим её примерно, а затем переместим на нужную линию командой L. Эта точка послужит целевой для перемещения, а исходной выступит сам передний угол. Таким образом нам надо будет:
- поставить целевую точку;
- выделить множество перемещаемых точек;
- запустить скрипт Move, который получит выделенное множество в качестве первого аргумента;
- кликнуть на угол - исходную точку - второй аргумент;
- кликнуть на целевую точку - третий аргумент, после чего произойдёт перемещение;
- объединить оказавшиеся на одном месте угол и целевую точку командой M.

Возможность поступить только что описанным способом более теоретическая, чем практическая. Я даже не припомню, пользовался ли я ей для поправок формы зданий. Необходимость добавить временную точку, а потом от неё отделаться создаёт слишком много возни для каждого здания, ведь подобные поправки редко необходимы лишь для одного из них. Временных данных у нас и так хватает, да и толку от такой операции может не быть, если задняя стена не параллельна передней.

Пока что мы рассматривали ситуации, когда приходилось двигать сложное множество точек, то есть непрямую стену или стену вместе с находящимися рядом объектами. Но часто таких сложностей нет, и нужно устранить несовпадение с реальным положением лишь у прямого участка боковой стены. Тогда вместе с передним углом здания, то есть точкой первой разновидности, достаточно подвинуть лишь задний угол. То есть, надо подвинуть лишь один отрезок из двух точек, и удлинить или укоротить ещё два перпендикулярных ему отрезка.

Самым простым таким случаем будет прямоугольное здание, к перемещаемой стене которого не примыкает другое здание. Тут мы наверняка догадаемся, что можно использовать режим X по его прямому назначению - как раз, когда мы тащим отрезок, а не отдельную точку. Ещё лучше подойдёт родственный ему режим XX с выравниванием по двум примыкающим отрезкам, который сохранит направления передней и задней стен, даже если они непараллельны. Если же к стене что-либо примыкает или касается её, так что на ней есть ещё точки, переместить в этом режиме всю стену целиком будет не так просто.

Если здание ортогонально, в режиме X можно перетащить вдоль улицы только передний угол, а затем можно исправить всё здание с помощью команды Q, как рассматривалось выше. Разница с предыдущим вариантом применения Q в том, что задний угол и точки примыкания чего-либо к стене мы самостоятельно не двигаем, полностью поручая это дело команде. Предыдущий вариант был нужен, когда помимо этих точек, расположенных на прямой стене, надо было двигать и другие, чего поручить команде Q мы не могли. Если такие точки есть, или нет никакой ортогональности, нам придётся вернуться к рассмотренным ранее способам перемещения точек первой разновидности и последующей корректировки контуров зданий.

### Перемещение точек, связанных с линиями

Так мы разобрались с контурами зданий с точки зрения их протяжённости вдоль улицы. Теперь можно заняться точками второй разновидности. Использовать для них способы перемещения отдельных точек можно настолько, насколько мы готовы исправлять искривлённые таким перемещением линии. Иногда мы весьма готовы это делать, потому что это очень просто, или потому что линии были уже искривлены до того. В последнем случае речь идёт, конечно же, о проездах и точках их пересечений с контурами зданий. Исправление линий проездов - это отдельная тема, которой мы займёмся попозже, так что точки их пересечения с контуром здания мы пока можем двигать, не обращая внимания на их линии. И наоборот, поскольку линии всё равно уже погнуты, мы можем заодно уточнить и точки их пересечения. В общем, к этим точкам мы будем относиться примерно так же как и ко входам в здание и прочим точкам третьей разновидности.

Что у нас осталось во второй разновидности? В основном это *входы в здания с пририсованными к ним проходами*, как снаружи, так и внутри здания. Например, снаружи любят пририсовывать лестницы-спуски в цокольный этаж, хотя могут пририсовать и простой прямой проход до тротуара. Внутри бывают короткие проходы до одной или нескольких POI, а бывают и длинные, возможно, идущие насквозь через здание. Ясно, что при перемещении входа нам придётся что-то делать с присоединёнными к нему проходами. Обычно мы хотим их сдвинуть вместе со входом, особенно, если они короткие. Длинные прямые проходы имеют много общего с рассматриваемыми далее проездами, и разбираться с ними мы можем соответствующим образом, относясь к перемещаемой точке второй разновидности как к арке.

Короткие проходы, возможно разветвляющиеся и ведущие к точкам POI и соединяющиеся с контуром здания только в одной точке входа имеет смысл двигать целиком со входом и всем, к чему они ведут. Здесь более всего подходит рассмотренное ранее перемещение множества точек скриптом Move, хотя теперь нам легче выделять для перемещения уже не точки, а линии проходов. В роли исходной контрольной точки будет вход, в роли целевой - временная точка, поставленная нами в то место контура здания, где вход должен оказаться.

Для перемещения коротких разветвляющихся проходов есть способ и получше, воспользоваться которым мы сможем благодаря достаточности выделения линий. Помните, что ранее предлагалось [поэкспериментировать с завершением перетаскивания при нажатой клавише Ctrl](#merge-nodes)? Сейчас мы воспользуемся не вполне стандартным применением такого перетаскивания. Стандартное применение выглядит так: берётся одна точка и перетаскивается на другую при нажатом Ctrl, что приводит к слиянию точек. Теперь же мы хотим перетащить точку вместе с несколькими линиями. Ясно, что слить линию с точкой невозможно, поэтому перетаскиваемые линии останутся даже после Ctrl-сбрасывания на целевую точку. Зато выделенная перетаскиваемая точка будет слита с целевой, при этом линии будут перемещены на столько же, на сколько и точка. Это и является желаемым результатом.

Обратим внимание на то, что перемещаем мы не одну точку, а все точки, входящие в набор линий, и только их, значит, если надо переместить также и точки, не входящие в линии, этот способ не годится. Непосредственно выделяем же мы только одну точку - исходную контрольную, на остальные точки наши действия повлияют, потому что они входят в линии, выделенные вместе с исходной точкой. Итого, нам надо сделать следующее:
- поставить целевую точку на стену здания;
- выделить исходную точку, которой обычно будет вход в здание;
- добавить к выделению все линии, которые должны быть перемещены - ими обычно являются проходы, ведущие от входа к каким-либо точкам внутри здания, хотя это может быть и проход снаружи, ведущий к тротуару;
- начать перетаскивать всё это, подведя указатель мыши к любому из выделенных элементов, нажимая и удерживая кнопку мыши;[^11-any]
- нажать и удерживать Ctrl и перемещать указатель к целевой точке, указатель при этом изменится, когда будет подвинут достаточно близко;
- отпустить кнопку мыши, что приведёт к выполнению желаемого действия, а затем отпустить и Ctrl.

[^11-any]: Да, к любому, то есть, можно тащить, даже взявшись за линию и не обязательно рядом с исходной точкой. Конечно, более интуитивно эти манипуляции выглядят при перетаскивании за исходную точку, но даже если мы взялись за другое место и подтащили к целевой точке его, при Ctrl-отпускании все выделенные элементы сместятся так, что на месте целевой точки окажется исходная.

По сравнению с использованием команды Move у указанного способа есть пара преимуществ. Нам не нужно вызывать саму команду, набирая её или ища в меню, и не нужно последовательно передавать ей аргументы. Также нам не нужно после перемещения элементов выполнять отдельно объединение исходной и целевой точек, про что можно забыть. В только что рассмотренном способе исходная точка не просто перемещается на целевую, но и сразу объединяется с ней. Также можно указать и следующий недостаток: переместить без проблем указанным образом можно лишь небольшое количество элементов. Дело в том, что у перетаскивания есть защита от случайного перемещения слишком большого набора элементов. Реализована она так, что при подобном перемещении появляется диалог, требующий подтверждения действия. Появление этого диалога конфликтует с нашим нестандартным использованием ctrl-сбрасывания.

Отдельно среди точек второй разновидности можно отметить *входы в метро* - проходы через них могут соединяться с подземными объектами, которых мы старались не двигать вместе с кварталом. Например, в Петербурге многие станции метро имеют длинные эскалаторы. Эти эскалаторы как проходы соединяются с проходами в наземном вестибюле, которые соединяются со входом и выходом. Проходы в вестибюле придётся подвинуть в соответствии с необходимыми перемещениями входов-выходов. Эскалаторы же желательно не двигать или, по крайней мере, только сократить или удлинить их, не меняя направления, чтобы не трогать того, что находится за ними. В результате не выйдет просто взять и всё синхронно сдвинуть, и понадобится решать, что делать с каждым отдельным элементом.

Ещё среди точек второй разновидности могут быть те, которые входят в *POI, обозначенные полигонами*. Часть контура таких POI может совпадать с частью контура здания, и нас интересует именно этот случай. Тогда сдвиг краёв POI становится похож на сдвиг точек первой разновидности, где полигон заведения подобен зданию. К счастью, форма полигонов POI обычно более простая, чем форма зданий, и часто у нас не будет необходимости синхронно перемещать сложный участок контура. Поскольку такие POI обычно не рисуют точно, у них высокие шансы оказаться просто прямоугольниками, а с прямоугольниками мы легко справимся режимом X или перетаскиванием углов вдоль линии и командой Q. Ситуацию может осложнить наличие объектов внутри заведения, например, банкоматов, но, обычно, для нас не очень важно, как именно мы их подвинем. Скорее всего, ничего страшного не будет, если подвинуть их отдельно от стены. Вряд ли они были особо точно поставлены, это же не серьёзный indoor mapping...

Если *серьёзный indoor mapping* всё-таки имеет место, он является ещё одним источником точек второй разновидности. Они находятся там, где с внешней стеной здания соединяются внутренние стены, ограничивающие нарисованные помещения. Тут мы уже не сможем передвигать внутренности здания как попало, и вряд ли удастся дать совет, подходящий для всех случаев. В целом оказаться в ситуации с необходимостью двигать indoor отдельно от квартала мала. Во-первых, сам indoor не слишком распространён, а во-вторых, мы работаем с неточно нарисованными зданиями, и те участники, которые хотели бы рисовать indoor, предпочли бы сами уточнить и здания.

### Перемещение прочих точек

Теперь осталась только третья разновидность точек, в которую мы сослали и передние арки из второй. Для неё подойдут перечисленные ранее способы перемещения отдельных точек без каких-либо модификаций. Тут уже довольно часто приходится использовать перемещение точек относительно отрезка стены с помощью Shift+B. Нередко ровно по середине передней стены здания расположена арка или вход. При этом, что иногда бывает удивительно, точка арки или входа может быть нарисована нашими предшественниками далеко от середины. Также мы и сами могли испортить относительное расположение точки сдвинув передние углы здания, и теперь её положение надо восстановить. Команда Shift+B как раз лучше всего подходит для выполнения подобных правок.

Помимо середины, точки часто бывает нужно поставить на треть или на четверть длины отрезка. Обычно добавление таких точек выполняется просто на глаз, а в качестве дополнительного ориентира при этом выступает плюсик для вставки точки на середине отрезка. Причиной отказа от точности служит то, что рисующему осмеру бывает лень добавлять и удалять временные точки, необходимые для использования команды Shift+B. Если лень и нам с нашей задачей перемещения существующих точек, мы можем просто Ctrl-перетащить их в режиме X. Однако, если в данных уже имеются настоящие точки, которые подойдут для команды Shift+B вместо временных, или мы хотим такие точки сразу добавить, имеет смысл использовать именно эту команду. Например, если посередине стены находится арка, а по четвертям - входы, то легче всего использовать именно эту команду, применив её сразу к двум углам, двум входам и арке. Подобным же образом мы можем поступить и с большим количеством точек, которые должны оказаться на одинаковом расстоянии друг от друга.

Конечно, точки на стене часто не стоя́т и не должны стоять на какой-либо простой пропорции отрезка. Они даже могли быть поставлены совсем не относительно отрезка. Другим способом их установки могла быть установка *наугад*, установка *по gps* и установка *по снимку*. *Наугад*, бывает, ставят точки POI внутри зданий, когда известны только их адреса, а для точек на контурах зданий это нетипично. *По снимку* же установка точек на контурах весьма вероятна. Может быть доступен снимок, выполненный под таким углом, что хорошо будет видна стена здания. В главе [*Подготовка к сдвигу по направляющим*](../9-guides/) мы такие снимки называли *очевидно непрямоугольными*. На стене при этом обычно можно разглядеть ряды окон и водосточные трубы, арки и двери. Арки и двери могли быть отмечены прямо по снимку, а окна и трубы могли выступить ориентирами для прочих объектов.

Руководствуясь снимком, мы тоже можем исправить положение существующих объектов или добавить новые. Исправлять нам придётся в частности те объекты, которые были поставлены по снимку, не подогнанному под смещение здания. Поскольку мы сейчас занимаемся исправлениями после сдвига квартала, абсолютное смещение здания было неправильное, а, значит для относительно правильной установки объектов и снимок должен был быть сдвинут относительно своего абсолютно правильного положения. Если же кто-то рисовал объекты на сдвинутом здании по несдвинутому снимку, после нашего сдвига квартала положение объектов станет неправильным и нам его придётся исправлять. Примерно то же можно сказать и про установку объектов *по gps*, хотя часто точности у них не будет в любом случае из-за больших погрешностей рядом со стенами зданий.

Иногда наши предшественники и не могли подогнать снимок под существующую геометрию здания, например, когда у контура здания неправильная длина. Для того, чтобы нас эта проблема не затронула, мы уже подвинули передние углы здания. Углы мы ранее могли сдвинуть также для того, чтобы они не мешали перемещать точки вдоль линии стены. Возможно, нам надо перетащить точку контура дальше текущего положения в данных переднего угла. Результат сдвига точки контура здания за его пределы мимо его угла нас вряд ли устроит. Чтобы перемещаемая точка осталась в пределах здания, нужно поменять сами пределы, что мы и могли проделать сдвигом углов.

С другой стороны, и при сдвиге передних углов может возникнуть необходимость переместить их дальше какой-либо точки на контуре здания. Понятно, что результат сдвига лишь угла будет точно так же неудовлетворителен, как и только что упомянутый результат сдвига точки мимо угла. Допустим, что и слева, и справа от переднего угла стоят точки. Про левую точку мы выясняем, что её надо подвинуть направо, дальше текущего положения угла. Тогда, поскольку перед этим надо подвинуть угол, мы выясняем и правильное положение угла, а оно оказывается правее правой точки. Значит, нам придётся выяснять положение и этой точки, и двигать сначала её, потом угол, потом левую.

Давая выше номера разновидностям точек, мы хотели показать, в какой *последовательности* их имеет смысл двигать. Так, в нашем примере мы бы подвинули сначала угол как точку *первой* разновидности, а затем обе точки по его сторонам как *третьей*. Выясняется, что иногда от этой последовательности мы бываем вынуждены отойти, и в нашем примере мы двигаем точку *третьей* разновидности перед тем, как двигать точку *первой*. Впрочем, такая ситуация возникнет только при достаточно высокой плотности точек на стенах зданий или очень больших неточностях в данных.

Будем ли мы действовать по этой последовательности, если нас ничто не будет вынуждать действовать иначе? Как такие действия будут выглядеть? Пройдёмся ли мы по всей стороне, двигая только точки первой разновидности, затем пройдёмся ещё и ещё раз для второй и третьей, затем ещё раз для поправок проездов и прочего, к чему мы перейдём в следующих разделах? Скорее всего, нет, мы постараемся сделать все поправки после выравнивания стороны квартала за один проход вдоль этой стороны. Последовательность для разновидностей точек сохранится, видимо, в пределах зданий. Нам по прежнему будет легче скорректировать форму здания, подвинув его углы, прежде чем двигать прочие точки его контура. Точки второй разновидности важнее подвинуть прежде точек третьей лишь в той степени, в какой они затрагивают прочие линии. Так что лучше бы было говорить не о *последовательности* точек, из-за чего может сложиться впечатление о строгости следования действий, а об их *приоритете*, который мы можем поменять. Для каждой отдельной точки мы также можем решить, что она нам не важна, что понизит её приоритет. Повысить же его может, например, относительное расположение на простой пропорции, благодаря которому точка может выступить удобным ориентиром для положения других точек.

Наиболее вероятный вид процесса поправок точек их перемещениями вдоль границы квартала, когда такие перемещения не мешают друг другу, получается следующим:
- смотрим на первое здание вдоль улицы;
- решаем, устраивает ли нас его расположение и протяжённость вдоль улицы;
- если нет, передвигаем его углы;
- смотрим, надо ли поправить точки на простых пропорциях;
- если да, перемещаем их с помощью Shift+B;
- двигаем прочие точки, какие посчитаем нужным;
- сразу после рассмотрения и возможного сдвига точки, входящей в проезд, корректируем и сам проезд способом, описанным далее;
- переходим к следующему зданию;
- если оно стоит вплотную а предыдущему, мы могли уже начать корректировать его форму вместе с формой предыдущего;
- проделываем перечисленные действия для текущего здания и так далее.

Ясно, что всегда точно следовать такому плану не удастся, в частности при ситуациях, подобных рассмотренному ранее примеру с двумя точками рядом с углом. Тогда придётся забегать вперёд, двигая точки следующего здания, и возвращаться назад. Если нам удастся следовать плану хотя бы примерно, то после непосредственного сдвига квартала понадобится всего два прохода вдоль его сторон: первый для выравнивания зданий по прямой и второй для рассматриваемых в этом и следующем разделе поправок, заключающихся преимущественно в перемещении точек вдоль этой прямой и направлении линий перпендикулярно ей.

Напоследок заметим, что иногда поправки и точек третьей разновидности могут не ограничиваться перемещением только самой точки или вообще не являться перемещением точки. Самый простой вариант - это когда точку можно просто удалить, что можно сделать, если она больше не соответствует реальному объекту на своём месте. Например, точка на контуре здания может обозначать не особо теперь нужный и, соответственно, уже демонтированный телефон-автомат. Также стабильностью расположения не отличаются и велопарковки у стен, которые могут быть как перемещены, так и убраны. В общем, если мы делаем сдвиг квартала ради того, чтобы что-то к нему пририсовать, мы проверяли, что именно рядом с ним *есть*. Нам, конечно, стоило проверить, и чего уже *нет*, чтобы не заниматься перемещением этого.

Ещё перемещаемой точкой может быть вход в здание, за которым отмечена точка POI, но соединяющий их проход не нарисован. Тогда лучше POI подвинуть вместе со входом, но способ с Ctrl-сбрасыванием нам недоступен из-за отсутствия соединяющей линии. Зато поскольку линии нет, то, скорее, нет и особой точности в относительном расположении входа и POI. Это даёт возможность и нам особо не соблюдать точность при перемещении POI. Всё это должно как-то сочетаться с установкой точек POI на определённое расстояние от края здания, если мы решили заниматься и им.

В целом, поскольку большинство сдвигов точек вдоль края квартала являются для нас необязательными, берясь за них мы ищем баланс между *быстрее исправить сразу* и *лучше оставить на потом*. Мы не хотим оставлять на потом много мелких деталей, чтобы потом не надо было о них вспоминать и делать много мелких правок. Но также мы и не хотим, чтобы всё действие сдвига квартала стало слишком громоздким и растянулось надолго. Сколько поправок мы в итоге захотим сделать зависит от того, насколько мы торопимся и сколько вещей мы собираемся держать в голове до выгрузки результатов сдвига и до последующих правок. Но, как мы знаем, некоторых поправок нам не избежать.

## Проезды и их поправка внутри квартала

Вот мы и добрались до практически неизбежной разновидности поправок - поправок проездов. Это, как мы сказали раньше, внешние поправки, необходимость которых вызвана соединением линиями перемещённых элементов внутри квартала и статичных элементов снаружи. Заодно вместе с внешними мы выполним и внутренние поправки  частей проездов внутри квартала, если будут необходимы их дополнительные сдвиги. Хотя здесь мы будем рассматривать в основном проезды, то есть линии {% tag "highway=service" %}, аналогичные рассуждения применимы и к похожим на них проходам {% tag "highway=footway" %}. Последние обычно менее распространены в данных, так как проезд одновременно выполняет и роль прохода.

### Представление проездов

Проезды, соединяющие улицу и квартал, можно разделить на две разновидности: проходящие сквозь здания и проходящие между зданиями. Какие чаще будут нам попадаться, зависит от типа застройки. При плотной исторической застройке промежутков между зданиями очень мало и, значит, проходящих от улицы между зданиями проездов практически не будет. Для советской застройки второй половины двадцатого века наоборот проезды между зданиями будут более типичны. При современных тенденциях строить здания в виде периметра закрытого внутреннего двора проезды сквозь здания снова выходят на первый план. Возможны проезды, которые не удастся отнести ни к той, ни к другой разновидности. Например, при поселковой застройке, когда здания находятся на значительном расстоянии друг от друга, мы не станем говорить, что проезд на чей-то участок расположен *между* зданиями. С такими проездами нам, скорее всего, иметь дела не придётся, потому что они с большей вероятностью не отмаплены, да и наш метод сдвига квартала может для таких мест не подходить.

Рассмотрим сначала проезды сквозь здания. Разберёмся, из чего может состоять такой проезд как реальный объект. Мы, смотря с улицы, обычно можем обнаружить его в виде арки, идущей сквозь здание. По осмовской терминологии такой проезд находится в *тоннеле*, а аркой мы как и раньше будем называть место входа/въезда в тоннель, то есть его пересечение с контуром здания. Тоннель обычно прямой, но не обязательно. Он может быть и в форме буквы Г или изогнут на меньший угол, и более длинная часть буквы обычно примыкает к улице. Весь тоннель, если он прямой, или его длинная часть у улицы обычно перпендикулярна улице и стене здания, чем мы воспользуемся.

{% TODO %}фотка г-тоннеля{% endTODO %}

Внутри тоннеля или непосредственно рядом с ним может находиться какое-либо препятствие для проезда, прохода или того и другого, обозначающее, кто во дворе хозяин. Препятствием обычно являются ворота, чаще всего расположенные очень близко к передней стене здания. Поскольку нас интересует форма тоннеля, такие ворота могут помешать нам её рассмотреть. К счастью, большинство ворот решётчатые, так что через них можно заглянуть и увидеть, прямой ли тоннель или изогнутый. Другим видом препятствия может быть шлагбаум, обычно расположенный у задней стены.

{% TODO %}фотка ворот с Марата{% endTODO %}

С задней стороны здания проезд направляется вглубь квартала, возможно разветвляясь. Как именно он там идёт, нас интересует только до той степени, которая нам нужна для сдвига тоннеля, то есть почти совсем не интересует. Несколько более нас интересует проезд снаружи. Тут проезд по сравнению с тоннелем проявляется в гораздо меньшей степени, потому что у него может не быть чётких границ по бокам. Проезд снаружи является продолжением проезда через тоннель для соединения с улицей, и это продолжение проходит поперёк тротуара и части улицы. На самом тротуаре проезд выражается в отсутствии препятствий для себя. Например, если на тротуаре есть газон, то в месте проезда у газона должен быть промежуток. Нам придётся это учитывать, если мы хотим нарисовать или подвинуть проезд. Промежуток у газона может быть наиболее видимым проявлением проезда на спутниковых снимках, что нам пригодится. Точнее, нам это уже должно было пригодиться ранее, если мы двигали арку. На границе тротуара и проезжей части проезд проявляется в виде заниженного поребрика. На краю проезжей части проезд проявляется в отсутствии припаркованных автомобилей, что тоже хорошо видно на снимках. Посередине проезжей части он может присутствовать, а может и отсутствовать в виде изменений разметки, например как разрыв двойной сплошной.

{% TODO %}фотка разрыва двойной сплошной{% endTODO %}

Таким образом, проезд, если мы готовы рассматривать его как единый объект, состоит из разнородных частей. Чтобы их правильно отметить, нужны различные наборы тегов. Чтобы поставить различные наборы тегов, нужны отдельные элементы-линии для каждого набора. В результате проезд разделяет судьбу прочих {% tag "highway" %}, для которых бесполезно говорить о принципе [*один объект - один элемент*](https://wiki.openstreetmap.org/wiki/RU:Один_объект_—_один_элемент_OSM). Для нас некоторые из разделений проезда на части окажутся даже удобными, так как мы сможем использовать команды, работающие с линиями целиком для отдельных частей проезда, не затрагивая другие части.

Какие линии используются для обозначения проезда, где они делятся и какие на них теги? Для нас главное, что это линии с тегами {% tag "highway" %}, обычно {% tag "highway=service" %}, которые делятся в точках пересечения с контуром здания. Ещё для нас существенно то, что внешний участок проезда, проходящий по улице, тоже может быть разделен на части по различным причинам, а может и не быть. Мы с этим участком будем работать, как правило, целиком, так что нам надо не забывать применять команды ко всем его частям.

Основная наша задача - устранить внесённые нами же искажения в форму обозначенного до нас проезда. Во первых, они образовались из-за того, что мы не целиком сдвинули внешнюю часть проезда, когда двигали весь квартал. Мы точно сдвинули точку арки, возможно сдвинули точку пересечения с тротуаром и, скорее всего, не двигали точки пересечения с проезжими частями. Если мы таки сдвинули их все, то вместо выпрямления проезда нам надо делать выпрямление улицы, что мы рассмотрим позже. Во-вторых, мы могли заодно подвинуть арку и после сдвига квартала, в результате чего мы погнули проезд внутри площади здания.

Вот две части проезда, с которыми мы хотим работать: тоннель в площади здания и продолжение до линии улицы снаружи квартала. Есть ещё одна часть, которую мы хотим трогать только по минимуму - проезд внутри двора, у которого может быть сложная форма. Первым делом нам надо убедиться, что одна представляющая проезд элемент-линия не проходит через несколько этих частей. То есть, нам нужны разрывы линии проезда в двух точках-арках, где он пересекает контур здания. Если наши предшественники мапили правильно и отметили отдельно тоннель как {% tag "tunnel=building_passage" %} или как {% tag "covered=yes" %}, то линии разрываются где надо. Но нашим предшественникам могло быть и лень делить линию, и весь проезд от улицы до внутренностей квартала они могли представить одной линией без разрывов. Тогда нам придётся сделать разрывы самим.

При разрезании линии проезда на части нам сначала нужны точки пересечения проезда с контуром здания. Наши предшественники могли их поставить, а могли и не поставить. Если они поставлены не были, то нам бы их следовало поставить ещё до сдвига квартала. Без этого мы при сдвиге погнули проезд между точкой на улице и точкой внутри квартала, что тоже поправимо, только действовать придётся немного иначе. Например, можно попытаться сразу перетащить точку пересечения с улицей или тротуаром так, чтобы она оказалась примерно напротив точки внутри двора, затем добавить точки пересечения с контуром здания, после чего действовать по обычному плану.

Обычный же план разрезания проезда такой: разрезать линию по точкам пересечения с контуром здания и поставить на часть внутри контура тег {% tag "tunnel=building_passage" %}. Вместо тега {% tag "tunnel=*" %} следует ставить тег {% tag "covered=*" %} в тех случаях, когда одна из сторон тоннеля является аркадой, колоннадой или ещё чем-то с видом на улицу. Одновременно оба эти тега ставить не нужно, и чаще всего лишним оказывается тег {% tag "covered=*" %}, хотя нередко он встречается в сочетании с {% tag "tunnel=*" %} в уже введённых данных с правильно распиленными проездами. Если мы такое сочетание обнаружим, можно заодно поправить данные, удалив лишний тег.

### Поправка проездов внутри квартала

Теперь проезд разрезан на необходимые части, и мы можем их отдельно исправлять. Если в результате наших предыдущих действий мы погнули тоннель внутри здания, первым делом стоит исправить его. Это очень просто сделать, если:
- тоннель должен стать прямым и перпендикулярным передней стене здания, чего можно достичь сдвигом задней арки так, чтобы она оказалась прямо напротив передней;
- задняя стена, то есть та, которая включает заднюю арку, прямая, параллельная передней стене и не имеет вставленных в себя точек на том участке, через который должна переместиться задняя арка.

В этом случае нам надо выделить линию тоннеля, точку передней арки и ещё любую точку на передней стене здания, затем использовать команду Q. Выделенные точки послужат указанием линии-перпендикуляра для тоннеля, следовательно, концы самого тоннеля сдвинутся так, что он станет перпендикулярен передней стене. Также выделенные точки, в частности точка передней арки, будут зафиксированы, так что если тоннель состоит из двух точек передней и задней арки, сдвинута из них будет только одна - точка задней арки, чего мы и хотели.

Теперь рассмотрим, что нам может помешать использовать команду Q. Самая простая из таких ситуаций - тоннель в реальности прямой, но не перпендикулярный передней стене. Удобнее всего, если при этом он параллелен какой-нибудь линии, например, боковой стене. Так бывает, когда тоннель проходит близко к этой стене. Тогда мы можем повернуть тоннель относительно арки параллельно нужной стене с помощью плагина AlignWays, а затем выпрямить затронутый участок задней стены. В общем же случае прямого, но неперпендикулярного тоннеля мы бы старались не задавать непосредственно его направление, а правильно ставить его концы, то есть арки. Отчасти мы делали это и для перпендикулярного тоннеля, поправляя вручную переднюю арку, а теперь бы нам следовало поправить таким же образом и заднюю.

Проблема при непосредственной установке задней арки обычно в том, что мы не знаем, куда конкретно её надо подвинуть. На доступных нам снимках задняя арка вряд ли видна, и вряд ли мы сходили посмотреть на здание сзади, чтобы увидеть её самостоятельно. В результате нам придётся, зная место передней арки, угадать положение противоположной арки тоннеля. Если задняя стена в тех местах, где мы перемещаем арку, прямая и на ней ничего не отмечено, то правильность положения не столь важна. В прочих случаях правильность уже гораздо важнее, так как мы хотим иметь эту правильность относительно геометрии стены и всего на стене отмеченного. И тогда у нас появляется ещё одна проблема.

Если в участок задней стены между исходной и целевой позицией задней арки вставлены точки, нам уже будет недостаточно просто нажать на Q. Перемещаемая нами точка арки сама не перепрыгнет через другие точки контура здания. Та же проблема будет и при перемещении точки вручную, как мы бы поступили в идеальных обстоятельствах с видимой задней аркой. Для передней арки эту проблему мы решили, выпрямив переднюю стену и двигая вдоль неё прочие точки, которые могли бы нам помешать. Заднюю стену мы выпрямлять не хотим, потому что она часто не прямая, и точки по ней мы тоже двигать не хотим, потому что мы не знаем, где они на самом деле находятся.

### Команда Alt+J

Чтобы передвинуть арку в условиях, когда этому мешают другие точки и изгибы стены, нам потребуется сначала разъединить линии проезда и контура здания. Для этого у нас есть два основных варианта: исключить точку арки из контура здания или исключить её из проезда. Первый вариант более простой, так как точка в нём убирается только из одной осмовской линии. Воспользоваться им можно, когда точка арки не задаёт существенной геометрии здания. То есть, точка арки должна быть примерно на одной прямой между своими соседними точками в контуре здания так, чтобы мы не посчитали её углом здания. Исключить точку из линии можно выделив точку и линию, затем использовав команду отсоединения точки от линии (Alt+J).

В первом варианте выделить понадобится точку арки и линию контура здания. На всякий случай обратим внимание на то, что линий контура как осмовских элементов у здания может быть несколько, и выделять надо только ту из них, в которую входит перемещаемая нами точка арки. После этого можно перетащить точку к нужному месту и вставить её там в контур здания командой N. Дальше, если тоннель перпендикулярен передней стене, и эту перпендикулярность хочется точно задать, можно использовать команду Q. После этого нам придётся подправить проезды внутри квартала, чтобы они соответствовали  новому положению арки. В общем, по сравнению с обычным ходом дел есть два отличия: необходимость извлечь и вставить точку в контур здания и необходимость подумать, в каком именно месте её вставлять.

Если до нас тоннель нарисовали ведущим в угол здания, а мы считаем, что на самом деле он туда не ведёт, убрать из контура точку арки, одновременно являющуюся и точкой угла, мы не можем, не испортив формы здания. Нам придётся воспользоваться вторым вариантом: исключить точку из проезда. Этот вариант сложнее, потому что проезд может состоять из нескольких линий. Он даже должен состоять из нескольких линий, и если это было не так, мы специально его разрезали. Сейчас нас интересуют две из этих линий: тоннель и продолжение проезда вглубь квартала, которые сходятся в точке арки-угла. Может быть так, что продолжение проезда не нарисовано, это облегчит нам задачу. Тоннель же, раз мы его исправляем, точно есть, так что займёмся сначала им.

Мы хотим исключить из тоннеля угол здания во дворе, что можно сделать точно так же командой Alt-J, только вместо линии контура здания надо выделить линию тоннеля. Тут нас может ждать следующее затруднение: тоннель часто представлен линией из двух осмовских точек, и если исключить одну из них, от линии ничего не останется. На самом деле, команда исключения точки просто откажется выполняться в подобной ситуации. Значит, перед исключением точки в тоннель надо добавить ещё одну точку, которая станет новой точкой арки, и которую мы будем перетаскивать на нужное место.

Если линия тоннеля проходит более чем через две точки, команда Alt+J на ней сработает, в результате чего исчезнет участок тоннеля между задней аркой и её соседней точкой в линии тоннеля. Перетаскивать эту соседнюю точку мы, скорее всего, не можем - если она есть, она, вероятно, значима. Этой точкой обычно является либо изгиб тоннеля, либо барьер типа ворот, отмеченный внутри, и тащить такие объекты к контуру здания нам не следует. Значит, нам вместо этого придётся продлевать линию тоннеля до нового места задней арки. Тут мы можем решить, что удобнее было бы всё-таки вставить в тоннель точку рядом со старым положением арки, и дальше тащить эту точку, как в ситуации с двухточечным тоннелем.

После перетаскивания и вставки новой точки тоннеля в новое место на контуре здания или продолжения до этого места сократившейся линии тоннеля нам надо туда же подвести и внутриквартальное продолжение проезда, если оно нарисовано. Тут нам тоже понадобится Alt-J и, может быть, вставка перед этим дополнительной точки, а после - объединение уже не входящей в контур здания точки проезда и точки конца тоннеля. Дальше надо проделать всё то, что мы бы сделали после вставки арки на новое место при более простом первом варианте: дополнительное выравнивание с помощью Q и т.п.

Глядя на описание этих двух манипуляций с тоннелем и с продолжением проезда во дворе, у нас может возникнуть мысль, как их оптимизировать. Если для исключения точки из *одной* линии мы перед применением Alt+J выделяли точку и *одну* линию, то, может быть, для исключения точки из *двух* линий лучше выделить точку и *две* линии? Нет, не лучше, и, по идее, команда сработать не должна, и JOSM должен сообщить, что точка используется несколькими линиями, а выбрать надо только одну. В реальности же команда может сработать, только даст она не тот результат, который можно было бы ожидать.

Мы только что узнали, что при применении команды к точке и одной линии команда отказывается выполняться, если в линии всего две точки. Так вот, на такие линии из двух точек команда Alt+J просто не обращает внимания, когда она применяется к нескольким линиям, среди которых есть и те, из которых точку исключить возможно. Для нас будет типична такая ситуация: тоннель из двух точек и проезд внутри двора более, чем из двух. Выделим заднюю арку, тоннель и проезд во дворе, применим Alt+J - и команда сработает, потому что тоннеля с её точки зрения как бы нет. Но, конечно же, из тоннеля при этом точка не исключится, а это не то, чего мы хотели. Короче, пытаться выделять несколько линий для команды Alt+J не следует.

### Команда G

Второй вариант применения Alt+J, когда точка задней арки задаёт геометрию здания, выглядит как-то коряво. Есть условия, при которых команда работает или не работает, может понадобиться или не понадобиться вставлять ещё одну точку в отсоединяемую линию. На самом деле, от создания новой точки нам в любом случае не уйти, так как нам нужна точка и на старом месте арки, и на новом, где её раньше не было. Если бы в JOSM была команда, сочетающая в себе исключение точки из линии и включение туда новой точки, было бы проще ей и воспользоваться. Такая команда, конечно, есть - это команда {% action "UnGlue" %}разъединения линий или "отклеивания"{% endaction %} (G). Она превращает одну точку, общую для нескольких линий, в несколько, так что у каждой линии будет своя точка.

У команды G есть изрядное количество способов применения, зависящих от выделенных элементов. В случае ошибки, когда команда оказывается неприменима к выделенному множеству, появится сообщение-подсказка, перечисляющая пять вариантов вызова команды. Список этот неполный, и мы бы могли его продолжить.[^11-variants] Простейшим из них является применение команды только к точке, входящей в несколько линий. В результате эта точка исключается из всех своих линий кроме одной, а лишившиеся точки линии получают взамен новые точки на месте исключённой. То есть, если применить G к точке, входящей в две линии, она превратится в две точки.

[^11-variants]: Например, в варианте вызова с несколькими выделенными точками не обязательно, чтобы все эти точки были общими для нескольких линий. Ещё команду можно использовать и на одной точке, входящей только в одну линию, но делающей это несколько раз. У любой замкнутой линии есть хотя бы одна такая точка.

Помимо соответствующего изменения осмовских данных, команда меняет множество выделенных элементов. После применения команды вместо того, что было выделено как её аргумент, в простейшем случае - вместо одной исходной точки, выделенной окажется одна из созданных точек. Поскольку мы выполняли разделение точки ради того, чтобы некоторые точки перетащить, нам было бы удобно, чтобы выделенной стала та точка, которую мы тащить и собираемся. Если выделенной могла бы оказаться точка, которую надо оставить на месте, нам пришлось бы выбирать нужную точку из нескольких, находящихся на одном месте, что не слишком удобно делать. Ещё нам бы хотелось, чтобы исходная точка со своей историей осталась в контуре здания. Она там была, скорее всего, до обозначения тоннеля, так что пусть будет и после его перемещения.

Хотя обозначенные выше подробности работы команды G не совсем документированы, эксперименты показывают, что при применении команды к одной точке угла-арки всё сложится желаемым для нас образом. *Во-первых*, история окажется сохранена на точке контура здания. Я пока не могу сказать, почему, но видимо для истории выбирается точка не на конце линии, а у линий проездов точка находится на конце.[^11-old] *Во-вторых*, выделенной окажется либо точка тоннеля, либо точка проезда во дворе, неизвестно, какая именно.[^11-unknown] Но нам и не важно, какая из них будет выделена, потому что нам их обе надо перетащить. Кстати, подсказка к команде утверждает, что выделятся "все" точки, но это не так: выделится, как мы сказали, лишь одна.[^11-select]

[^11-old]: Можно было бы предположить, что история сохраняется в точку более старой линии, но это не так, в чём можно убедиться, пририсовав новую линию к концу какой-нибудь существующей.

[^11-unknown]: Можете проверить это, применяя команду G, отменяя и снова применяя. Будет выделяться точка то одной линии, то другой.

[^11-select]: Подсказка говорит, что если выбрана линия, то она получит новые точки в местах отклеивания, и эти точки будут выделены, что верно. Дальше говорится, что "иначе", то есть когда линия не выбрана, все линии получат свою копию точки, и "все" точки будут выделены. "Все" какие точки? Старые? Нет. Новые? Не все новые. На самом деле команда выделяет по одной новой точке на месте каждой старой точки. Но не указав линию, команду можно использовать только на одной точке, значит том случае, который подсказка называет "иначе", будет выделена ровно одна новая точка.

Допустим, мы перетащили одну из точек проезда, но, скорее всего, на старом месте, там же где и точка контура, осталась ещё одна точка проезда. Нам ведь надо её тоже выделить, и теперь самостоятельно, ведь команда G нам в этом уже не поможет... Но на самом деле она нам поможет, потому что *в-третьих*, в интерфейсе редактора все новые, созданные командой точки окажутся *сверху*, а старая точка - точка контура здания - *снизу*. Означает это следующее: в результате применения команды в одной геометрической точке оказывается несколько точек-элементов; если мы по ним кликнем - выделится одна из новых; перетащим её и снова кликнем - снова выделится одна из новых и так далее, пока на этом месте не останется только старая точка. После нашего применения команды G на одном месте обычно оказываются три точки: старая точка контура и две новых точки проезда. Одна из точек проезда сразу будет выделена, так что мы её без проблем перетащим. Далее мы сможем просто кликнуть на место двух оставшихся точек, в результате чего выделится вторая точка проезда, после чего мы сможем перетащить и слить её с первой перемещённой точкой проезда. Так мы выполним перемещение задней арки.

Такое применение команды G выглядит простым и удобным, но напомним, что оно рассчитывает на недокументированные подробности работы команды. Что, если разработчики их поменяют? Что, если я эти особенности неправильно описал? Как мы помним, у команды G есть несколько вариантов вызова, в том числе более документированные и более предсказуемо работающие. Из них нам может пригодиться вариант с указанной линией. Если выделить точку вместе с одной из содержащих её линий и применить команду G, в указанной линии и *только в ней* точка будет заменена на вновь созданную. Также выделение заменится на эту новую точку, и её будет легко сразу перетащить.

Мы можем воспользоваться этим вариантом команды G, когда точка задней арки и угла здания входит в три линии: контура здания, тоннеля и внутриквартального проезда. Выделим точку арки и линию тоннеля, затем применим G. На месте соединения линий станет две точки, а не три, как при простейшем применении G. Ими будут старая точка, входящая в контур и проезд, и новая, входящая в тоннель, выделенная и готовая к перетаскиванию. Перетащим точку тоннеля в то место контура, где по нашему мнению должна находиться задняя арка, и вставим её туда, например, командой N. Теперь вернёмся к точке контура-проезда, выделим её и проезд, применим G. В результате там снова окажутся две точки, и точка проезда будет новой и выделенной. Перетащим и ее на новое место задней арки и объединим с поставленной там точкой, заканчивая перетаскивание с нажатым Ctrl.

Мы знаем, что завершение перетаскивания точки с нажатым Ctrl - это то же самое, что и вызов команды M. Значит, вместо перетаскивания второй точки можно выделить её, затем выделить точку на новом месте арки и выполнить команду M. При простейшем варианте использования G, создающем сразу три точки, это делать не совсем удобно, так как мы не совсем уверены, которая из точек выделена. Выполняя перетаскивание, мы можем увидеть ещё до его завершения, какая линия меняет форму и, соответственно, какая из точек выделилась и теперь перетаскивается. Это нам понадобится, если команда G сработает не так, как мы ожидаем. В варианте же вызова команды с указанием линии наши ожидания почти наверняка оправдаются.

Как и раньше с командой Alt+J, нам может прийти в голову идея отклеить точку сразу в две линии, то есть выделить точку и обе линии проезда, и вызвать команду G, надеясь, что она создаст одну новую точку на обе линии. Но как и раньше это не сработает, так как линию можно указать лишь одну. Конечно, вместо линий проезда мы можем указать линию контура здания и получить так две точки, одна из которых будет общей для двух частей проезда. Однако тогда в контуре здания окажется новая точка, и она же будет выделена и готова для перетаскивания, чего мы не хотим. Конечно, дальше можно выбрать точку проезда и перетащить её, но в итоге такой способ окажется не более простым и не более правильным.

### Итоги поправки тоннеля

Вернёмся к выбору нового места для задней арки. Куда именно вставлять точку арки нам придётся думать, так как перемещаем мы её между качественно различающимися местами. В ситуации, когда тоннель можно можно было исправить одним вызовом команды Q, задняя стена была прямая, и места так не различались. Нас сейчас в первую очередь интересует зависимость расположения задней арки от геометрии стены, а не от точек типа входов. Относительно последних мы расположение арки всё равно не сможем угадать. Правда, делать это будет, скорее всего, и не нужно, так как если кто все эти точки отметил, то арку он наверняка тоже поставил правильно, и мы бы двигать её не взялись. Относительно же геометрии, нетрудно догадаться что если у здания есть с точки зрения расстояния между передней и задней стеной более широкие места и более узкие, арка будет там, где более узко. Впрочем, часто осмеры до этого не догадываются и ведут тоннель куда попало, из-за чего нам и может понадобиться его поправлять.

Исключениями из описанного принципа, когда тоннель идёт через узкую часть здания, будут случаи с непрямыми тоннелями. Тогда тоннель начинается наоборот в широкой части здания, а затем заворачивает вбок. Например, если здание имеет П-образную форму, с "горизонтальной" линией буквы, идущей вдоль улицы, и двумя "вертикальными" линиями, уходящими вглубь квартала, тоннель может начинаться у вертикальной линии. Конечно, прямо через всю эту линию тоннель не идёт. Вместо этого он сворачивает при первой возможности, чтобы быстрее привести во двор.

Осмеры, не знающие настоящей формы тоннеля, попытаются нарисовать его прямым. Однако, они понимают, что через всю "вертикальную" линию буквы П тоннель не идёт, значит рисовать его они будут ближе к центру здания. Мы же в процессе наших исправлений точек на передней стене сдвинули переднюю арку куда надо, после чего линия тоннеля осталась прямой, но стала косо проходить через здание. Ясно, что только с помощью команды Q форму тоннеля исправить мы не сможем. Q для нас не совсем бесполезна, если тоннель сначала идёт перпендикулярно передней стене, а потом поворачивает на 90 градусов. Прежде, чем мы сможем воспользоваться этой командой, нам надо хотя бы примерно нарисовать изогнутый тоннель вместо прямого. Первым делом лучше переместить заднюю арку в нужную часть задней стены, предварительно отвязав её от ненужной, как было описано ранее. Далее можно добавить точку в линию тоннеля и перетащить эту точку на место его изгиба. Теперь можно применять Q или не применять, если угол тоннеля не прямой или вы считаете, что и так сойдёт.

Подытожим операции для поправки проезда перемещением задней арки для разных случаев:
1. Если *точка задней арки не задаёт геометрии здания и её не надо перемещать через другие точки контура здания*: переместить арку командой Q или плагином AlignWays с последующим выпрямлением задней стены или Ctrl-перетаскиванием в режиме X.
2. Если *точка задней арки по прежнему не задаёт геометрии здания, но её надо перемещать через другие точки контура*: перед перемещением арку исключить из контура командой Alt+J, дальше перетащить арку в примерно нужное место контура и включить её в него командой N, поправить конечное положение арки как в первом случае.
3. Если *точка арки задаёт геометрию здания*: выделить только точку задней арки, расклеить её командой G, переместить выделившуюся точку на новое место контура и вставить её туда командой N; кликнуть на старое место арки, чтобы выделить вторую точку проезда, перетащить её к только что вставленной на новое место точке, объединить с ней Ctrl-сбрасыванием; поправить конечное положение арки как в первом случае. При этом надо следить, чтобы перетаскиваемые точки входили именно в линии проезда, то есть видеть, что при перетаскивании меняется именно форма проезда, а не здания. Если это не так, то команда G работает иначе, чем мы ожидаем, и нам нужен следующий вариант действий.
4. Если *точка арки задаёт геометрию здания и мы хотим более контролируемый способ применения команды G*: командой G отклеить арку в составе линии тоннеля, переместить и включить полученную точку в примерно нужное место контура, командой G отклеить арку в составе линии внутриквартального проезда, объединить полученную точку с ранее вставленной в контур, поправить конечное положение арки как в первом случае.

К этому надо добавить поправку проезда сзади здания любым удобным нам способом, и с *внутренней* относительно квартала поправкой проезда мы покончили.

## Поправка проездов снаружи

Мы разбираемся с проездом от улицы вглубь квартала, который проходит сквозь здание. Непосредственно с той частью проезда, которая проходит сквозь здание, мы уже разобрались, но осталась та часть, которая находится снаружи и соединяется с линиями улицы. Направление линий проезда в этой части мы могли исказить сдвигом квартала. Но также нам известно, что в реальности эта часть проезда может не иметь чётких границ, что вносит неопределённость в представление проезда линиями. Однако вряд ли эта неопределённость является поводом оставить линии повёрнутыми как попало. Лучше рассматривать её как возможность или даже обязанность выбрать наиболее подходящее направление линий.

Есть два логичных выбора направления проезда снаружи: перпендикулярно улице или в направлении примыкающей к улице части тоннеля. В большинстве случаев это одно и то же, потому что часть тоннеля тоже перпендикулярна улице. Если разница между вариантами всё-таки есть, то чисто визуально лучше выглядит продолжение проезда в направлении тоннеля, потому что в точке передней арки у проезда не будет излома. Однако для достаточно широкой улицы такой вариант будет менее правильный, так как точка пересечения проезда и улицы будет смещена в сторону от арки. Особенно странно будет выглядеть косое относительно улицы продолжение проезда, соединяющее две линии проезжей части в случае двухвейки. Гораздо лучше будет выглядеть соединение, перпендикулярное к обеим линиям дороги. Кроме того, нам не нужно придумывать, где находится место этого соединения, так как разрыв двойной сплошной должен быть достаточно хорошо виден на доступных снимках.

Оба этих варианта мы можем реализовать как и раньше вызовом команды Q. Проблем с этим не будет, если:
1. текущий угол между желаемым направлением и направлением деформированного нами проезда на улице ближе к нулевому, чем к прямому;
2. проезд не соединяется с другим проездом с противоположной стороны улицы;
3. на линиях улицы нет точек, мимо которых должны будут переместиться точки соединения этих линий с проездом;
4. нет плотно прилегающих препятствий по бокам проезда, например, газонов.

Тогда нам достаточно будет применить команду Q, предварительно выделив цепочку линий проезда на улице, его переднюю арку и ещё одну точку. Этой точкой в варианте с перпендикуляром к стене будет как и раньше ещё одна точка на стене. В другом варианте с продолжением в направлении тоннеля этой точкой будет ещё одна точка тоннеля, лежащая на той прямой, по которой мы хотим выстроить все точки проезда. Если тоннель прямой, то этой точкой будет задняя арка, если тоннель Г-образный, то точка изгиба.

В отличие от рассмотренного ранее исправления тоннеля, команду Q нам может потребоваться применить сразу к нескольким линиям, образующим цепочку. Как мы заметили ранее, эти несколько линий могут существовать из-за необходимости поставить на них разные теги. Впрочем, очень часто это будет всего лишь одна линия с единственным тегом {% tag "highway=*" %}, которым нередко ограничиваются и для линий проездов внутри квартала. Иногда внутри квартала используют также тег {% tag "living_street" %}, которого снаружи точно не будет. Если проезд снаружи поделен на части, то точками, в которых выполнены деления, могут быть пересечения с линиями тротуара и проезжей части. Поскольку нам придётся иметь дело с этими линиями, посмотрим, зачем они нужны.

### Перемычки и повороты

Сначала обратим внимание на возможное деление внешней части проезда в точке пересечения с линией проезжей части. Раз проезд в этой точке делится, значит он на ней не заканчивается и идёт дальше. Дальше он может идти либо на противоположную сторону улицы, соединяясь в этой точке с проездом напротив, либо к ещё одной линии проезжей части. В последнем случае ясно, что вдоль улицы проведено несколько линий проезжих частей, как минимум, две. Эти деления и продолжения скорее всего связаны с тем, на какую сторону улицы можно выезжать из проезда, то есть можно ли из него повернуть налево.

Допустим, что улица нарисована двухвейкой. Если при выезде из тоннеля повернуть налево нельзя, проезд будет соединён только с ближайшей линией проезжей части. Если повернуть налево можно, то проезд будет продолжаться и до следующей линии. Это довольно очевидно, но непонятно только, зачем при пересечении с первой линией проезд делить. Действительно, можно и не делить, и сама по себе связность от этого не пострадает. Однако мы можем обнаружить, что иногда проезд там делят. Делают это для того, чтобы получить отдельную линию, соединяющую две линии проезжих частей, и поставить на неё тег [`highway=*_link`](https://wiki.openstreetmap.org/wiki/Key:highway#Link_roads). Насчёт того, стоит ли это делать, существуют [разные мнения](https://community.openstreetmap.org/t/part-1/42495/1639), зависящие от того, как рассматривается данное место проезжей части. Если смотреть на него как это делаем мы, то есть как на продолжение внутриквартального проезда, ставить _link вместо service вроде бы не нужно. Но можно смотреть на него как на самостоятельно существующее место для разворота посередине улицы, сбоку от которого оказался проезд. Тогда там сначала бы нарисовали перемычку с тегом _link, а потом пририсовали бы проезд.

Выбирать между этими вариантами - не наша текущая задача. Мы собирались лишь подвинуть это соединение, как бы оно ни было обозначено, так, чтобы оно оказалось напротив тоннеля. Однако, в случае, если мы увидим _link, у нас могут появиться сомнения, надо ли его трогать. Согласно тому, как мы выше описали развитие событий, это независимый объект, нарисованный отдельно от нашего проезда, и, значит, его положение никак не касается положения квартала. Тогда зачем мы будем его двигать? Действительно, если перемычка нарисована в правильном месте, и мы можем в этом убедиться, трогать её мы не станем. Но бывает, что события шли по-другому, и, несмотря на обозначение _link, сначала рисовался проезд.

Проезд мог быть нарисован раньше перемычки, например, потому что он был нарисован и раньше двухвейки, то есть тогда, когда улица была представлена одной линией. При одновейке перемычку просто негде рисовать, что является одним из недостатков одновейки, и наличие места для разворота можно угадать только из соединения с проездом. Если при выезде из тоннеля не запрещён левый поворот, что реализуется [соответствующим отношением](https://wiki.openstreetmap.org/wiki/Relation:restriction), значит и место для разворота есть. Когда наступит время перерисовать улицу в двухвейку, рисующий её участник может расставить перемычки не на основании отдельного и независимого от уже введённых данных поиска мест для разворота, а просто заключив о наличии таких мест из соединений прежней линии улицы с проездами. Тогда, если проезд был смещён вместе со всем кварталом, смещена будет и перемычка, даже если на ней стоит _link. Такую перемычку нам есть смысл подвинуть.

Чтобы убедиться, стоит ли двигать перемычку, мы можем поискать место для разворота самостоятельно. Возможно, мы его не найдём, потому что его на самом деле нет и никогда не было. Нарисована же перемычка была лишь потому, что участнику, рисующему двухвейку, было лень самостоятельно проверять необходимость её присутствия, и он положился на рисовавшего проезд, как было сказано выше. Рисовавшему же проезд участнику было лень проверять ограничение поворота или лень его обозначать, ведь для этого нужно возиться с отношениями. В роли последнего участника был и я сам, и я могу сказать, что пока лазаешь по внутренностям квартала, рисуя там проезды и всё прочее, часто не думаешь о том, как соединить это с улицей.

В итоге теперь, делая исправления после сдвига квартала, мы можем пытаться "правильно" расположить линии, которых в реальности не существует. Смысла в этом никакого нет, и лучше было бы лишние перемычки удалить. С другой стороны, не мы эти ошибочные перемычки внесли, а значит, удалять их мы не обязаны. Прежде чем их удалять, нам нужно убедиться, что их нет в реальности, а это дополнительная работа, которую лучше делать отдельно от сдвига квартала. Если мы ошибёмся с решением об отсутствии места для разворота, то и отменить эти правки будет легче, если они записаны отдельным пакетом.

Ещё такие правки логично делать отдельно из-за *другого их характера*. Нашей основной целью является поправка *геометрии*, а удаление перемычек будет уже изменением *топологии*. Из этого следует, что если мы сразу не уверены в том, что перемычки не должно быть, легче её оставить и относиться к ней как к продолжению проезда, то есть двигать вместе с подходящей к ней линией {% tag "highway=service" %}. Исключениями, при которых нам захочется разделаться с лишними перемычками сразу, могут быть случаи, когда перемычки мешают двигать остальные линии проездов. Так будет при несоблюдении второго и третьего условий из приведённого выше списка. Несоблюдение этих условий, особенно третьего, может превратить и сдвиг перемычки в топологическую правку.

Ещё одной причиной не слишком торопиться удалять перемычки является то, что их иногда намеренно ставят там, где развернуться нельзя. Под "нельзя" подразумевается нельзя  *юридически*, а не *физически*. Физически проехать и развернуться можно, и именно эту возможность для тех, кого юридические ограничения не касаются, мог хотеть [передать рисовавший](https://community.openstreetmap.org/t/divided-divided/49856/260). Передаваться эта возможность должна линией {% tag "highway" %} с соответствующими тегами доступа, разрешающими только спецтранспорт или что-либо подобное. Следовательно, прежде чем удалять перемычку, нужно обратить внимание на теги из семейства access.

Вернёмся к тому, что мы выясняем причины деления внешней части проезда на отдельные линии. Мы обнаружили одну из причин разрезать его в точке пересечения с линией проезжей части. Этой причиной является необходимость дать отдельные теги соединению двух линий дороги, и этими тегами могут быть [`highway=*_link`](https://wiki.openstreetmap.org/wiki/Key:highway#Link_roads) или ограничение доступа. Остаётся ещё один вариант распиливания проезда, когда его продолжение пересекает всю улицу и является также продолжением проезда с противоположной её стороны. Такое продолжение можно было бы нарисовать и одной линией, если только не окажется нужным задать ограничения поворотов.

Вариант распиливания проезда ради ограничения поворота уже актуален для одновейки, при которой перемычку между двумя веями нарисовать нельзя. Точнее, нельзя обозначить разницу между её присутствием и отсутствием в реальности, не прибегая к отношениям в данных. Для создания же отношения ограничения поворота нужны линии, заканчивающиеся и начинающиеся в месте запрещённого поворота. В нашем случае местом поворота будет точка пересечения проезда и улицы, значит, одна из линий проезда должна в этой точке заканчиваться. Ограничение через точку посередине линии задать нельзя, потому что будет непонятно, с какой стороны к этой точке нельзя подъезжать для выполнения запрещённого поворота.

### Проезды напротив и псевдопереходы

Ещё продолжение проезда на улице может быть разрезано в точке пересечения с тротуаром. Ясно, что для этого тротуар должен быть нарисован, и именно с этим связаны различия в тегах, которые мы хотим поставить на части продолжения проезда. Если рисование или нерисование перемычки у двухвейки и установка на неё тегов доступа были связана с *автомобильным* графом маршрутизации, то разрез и теги, рассматриваемые сейчас, связаны с *пешеходным* графом. На тех линиях с тегами {% tag "highway" %}, которые используются для обозначения улиц и проездов, проход пешеходов по умолчанию разрешён. После рисования тротуаров вдоль улицы её ранее существовавшие линии начинают обозначать только проезжую часть, проход по которой надо запретить. Этот запрет реализуется добавлением тега {% tag "foot=no" %}. На линии проездов такой же запрет попадает редко, и даже наоборот, на них чаще вводят дополнительные ограничения для автомобилей с помощью тега {% tag "living_street" %}. По тротуару же проход, очевидно, остаётся разрешён.

Теперь посмотрим на небольшой участок, состоящий из линии проезжей части с запретом хождения, параллельной ей линии тротуара и линии проезда, начинающейся в глубине квартала, пересекающей линию тротуара и заканчивающейся на линии проезжей части. Какой пешеходный граф они образуют? Пешеходный граф будет состоять из двух линий: проезда и тротуара. По линии тротуара можно идти вдоль улицы. Ещё с нее можно свернуть на линию проезда и пройти вглубь квартала, но не только. Можно свернуть и в противоположную сторону и выйти на середину улицы. Высовывающийся за пределы тротуара кусок линии проезда образует там тупик пешеходного графа. Зачем нужен этот тупик и возможность гулять поперёк улицы? Они, конечно же, не нужны, просто их не убрали и не запретили.

Такой торчащий пешеходный тупик представляет из себя обычную картину. Как правило, устранять его не пытаются, потому что граф он портит не сильно, и неправильные маршруты из-за него не возникнут. Если же кто-нибудь захочет проявить педантизм и устранить тупик, для этого потребуется запретить ходить по части продолжения проезда, соединяющей тротуар и проезжую часть. Тогда линию проезда придётся разрезать в точке пересечения с тротуаром и поставить на её часть тег {% tag "foot=no" %}, после чего с прогулками до середины улицы будет покончено.

Пока что непонятно, как отсутствие или присутствие этого разреза касается нас. Мы резать или склеивать линию проезда не собираемся, потому что топология нас сейчас не касается. Мы готовы поправить как одну неразрезанную линию, так и две, а то и три, если есть также перемычка между двухвейкой. Однако чуть-чуть на топологию мы при этом можем повлиять в случае невыполнения тех же условий 2 и 3. Этого чуть-чуть может оказаться достаточно, чтобы испортить пешеходный граф. Чаще всего, тем образом, о котором пойдёт речь, граф был испорчен уже до нас, но и мы можем его аналогично испортить в процессе внесения наших поправок.

Выше мы говорили про тупик в пешеходном графе, который образуется из-за того, что участникам лень резать линию продолжения проезда, чтобы запретить ходить по её части. Тупик будет, если линия продолжения проезда, по которой разрешено ходить, заканчивается на дороге. Если же линия пересекает всю улицу и продолжает проезд вглубь противоположного квартала, в графе в этом месте будет задан переход через улицу, которого почти наверняка в реальности не существует. Ошибкой это становится либо в момент рисования такого проезда, либо в момент запрета хождения по проезжей части, в зависимости от того, что происходит позже. Без запрета хождения граф и так не соответствует действительности с тем уровнем детализации, на котором возможна рассматриваемая ошибка. Без нарисованной линии поперёк дороги ошибки не будет по очевидным причинам.

Как мы можем внести эту ошибку в процессе наших исправлений? Теги линий проезжих частей мы трогать не собираемся, значит остаётся только вариант с рисованием линии поперёк дороги. Новых линий продолжения проездов мы не рисуем, но мы можем пересоединить неудачным образом уже имеющиеся. Допустим, что в имеющихся осмовских данных с проезжей частью соединяются два продолжения проездов с разных сторон. Точки их соединений разные, но находятся недалеко друг от друга. Вместе с кварталом мы двигаем один из проездов. После этого мы обнаруживаем, что точки соединения примерно совпадают. Мы решаем, что оба проезда действительно находятся друг напротив друга. Ещё мы решаем, что лишние точки нам не нужны, и что соединить проезды с дорогой можно и в одной точке. Мы объединим обе точки, чем и создадим, не заметив того, ошибочный переход через улицу. К объединённой точке с двух сторон подходят линии, по которым можно ходить, а значит, можно перейти с одной линии на другую. Дальше мы можем решить, что и две линии можно объединить в одну, но даже если мы этого не сделаем, ошибка останется. Если бы у продолжения проезда была отделена часть, на которой стоял бы тег {% tag "foot=no" %}, такая ошибка не возникла бы. Значит, отделение такой части - не обязательно лишь педантизм.

Таковы основные причины, по которым продолжение проезда на улице могло быть разрезано на части в точках пересечения с другими линиями. Конечно, с точки зрения того, что в данный момент делаем мы, нам было бы легче, чтобы делений не было. Каждое деление - необходимость добавить к выбранным элементам ещё одну линию перед использованием Q, что придётся делать неоднократно, если наши предшественники постарались отрисовать все возможные проезды. Помочь деление нам может лишь в описанном выше случае создания ошибочного перехода, но при нём нам и так придётся дополнительно возиться.

### Трамвайные пути

Ещё легче нам было бы, если бы продолжение проезда не имело общих точек-элементов с теми линиями, которые оно пересекает. Тогда нам не пришлось бы задумываться, как операции выравнивания проездов влияют на эти линии, потому что эти операции никак бы эти линии не затрагивали. При пересечениях с рассмотренными линиями улицы и тротуара отсутствие общих точек возможно, только если наши предшественники допустили ошибку. Эта ошибка подобна отсутствию точек пересечения с контуром здания при обозначении тоннеля. Ошибку с тоннелем мы сразу исправляли, добавив точки для арок, и так же мы можем сразу исправить отсутствие точки пересечения, например, с тротуаром. Но помимо линий {% tag "highway=*" %} продолжение проезда может пересекать и другие линии. Точки-элементы в местах этих пересечений могут как стоять, так и не стоять.

Похожей на линию обычной дороги будет линия дороги железной. Поскольку мы рассматриваем обычные улицы вокруг квартала, в роли железной дороги выступают трамвайные пути. Аналог двухвейки для них делают практически всегда, то есть если трамваи ходят по улице как в одну сторону, так и в другую, линий для путей будет две. Если пути совмещены с автомобильной дорогой, между ними будет находиться линия проезжей части. Продолжение проезда обычно идёт до этой линии посередине, а значит оно пересекает одну из линий путей. Надо ли ставить точку на месте такого пересечения? На этот вопрос участники могут отвечать по-разному.

Если смотреть на графы маршрутизации отдельно для различных видов транспорта, точка на пересечении трамвайных и автомобильных путей не нужна. Трамвай свернуть со своих путей не может, значит ему не нужна связь, выражаемая с помощью общей точки. Автомобиль в случае совмещённых с проезжей частью путей свернуть на них может, но эта возможность уже отражена общей точкой с линией {% tag "highway" %} между путями. Однако возможность перейти с одного пути на другой - не единственная причина задать для них общую точку. Например, точки пешеходных переходов ставятся не для того, чтобы пешеход мог свернуть с перехода и идти посередине улицы. Нужны они для того, чтобы предупредить пешехода о пересечении с дорогой, и наоборот, предупредить автомобилиста о пересечении с переходом. На саму точку для этого ставятся соответствующие теги, указывающие свойства этого пересечения, в частности, как оно регулируется.

Аналогично, кто-то мог не просто поставить точку на пересечение трамвайных путей и проезда или любого другого highway, но и отметить её как [переезд](https://wiki.openstreetmap.org/wiki/Tag:railway%3Dtram_level_crossing). Это уже серьёзная заявка на то, что точка была поставлена осознанно. Не будь на ней тегов, нам было бы легче объявить её лишней и удалить. Но, может быть, и отмеченная как переезд точка является лишней? Для чего она нужна - предупредить водителя трамвая, что в этом месте автомобилисты имеют обыкновение ездить поперёк путей? Если отмечать как переезды пересечения путей с проездами, то из-за количества последних предупреждения могут быть через каждые пару десятков метров. При этом ничто не мешает проехать поперёк путей и между помеченными местами. С другой стороны, из проездов выезжают не так часто, и пересекают пути при этом далеко не всегда. Значит, смысла от отмеченных "переездов" на совмещённых путях с целью предупреждения водителя трамвая обнаруживается не так много.

Может быть, этого смысла больше с целью предупредить автомобилистов? Получается, что обозначенный переезд в рассматриваемом нами случае линии проезжей части между двумя линиями трамвайных путей предупреждает о пересечении с путями при любом выезде из квартала. Даже при повороте направо в автомобильном графе надо пройти через переезд, хотя в реальности пересекать пути при этом не надо. Точнее, пути не надо пересекать, если они идут по середине улицы, если же они расположены по краям, то ситуация будет другой. Отсюда следует, что логичнее было бы вместо обозначения точек переезда обозначить совмещение трамвайных путей с улицей прямо на линии улицы, то есть поставить на неё теги, указывающие наличие и расположение путей.

Не будет ли обозначение путей на линии улицы шагом назад, ведь ранее участники убирали теги путей с этой *общей* автомобильно-трамвайной линии, создавая для трамваев *отдельные* линии? Не будет, так как убирать сами отдельные линии путей мы не предлагаем. Мы предлагаем не изменять обозначение конкретного места прохождения путей, а *дополнительно к уже обозначенным путям указать для проезжей части, как именно она с путями совмещается*. В вики можно обнаружить подходящий для этого тег [`embedded_rails:lanes`](https://wiki.openstreetmap.org/wiki/Key:embedded_rails#Lanes). Аналогично можно было бы и на линии путей добавить теги о том, как они совмещаются с проезжей частью, но это, похоже, распространённым подходом не является.

Конечно, прямо сейчас мы никаких обозначений совмещений добавлять не хотим, это были лишь теоретические рассуждения о том, что в принципе можно сделать. Прямо сейчас мы заняты поправками после сдвига квартала, и из приведённых рассуждений следует, что точки пересечений проездов с путями не столь важны. Если эти точки будут нам мешать, мы можем их удалить. Впрочем, будут ли они сильно мешать? Если пути прямые и параллельны улице, мешать они будут не больше и не меньше, чем пересечения с другими линиями, параллельными улице. Если мы боимся, что то перемещение точек путей, которое выполняет команда Q, может погнуть трамвайные пути, то нам надо опасаться того же и по отношению к проезжей части и тротуарам. Оправданы ли эти опасения, мы увидим позже.

### Площади и их границы

Пока рассмотрим пересечение проездов с ещё одной разновидностью линий - границами тротуаров и проезжих частей. Линии на этих границах могут обозначать либо сами площадные объекты {% tag "area:highway" %}, либо препятствия-барьеры между ними. Продолжение проезда может пересекаться далеко не с любым барьером. Например, сквозь заборчик проезд идти не может, и вместо их пересечения мы должны увидеть разрыв барьера. Если разрыва нет, возможно, стоит его добавить, если и не прямо сейчас, то сразу после того, как мы разберёмся со сдвигом квартала и сделаем исправления внесённых нами ошибок. Если же разрыв уже нарисован, то он может перестать соответствовать проезду после сдвига последнего. Это будет невыполнением условия 4, обещающим нам дополнительную возню после исправления проезда. В случае если обозначенным барьером является всего лишь поребрик, особых проблем возникнуть не должно.

Точно так же мы не ждём и проблем от пересечений с границами площадных хайвеев, но как и раньше, мы бы предпочли, чтобы там не стояла общая точка. Поскольку эти границы тоже должны быть параллельны улице, о том, сколько неприятностей доставит нам перемещение входящих в них точек, можно сказать примерно то же, что и о линиях трамвайных путей. Для общих точек проездов с путями мы также решили, что они не особо нужны. Нужны ли тогда общие точки с границами площадных хайвеев?

У линии улицы, имеющей также и площадное обозначение, точки пересечения линии и площади могут быть нужны, чтобы сопоставить эти различные элементы. Такое сопоставление может быть нужно, например, для того, чтобы пользователь мог ткнуть в приложении на площадной хайвей вместо линейного, формально не имеющего площади, или чтобы распространить свойства с линейного элемента на площадной или обратно. Мы же сейчас рассматриваем не линию улицы, а линию проезда, и точка пересечения этой линии с площадью для только что рассмотренных целей не нужна. Это должно быть очевидно, потому что само продолжение проезда не обозначено как площадь, и линию проезда не с чем сопоставлять. Как мы знаем, никакую определённую площадь оно не занимает, и его линия проходит в площадях тротуара и проезжей части, пересечение с которыми мы и рассматриваем.

Даже если бы рассмотренное выше отношение линейного и площадного хайвеев показать было необходимо, об обязательности для этого общей точки можно было бы всё равно поспорить. Речь сейчас идёт о неявном отношении, которое не задаётся осмовским элементом-отношением, а выводится либо из *геометрии*, либо из *топологии*. Собственно наличие общей точки было бы *топологическим* способом задания отношения. Задавать топологически отношения для хайвеев выглядит логичным, так как самое известное из них - граф маршрутизации - именно этим способом и задаётся. В рассматриваемом сейчас случае мы могли бы сказать, что если у линии {% tag "highway" %} и контура {% tag "area:highway" %} есть общие точки, значит они как-то связаны. Связь, которую мы бы хотели задать в первую очередь, должна была бы выражать то, что линейный и площадной элементы соответствуют одному и тому же физическому объекту.

Тут мы можем догадаться, что желаемую связь общие точки линии и контура площади не выражают. Линия хайвея проходит не только по *своей* площади, но и по площадям тех хайвеев, с которыми она соединяется. Значит, у линии есть общие точки и с этими *чужими* площадями. Правильная общая точка, входящая в линию хайвея и контур его площади, скорее всего, входит и в контур примыкающей к данному месту *чужой* площади. Исключать точки линий из чужих контуров, и при этом оставлять в своих в принципе можно, но вряд ли кто-то будет этим заниматься. Если добавить к этому, что для нашего проезда *своя* площадь, скорее всего, не обозначена и даже не определена, станет понятно, что связи, выражающей обозначение одного и того же физического объекта для проезда у нас не будет.

Пока что мы повторили свои уже высказанные ранее сомнения насчёт необходимости ставить точки для проездов и обобщили их для других линий. Одной лишь общей точки для задания соответствия линии и площади недостаточно. Но, может быть, общая точка выражает какую-нибудь другую связь? Сложно будет придумать что-либо кроме того, что данный линейный хайвей проходит по или касается данной площади. Однако это утверждение является уже чисто *геометрическим*, и смысла показывать его топологически не слишком много. Значит, от точки на пересечении {% tag "area:highway" %} и проезда мало толку, если она сама не обозначает какой-то объект. Объектом может быть, например, препятствие для проезда типа столбика, или средство преодоления препятствия типа заниженного поребрика. В таких случаях на точке будут стоять соответствующие теги. Если тегов нет, а обычно их нет, и точка нам мешает, мы её можем удалить.

### Изгибы линий пересечения

Мы рассмотрели, из каких линий и точек может состоять исправляемая нами часть проезда, выходящая на улицу. До этого мы рассмотрели условия, при которых для исправления хватает выделения нескольких элементов и вызова команды Q. Позже мы рассмотрим, что делать при невыполнении этих условий, но пока нам может быть ещё неясно, почему их достаточно для применения команды Q. Задуматься на эту тему мы могли и раньше, когда исправляли проезд через здание, но тогда мы выполняли внутреннюю поправку, то есть двигали то, что мы и так уже двигали вместе со всем кварталом. Теперь же мы выполняем внешнее исправление и собираемся двигать точки, которые пока оставались нетронутыми. Может быть, мы выпрямим продолжение проезда на улице, но погнём все линии, с которыми у него общие точки, в частности саму улицу?

Погнём ли мы другие линии или не погнём определяется принципом работы команды Q. Предположим, что часть проезда, к которой мы применяем Q состоит из одного отрезка, соединяющего две точки - одну на здании и одну на улице. Одна из этих точек - передняя арка на пересечении проезда со зданием -  выделена для применения Q с указанием направления. Предположим, что ещё одной выделенной точкой, уже не относящейся к проезду, является другая точка на передней стене здания, и мы, соответственно, хотим сделать линию проезда перпендикулярной этой стене. Точка передней арки, принадлежащая проезду, зафиксирована, а на линии проезда остаётся ещё одна точка, которую команда Q уже может переместить. Эта точка также входит в линию улицы, форма которой изменится при неаккуратном перемещении точки. Чтобы прямая улица осталась прямой, точку надо перемещать именно вдоль улицы, а не в каком-либо другом направлении. Переместит ли её именно в этом направлении команда Q? Если мы проделали описанное ранее выравнивание сторон квартала, то да.

Для того, чтобы команда Q сделала своё дело, ей надо переместить незафиксированную точку проезда на перпендикуляр к стене, проходящий через зафиксированную точку. Перпендикуляр является бесконечной прямой, так что точку можно было бы перемещать в любом направлении. На деле перемещаться она будет по кратчайшему пути, то есть *по перпендикуляру к перпендикуляру к стене*, то есть *параллельно стене*. Ранее мы могли позаботиться о том, чтобы стена стала параллельна улице, и тогда точка будет двигаться точно вдоль улицы, что нам и нужно. Так что к нашему списку условий, при выполнении которых нам хватает одного вызова команды Q, можно было бы добавить ещё одно: проезд мы стремимся сделать перпендикулярным линии улицы.

Тут же мы можем указать, когда линия улицы всё-таки погнётся после применения Q:
- линия улицы проведена не совсем параллельно реальному направлению улицы, так что даже если мы и выравнивали края квартала, направляющие не были параллельны этой линии;
- мы не стали выравнивать края квартала, и стена осталась непараллельной улице;
- стена на самом деле не параллельна улице; правда в этом случае меньше смысла пытаться сделать перпендикулярным ей проезд;
- на самом деле мы пытаемся не сделать проезд перпендикулярным стене, а продолжить его в направлении тоннеля, который идёт под непрямым углом к улице.

Обычно ситуация складывается так: либо всё ровно, и тогда у нас нет указанных проблем с применением Q, либо всё криво, и тогда мы особо не волнуемся, что что-нибудь погнётся. К тому же, выпрямить линию улицы часто можно одним щелчком мыши и одним нажатием клавиши после исправления всех проездов. Поэтому мы не стали вносить отсутствие перечисленных абзацем ранее возможных обстоятельств в список условий, при которых у нас не будет проблем с использованием Q. Осталось заметить, что помимо линии улицы или даже нескольких линий улицы такие же рассуждения применимы и к прочим линиям, имеющим общие точки с продолжением проезда. Из этих линий тротуар нередко бывает кривоват, так что сильно портить в нём нечего. Если же дело дошло до того, что были нарисованы другие упомянутые ранее линии типа границ площадного хайвея, то они, скорее всего прямые и параллельные улице, так что одно из перечисленных обстоятельств нам не грозит. Кроме того, точки пересечения проезда с ними весьма необязательны.

### Недостаточная перпендикулярность стене

Перейдём, наконец, к давно перечисленным пронумерованным условиям отсутствия проблем с вызовом Q и посмотрим, что будет при их невыполнении. *Первое условие касалось угла, на который линия проезда отклонялась от желаемого направления.* Поскольку команда Q может загнуть проезд вместо этого направления в направление, перпендикулярное ему, мы и хотим, чтобы отклонение было не слишком большое. Q выберет ближайшее направление из желаемого и перпендикулярного ему, и нам нужен именно первый выбор, однако могут наступить обстоятельства, при которых более вероятен второй. Шансы этого тем выше, чем дальше мы сдвинули квартал по направлению вдоль улицы или к улице, и чем короче был отрезок проезда между сдвинутой точкой и несдвинутой. Чаще всего короткий отрезок находится между сдвинутым зданием и несдвинутым находящимся рядом с ним тротуаром.

Если такие обстоятельства наступили, то при применении Q часть проезда загнётся под прямым углом к желаемому направлению. Нам нужно следить за результатами работы команды, и как только мы заметим подобное загибание, действие нужно отменить, а затем поспособствовать правильному выбору направления. Способствовать мы будем, сдвигая вручную несдвинутую вместе с кварталом точку пересечения вдоль улицы так, чтобы направление проезда стало ближе к нужному. Сдвиг мы выполним в режиме X, удерживая Ctrl, чтобы не погнуть линию, с которой пересекается проезд.

Тут для нас открываются два варианта действий. В одном из них мы можем подвинуть вручную точку с достаточной точностью, чтобы отказаться от использования Q совсем. Правда, в сложившейся ситуации нам обычно не удастся ограничиться сдвигом лишь одной точки. Точка, из-за которой нам пришлось вмешиваться в работу команды Q нередко находится на пересечении проезда с тротуаром. Если это так, то есть ещё одна точка пересечения проезда - теперь уже с улицей - которая тоже должна быть подвинута. Если мы откажемся от вызова Q, нам придётся двигать вручную и её, и прочие точки пересечения проезда.

Если же мы выберем вариант с вызовом Q, мы можем особо не заботиться о точности ручного сдвига, и выполнять его понадобится, скорее всего, лишь для одной точки. В принципе нам может и не повезти, если линия тротуара проходит близко к линии улицы, и нам не удастся ограничиться сдвигом лишь одной точки и в этом варианте. После сдвига точки на тротуаре уже следующий отрезок проезда окажется направлен ближе к перпендикуляру к нужному направлению, и мы окажемся в ситуации, подобной исходной, только теперь станет на одну мешающую точку меньше. К счастью, всего общих точек достаточно мало, и двигать вручную больше двух точек для одного проезда практически никогда не бывает нужно. Ещё заметим, что команду Q можно вызывать прямо из режима X, а действия в режиме X не влияют на выделение и не зависят от него. Значит, можно перейти в режим X с уже выделенными линиями и точками, и чередовать перемещения точек с попытками применения Q.

### Отсоединение от линий с другой стороны улицы

Теперь перейдём к следующим условиям, невыполнение которых помешает нам подвинуть точки, как вручную в режиме X, так и командой Q. Одно из них - про *соединение нашего проезда с проездом с другой стороны улицы*. Соединение это может быть существующим в реальности, заданным в осмовских данных и одновременно существующим и заданным. Рассмотрим сначала соединение в данных, так как его нам легче заметить. Если оно присутствует, с обеих сторон улицы было нарисовано по проезду друг напротив друга. Находятся ли эти проезды в реальности друг напротив друга, мы можем пока не знать.

Мы сейчас поправляем описанными выше способами один из этих проездов. Его поправка приведёт к сдвигу точки соединения проездов, а, значит, и к изменению формы соседнего проезда. Соседний проезд загнётся в сторону перемещения общей точки. Насколько далеко он загнётся зависит от того, как далеко мы сдвинули вдоль улицы проезд - вместе с кварталом или после того ещё и отдельно. Собственно, если мы двигали проезд отдельно посредством сдвига точки арки вдоль стены здания, мы могли как раз руководствоваться тем, чтобы сохранить его положение напротив соседнего проезда. Так было бы, если бы мы проверили расположение проездов друг относительно друга по какому-либо источнику, а также проверили правильность расположения соседнего проезда.

Всем этим мы, конечно, могли и не заниматься, и тогда перед нами стоит вопрос: надо ли нам сохранить эту общую точку двух проездов или лучше их отделить друг от друга и каждый из них соединить с улицей отдельно. Если мы сохраним соединение, то куда девать его точку: оставить напротив одного из проездов, чтобы тот был прямой, или поставить посередине? В таком виде вопрос встанет, если улица была нарисована одновейкой. Если же мы имеем дело с двухвейкой, вместо общей точки будет общая перемычка. Если перемычки, соединяющей соседние проезды нет, то нет и рассматриваемых здесь проблем. Пока предположим, что у нас одновейка.

Неопределённость с положением точки соединения говорит о том, что проезды лучше разделить и пересоединить с улицей отдельно. Нам также известно и другое нежелательное явление, избежать которого поможет разделение проездов - непредвиденный переход в пешеходном графе на месте соединения проездов. Если такой переход уже есть, разделение проездов его устранит, если его ещё нет, или говорить о нём пока неактуально, потому что никто не пытался запрещать ходьбу по проезжей части, разделение предохранит от его появления в будущем.

Если мы решились разделить проезды, первое, что нам нужно - чтобы они были представлены отдельными элементами-линиями. В режиме выделения мы кликнем на часть поправляемого нами проезда, соединяющуюся с улицей, в результате чего мы увидим, что входит в данный элемент-линию. Если мы увидим, что выделенная линия не заканчивается в точке соединения с улицей, а пересекает её, мы добавим к выделению точку пересечения и вызовем команду разделения линий (P). Теперь у каждого проезда своя собственная линия, но пока ещё общая точка соединения с улицей.

Следующая задача - сделать так, чтобы у поправляемого проезда со своим соседом общей точки не было. Для этого мы могли бы попытаться исключить точку соединения с улицей из поправляемого проезда с помощью команды Alt-J. Это делать не очень удобно, так как в результате пропадёт значительная часть проезда до предыдущей точки соединения с чем-либо. Если же этой точкой является арка, потому что помимо улицы проезд соединяется только со зданием, команда исключения точки не сработает вообще. Вместо этого нам лучше разъединить линии путём превращения одной общей точки в несколько точек, входящих в отдельные линии. Именно это и делает команда {% action "UnGlue" %}разъединения линий{% endaction %} (G), которой мы уже могли воспользоваться ранее для перемещения задних арок.

Как и в типичном случае применения команды G к задней арке, в интересующей нас точке сходятся три линии. Следовательно, простейший вызов команды, когда выделена только одна точка, создаст дополнительно ещё две точки, что для нас неудобно. В случае с аркой неудобства в трёх точках на самом деле не было, потому что обе новые точки принадлежали частям корректируемого нами проезда, и обе их было нужно переместить, что было легко сделать. Сейчас же нам, скорее всего, нужно переместить точку только одного из проездов, ведущего к нашему кварталу. Другой проезд мы ни двигать, ни отсоединять не хотим. Тогда нам больше подойдёт второй рассмотренный нами способ вызова команды G с указанием линии, который только для этой линии и создаст точку.

Сейчас необходимые действия выглядят так: выделяем линию исправляемого проезда, добавляем к выделению точку его соединения с улицей, вызываем команду G. На месте соединения теперь две точки, одна из которых принадлежит только исправляемому проезду. Тут мы могли бы, действуя по аналогии с применением G для задней арки, сразу перетащить уже выделенную точку проезда, но для проездов снаружи имеет смысл вместо этого применить команду Q. Чтобы ей воспользоваться, мы сбрасываем выделение и снова выделяем исправляемый проезд, теперь со всеми его частями, которые мы собираемся подвинуть и повернуть. Добавляем к выделению точки, по которым команда Q направит проезд и вызываем саму команду. Проезд подвинется, не затрагивая своего соседа и улицы, от которой он всё ещё отсоединён. Присоединить его можно командой N, предварительно выделив его конец, созданный командой G. В случае направления проезда перпендикулярно улице, этот конец окажется очень близко к её линии, и проблем с применением N не будет. Если конец всё-таки оказался далеко от линии улицы, его можно подтащить с помощью продления или сокращения линии проезда в режиме X.

Иногда встречаются вариации соединения проезда с линией на другой стороне улицы, когда эта линия не является проездом. Эта линия может быть, например, улицей на Т-образном перекрёстке, и её мы определённо не хотим двигать вместе с нашим проездом, значит, сдвигаемый проезд нам придётся известным способом отсоединить. Другой возможностью, к которой придётся отнестись внимательно, может быть линия пешеходного перехода. В данном случае речь идёт о реальном переходе, который должен сохраниться после наших преобразований, а не о ложном, получаемом из-за соединения проездов. Проезд и переход должны, по идее, не просто соприкасаться, а перекрываться, так как переход должен соединиться с тротуаром, а проезд - с проезжей частью. Как бы это место перекрытия ни было нарисовано до нас, сдвигая проезд, мы имеем возможность отделаться от неудобного перекрытия. Лучше будет не вести две линии проезда и перехода по одному и тому же месту, а раздвинуть их хотя бы немного, что мы и сделаем разъединив, подвинув и правильно пересоединив линии. Главное - не забыть продлить одну из линий, если до нас у них была лишь общая точка концов, а не перекрытие.

### Перемещение проезда мимо точек на улице

Что нам делать, если проезды расположены друг напротив друга в реальности? Допустим, что соседний проезд расположен правильно, и после сдвига напротив него оказывается поправляемый нами проезд. Точки соединения проездов с улицей окажутся очень близко друг к другу, так что у нас возникнет желание их объединить. Что последует в результате реализации этого желания, мы уже знаем. Если мы точно хотим соединить проезды в одной точке, нам придётся выделять в них часть посередине улицы, на которую мы поставим тег {% tag "foot=no" %}. Понятно, что вместо этого было бы проще не соединять проезды, и если они хоть чуть-чуть смещены друг относительно друга в реальности, стоит воспользоваться этим фактом.

Если вдоль улицы расстояние между проездами составляет метр, и между их точками соединения с улицей тоже оказывается метр - то и пусть он остаётся, эти точки объединять не обязательно. Правда, можно сказать, что это не самый надёжный способ действий, так как желание объединить точки может возникнуть позже у другого участника. Но можно понадеяться, что просто ради объединения точек никто это место трогать не станет, а в случае более значительных правок откроются и более широкие возможности испортить граф пешеходной маршрутизации, и в этой порче мы виноваты не будем.

Если мы не будем объединять точки, то нам может понадобиться подвинуть одну из них мимо другой. Проблема проявится в том, что линия улицы, в которую также входят обе эти точки, приобретёт форму зигзага. Этот зигзаг может быть очень маленьким или очень плоским, если точка переместилась точно вдоль улицы. Даже маленький зигзаг нам не нужен, а небольшой размер ещё и вреднее тем, что его сложнее заметить. Так мы перешли к невыполнению третьего условия отсутствия проблем применения команды Q. Невыполнение заключается в наличии точек на линии улицы, мимо которых должна переместиться точка поправляемого проезда.

В простейшем случае на линии улицы будет две точки: одна, которая стоит на месте, и другая, к которой присоединён исправляемый нами проезд. Вторая точка в результате перемещения проезда перемещается и сама. В качестве первой точки только что была упомянута точка соединения с другим проездом, идущим со стороны, противоположной перемещённому нами кварталу. Это довольно часто попадающийся вид точки, с которой придётся иметь дело в рассматриваемой ситуации, но возможны и другие, например, лежачие полицейские, остановки транспорта, знаки ПДД или даже стыки двух участков улицы с разными тегами. Чем именно является такая точка нас не интересует, потому что трогать мы её не собираемся... Или собираемся?

Перед нами может встать вопрос, не должен ли отмеченный первой точкой объект остаться с той же стороны от перемещаемого проезда, где он был и ранее. На подобный вопрос мы только что отвечали для соединений проездов, только речь шла не о том, с какой стороны должна оказаться точка относительно перемещаемого проезда, а о том, должна ли она быть в принципе в стороне. И в прежнем виде, и в текущем это является топологическим вопросом, на который мы, как редакторы геометрии, должны были бы ответить, что точка должны остаться с той же стороны или так же совмещённой, как она была до наших действий. Однако мы не всегда ограничивали себя таким ответом ранее, и не всегда будем ограничивать им в ситуациях, рассматриваемых сейчас. Мы знаем, что существующая в данный момент топология проездов не обязательно соответствует действительности, а сохранять то, что не соответствует действительности, не имеет смысла.

Если нам не лень, мы можем проверить по панорамам или чему-либо подобному, с какой стороны от проезда находится объект типа лежачего полицейского. Если он был расположен относительно правильно, но в рассматриваемой ситуации после сдвига проезда поменял бы сторону, значит он не был расположен правильно абсолютно. Мы можем подвинуть его на правильное место известным нам способом в режиме X, после чего нарушение третьего условия исчезнет. Значит, нам остаётся рассмотреть дальнейшие действия в том случае, когда от сохранения топологии мы отказались и решили оставить точку на месте.

Что тогда делать, в общем-то очевидно, так как почти такая же ситуация была рассмотрена ранее. Мы пользовались командой G, чтобы отцепить точку нашего проезда от места его соединения с улицей и соседним проездом, прежде чем двигать наш проезд. Теперь нам надо сделать то же самое, только проще: точку надо отцепить только от одной линии улицы. Для этого мы могли бы использовать команду G без выделения линии проезда, что в данном случае тоже приведёт к раздвоению точки. Однако точка в исходном месте соединения улицы с нашим проездом, скорее всего, не нужна, и мы можем вернуться к использованию команды Alt-J, от которого ранее отказались в пользу G. Исключать точку из проезда мы по прежнему не можем, но теперь нам это не нужно, вместо этого мы исключим её из улицы, выделив вместе с точкой её линию и вызвав команду. Дальнейшие действия будут такими же, как после отделения проезда командой G.

### Двухвейка

Пока что мы предполагали, что улица, к которой ведут поправляемые нами проезды, является одновейкой, и проезды с противоположной стороны соединялись с тем же самым элементом-линией улицы. При двухвейке проезды соединяются с разными линиями, и части проблем, связанных с их соединениями, разделениями и двиганиями одного мимо другого, можно избежать. Проезды с другой стороны не смогут создать для нас никаких проблем, если в том месте, где они подходят к улице, обе её линии не соединяются перемычкой. Например, при отсутствии перемычки, два проезда, расположенные друг напротив друга, не приведут к появлению непредвиденного перехода через улицу в графе маршрутизации, куда бы мы не поставили точки их соединений.

Даже если перемычка и есть, и оба проезда соединяются с ней с разных сторон, непредвиденного перехода избежать легче. Нам не понадобится распиливать линии проездов в необычном месте ради того, чтобы поставить на их фрагмент тег {% tag "foot=no" %}. Этот тег мы можем поставить на перемычку, где он и так должен стоять, даже если к ней не присоединены проезды. Правда, перемычка может быть не выполнена в виде отдельной линии, а быть просто продолжением линии проезда, в случае чего линию придётся разрезать. Зато место нужного разреза - пересечение проезда и улицы - уже не столь необычно, как пересечение проезда и тротуара, да и разрез там нужен в любом случае. Исключением могут быть лишь те проезды, по которым не положено ходить, ведущие, например,  на встроенную в здание парковку или на промобъект, а не в двор жилого дома. На такие проезды {% tag "foot=no" %} можно ставить целиком.

Конечно, двухвейка не облегчает нам задачу перемещения проездов мимо прочих точек на линии улицы. Сложность этой задачи зависит от того, сколько таких точек наши предшественники посчитали нужным поставить. Если улица выполнена двухвейкой, ей уделили больше внимания, значит и точек на её линиях может быть больше. Например, чаще будут попадаться точки деления на участки с разными полосами, про которые для одновейки никто бы не подумал. Да и сами перемычки не вызовут проблем в случае если они были поставлены правильно. Но, как мы знаем, их могли поставить напротив проезда при преобразовании одновейки в двухвейку, не проверяя их реального существования. Тогда правильность их расположения зависит от правильности ранее нарисованных проездов, а она в нашем сценарии сдвига квартала есть не вполне. В итоге нам может понадобиться заниматься разъединением, перемещением и пересоединением перемычек так же, как и подобными операциями для точек пересечения проездов и одновейки. Возни тут будет побольше, потому что команда G не раздвоит перемычку, а M - не объединит. Это простимулирует нас проверить, существуют ли перемычки в реальности. Если их нет, мы их просто потрём и избавимся от проблем.

### Помехи сбоку от проезда

У нас осталось последнее условие отсутствия проблем при использовании команды Q для исправления проезда. Прежние условия относились к объектам, с которыми проезд соединялся. Теперь же мы посмотрим на объекты, которые просто находятся рядом. Собственно условие заключается в том, что если проезд не пересекался с одним из таких объектов, то после выравнивания он тоже с ним не пересечётся. Если объект находится достаточно близко по направлению смещения проезда, условие нарушится, и пересечение состоится. Типичным примером является проезд между газонами, расположенными на тротуаре. Между газонами был нарисован разрыв напротив арки, но арка была нами сдвинута вместе со всеми зданиями и оказалась уже напротив того места газона, где разрыва нет. Значит выпрямление проезда теперь приведёт к тому, что он пройдёт по газону. Именно на примере газона мы и продолжим рассматривать действия по исправлению подобных ситуаций.

Первое, что по этому поводу мы могли бы сделать, это сдвинуть газон вместе с кварталом. Очевидно, что тогда условие бы не нарушилось, и исправления после сдвига квартала бы не понадобились. Если мы оказались в рассматриваемой ситуации, то газон мы не сдвинули либо по ошибке, либо намеренно. Зачем нам могло понадобиться его намеренно не двигать? Возможно, мы решили, что газон правильно расположен. Это весьма вероятно, так как газон это объект, полностью находящийся на уровне земли, благодаря чему его легче нарисовать несдвинутым по спутниковому снимку, сделанному под углом. Тогда исправлять нам надо не положение газона, а положение арки, что мы должны были сделать до исправления проездов, хотя это не поздно сделать и сейчас.

Также весьма вероятен и другой вариант: газон нарисован так криво, что нет никакого толку его двигать вместе со всем кварталом, несовпадения с реальностью будут в любом случае. Криво газон может быть нарисован тоже из-за особенностей доступных снимков, например, если он закрыт зданиями. Нам, вероятно, придётся поправить мешающий проезду кривой газон, хотя иногда можно без этого обойтись. Если в газоне никто не пытался рисовать разрывы для проезда, то и нам это делать не обязательно, тогда газон можно просто не трогать, а проезд пойдёт как бы поверх него. Тут даже не важно, криво или правильно нарисован газон, вырезать его часть под проезд можно как-нибудь потом, после того, как мы закончим действительно необходимые поправки. Другое дело, если на газоне нарисованы ещё какие-либо объекты типа деревьев, через которые проезд проходить не должен. Тогда придётся заниматься ручным редактированием, для которого сложно придумать общий рецепт.

Остаётся случай, когда разрыв нарисован, но после нашего сдвига квартала и арки он оказался не на месте, при этом внутри газона никаких дополнительных мешающих нам объектов не нарисовано. Первым делом мы исправим проезд, не обращая внимание на газон, после чего нам станет ясно, куда надо переместить разрыв. Конечно, при наличии подходящих снимков это нам было бы ясно и до сдвига проезда, и мы бы действовали в противоположном направлении, позиционируя по снимку проезд. Если так и есть, то ориентиром для сдвига разрыва выступают уже снимки, а не проезд, но для нас это сейчас не важно. Важно то, что прежде чем двигать разрыв, мы произвели действия, позволяющие нам определить место, куда мы его двигаем. Если мы ориентируемся только по проезду, мы не можем быть уверены в абсолютной правильности этого места, но нам всё равно лучше подогнать разрыв под проезд.

Вдобавок к сдвигу проезда мы будем перемещать параллельные ему края частей газона. Обычно затронуть надо будет две части с двух сторон от проезда: одну часть сократить, другую удлинить. Делать мы это будем, конечно, в режиме X или его вариации XX. Выше мы пытались использовать эти режимы для сдвига краёв зданий, чему часто мешали дополнительные точки на краях и примыкающие к ним объекты. Теперь помех должно быть гораздо меньше. Если затрагиваемый участок газона прямоугольный целиком или хотя бы со сдвигаемой стороны, у нас не будет никаких проблем перетащить её в режиме X. Поскольку газон мог быть нарисован криво, этот вариант может не сработать, один из углов газона останется на месте и войдёт в возникший при нём зубец. Бороться с этим мы можем предварительной ортогонализацией газона, но этот вариант доступен не всегда. Например, газон может на самом деле быть неортогональным, или проезд, а вместе с ним и разрыв в газоне может не быть перпендикулярным другим сторонам газона. В этой ситуации самым простым способом действий является сдвиг стороны части газона в режиме XX. Тогда нам не важно, насколько форма газона близка к ортогональной, и, по сравнению с предварительной ортогонализацией, изменения мы в неё внесём только локально, рядом с проездом.

Примерно так же, как и с газоном, мы сможем разобраться и с другим достаточно большим площадным объектом, который помешает нам подвинуть проезд. Достаточно маленький площадной объект, например, ларёк, мы подвинем целиком, как и точечный объект. Ближе к рассмотренным манипуляциям с газоном окажутся поправки, вносимые нами в мешающие проезду линейные объекты. Типичным таким объектом является заборчик по краю тротуара. В отличие от газона, мы точно не хотим, чтобы проезд шёл поверх заборчика, значит, нам надо внести в него разрыв, передвинуть существующий разрыв или сократить заборчик, передвинув его крайнюю точку. Передвижения точек мы можем произвести в режиме X с нажатым Ctrl.

## Прочие связанные с проездами поправки

Примерно так выглядит решение проблем, мешающих подвинуть проезд и направить его в нужную сторону. Теперь вернёмся к ряду моментов, которые мы при рассмотрении операций над проездами были вынуждены отложить.

### Выпрямление улицы

Первый момент: *не погнули ли мы линию улицы, когда исправляли линию проезда?* Если линию проезда мы делали перпендикулярной улице, то нет. Но что, если мы повернули линию в другом направлении, тогда команда Q двигала точку соединения проезда и улицы не вдоль улицы, и улица в результате этого погнулась. Мы можем не обращать на это внимания, пока не поправим все проезды вдоль отдельно взятой стороны квартала. Затем мы выпрямим весь участок улицы, проходящий вдоль этой стороны. Сделать мы это можем, отнесясь к нему как к набору точек, который надо выстроить в линию. У нас есть две крайние точки на перекрёстках у углов квартала. Эти точки мы не трогали, и по соединяющей их прямой мы можем выстроить все остальные точки участка улицы. Для этого нужно выделить и крайние, и остальные точки, затем вызвать команду L.

Так нам потребуется неоднократно тыкать мышкой по точкам улицы, а выше мы обещали, что часто бывает достаточно лишь одного тычка. Это *часто* произойдёт в случае, если участок улицы вдоль нашего квартала выполнен в виде отдельного элемента-линии. Улицы действительно бывают разрезаны по перекрёсткам для того, чтобы включать их участки в разные отношения административных границ или маршрутов или просто ставить разные теги. У таким образом вырезанного участка нам не понадобится выделять все точки, достаточно выделить сам участок и применить команду L к нему.

Если нам не повезло, и у улицы не вырезан такой участок, количество необходимых тычков мышкой слегка увеличится. Нам уже придётся выбирать точки, но поскольку они находятся на одном элементе-линии, есть способ ускорить этот процесс. Нам достаточно выбрать две крайние точки, а дальше использовать команду {% action "MiddleNodes" %}Middle nodes{% endaction %} из меню Select, которая там будет при включённом плагине utilsplugin2. К полученному в результате выделению уже можно применить команду L.

Противоположным вариантом невезения будет улица, слишком разрезанная на части. В дополнение к разрезам на перекрёстках могут присутствовать и разрезы внутри участка, проходящего вдоль квартала. Вряд ли их очень много; когда они присутствуют, их бывает не больше пары штук. Соответственно, нам может прийти в голову выделить их все перед применением команды L. Это, скорее всего, сработает, но надо обратить внимание на некоторые особенности применения команды L к линиям. На данный момент такое применение в справке к JOSM незадокументировано вообще. Без документации нетрудно догадаться, что команда сделает с одной выделенной линией. Но что она сделает с двумя и более? Она выпрямит каждую линию по отдельности. Это значит, что каждая из линий станет прямой, но все вместе они на одной прямой могут не расположиться. Нам же нужно именно расположение всех выбранных частей улицы по одной прямой.

Из сказанного выше следует, что результат работы команды может нас не устроить, но произойдёт это лишь в том случае если мы сдвинули точки разрезов. Сдвинуть их мы могли, если к ним были присоединены проезды. Наиболее вероятная причина таких присоединений - задание ограничений поворота. Однако, обычно ограничения не заданы, проезды с разрезами улицы не соединены, и тогда у нас не было причин их трогать. Если мы их не трогали, они по прежнему стоят в соответствии с геометрией улицы. Если эта геометрия, как мы предполагаем, прямая, то точки разрезов расположены на одной прямой, и, следовательно, нет разницы между выпрямлением элементов-линий улицы по отдельности и вместе. Тогда применение команды L к нескольким линиям даёт нужный результат.

Раз выпрямление при описанном выше способе действий применяется к линиям отдельно, мы можем сообразить, что то же самое получится и при такой последовательности действий: выделяем первую линию, вызываем L, выделяем вторую, вызываем L и так далее. Поскольку повторений потребуется весьма небольшое число, этот вариант действий окажется самым простым, если вызывать команду L нажатием на клавишу, про которую мы постоянно напоминаем читателям. Нам по прежнему нужна уверенность в том, что точки разрезов мы не трогали, так что при выделении линий мы будем обращать внимание на их концы: если к ним ведёт проезд со стороны нашего квартала, от выделения линий придётся отказаться.

На случай, если применения L к линиям не дают желаемого результата, рассмотрим, какие ещё варианты действий имеются. Понятно, что тогда нам надо либо выделять не линии, а точки, либо применять к выделенным линиям не L, а что-то другое. В качестве возможного чего-то другого мы можем придумать команду ортогонализации Q. Однако, на самом деле она нам не подойдёт. Во-первых, если выделены только линии, она в результате своей работы не гарантирует какого-либо их направления. Это не было бы большой проблемой, потому что мы могли бы добавить к выделению пару точек на нужной прямой, например, перекрёстки, тем самым направление задав. Но это может нам и не помочь, потому что команда не гарантирует и того, что линии получатся прямыми. При неудачных для нас обстоятельствах команда может изогнуть некоторые участки под прямыми углами, чего мы точно не хотим. Вдобавок к этому нет и гарантий того, что точки, уже находящиеся на нужной нам прямой, например, те, которых мы вообще не трогали, после применения команды не будут сдвинуты. Итого, лучше на Q для выпрямления улиц не рассчитывать.

Попробуем тогда выделять точки. Ясно, что можно добавить к выделению все точки улицы от одного перекрёстка до другого, кликая по каждой из них. Ясно также, что нам хотелось бы найти способ побыстрее. Мы уже знаем про команду Middle nodes, так что нам, конечно же, захочется попробовать применить её к двум выделенным перекрёсткам. Это теперь не сработает, потому что команде нужны две точки на одной линии. Но, может быть, мы сможем добавлять с её помощью точки участков последовательно - выделим концы первого участка, применим команду, добавим ещё невыделенный конец второго, применим команду и так далее? Нет, это тоже не сработает, команде нужны ровно две выделенные точки, так что добавить следующий участок точек к уже выделенному нельзя.[^11-middle]

[^11-middle]: Для тех, кому и так понятно, как работают команды, и, соответственно, непонятно, зачем мы тут их расписываем, вопрос: что сделает Middle nodes, если обе точки входят в несколько линий? Для всех остальных ответ: выделятся промежуточные точки во всех подходящих линиях. Ещё вопрос: а если выделить две точки замкнутой линии? Ответ: выделятся точки, находящиеся на таком пути между исходными двумя, который проходит через наименьшее количество точек. Ещё мы можем хотеть знать, не относится ли эта команда по-особому к месту замыкания замкнутой линии? Мы знаем, что, например, команда G относится, но Middle nodes, вроде, этого не делает. Конечно, при выделении точек улицы все эти особенности не проявятся, но вдруг они нам когда-нибудь пригодятся. В документации они ожидаемо не описаны.

Что же сработает? Сработает, например, соседняя по меню с только что рассмотренной команда {% action "SelectWayNodes" %}Select Way Nodes{% endaction %}. Ей можно последовательно добавлять точки участков: выделяем первую линию, применяем команду - выделение линии поменялось на выделение её точек; добавляем к выделению вторую линию, применяем команду - выделение этой линии тоже поменялось на выделение точек, а ранее выделенные точки никуда не делись; и так далее. Но также можно применить команду и к нескольким линиям сразу - в этом случае разница между несработавшим методом *выделили линии - применили L* заключается лишь в том, что перед L надо вызвать Select Way Nodes. Так точки выстроятся по одной прямой независимо от того, каким линиям они принадлежат.

Наконец, возможен промежуточный, самый неудобный вариант невезения. Улица может быть на перекрёстках не разрезана, а между ними - разрезана. Из-за разрезов Middle nodes нам не поможет, и придётся выделять линии. Когда мы выделим все линии улицы, проходящие мимо нашего квартала, выделение будет также высовываться за перекрёстки. Даже если нам это покажется неправильным, сейчас неподходящее время для того, чтобы резать улицу по-другому, так что продолжим работать с уже созданными её линиями.

Самым ленивым вариантом действий будет, опять же, простое применение L к участкам. Это даст желаемый результат, если все они были расположены на одной прямой до наших правок, и мы не двигали точки разрезов. Если разрезы мы двигали, то как и раньше, мы можем перейти к выделению точек с помощью Select Way Nodes. Если же участки не расположены на одной прямой, что теперь более вероятно, то дополнительно к переходу к точкам нам потребуется исключить из выделения лишние точки, находящиеся за перекрёстками. Делать это придётся уже вручную, кликая по каждой из них с нажатым Ctrl. Ясно, что если их много, то легче наоборот вручную добавить все точки, которые надо выстроить в прямую.

Итого, как нам лучше действовать в общем случае? Сначала мы даже не знаем, на какие части поделена линия улицы, и не узнаем этого, пока не выделим её. Значит, с попытки выделения линии мы и начнём. Кликнем по линии улицы рядом с нашим кварталом и посмотрим, докуда продолжится выделение. Для каждого из двух концов выделения возможны три варианта: недостаёт до перекрёстка, идёт ровно до перекрёстка, продолжается за перекрёсток. Учтя их вместе, мы можем действовать следующим образом, который мы назовём *план A*:
- *Если оба конца идут ровно до перекрёстков*: просто применяем L.
- Иначе, *если оба конца достают до перекрёстков и, возможно, идут дальше*: сбрасываем выделение, выделяем перекрёстки, применяем Middle nodes, применяем L.
- Иначе будем добавлять к выделению линии улицы, чтобы достать до перекрёстков с обеих сторон, после чего перейдём к *плану B*.

*План B*, когда выделено несколько элементов-линий, образующих цепочку:
- *Если оба конца выделенной цепочки идут ровно до перекрёстков*: применяем L.
- *Если ровно один из концов цепочки выходит за перекрёсток*: смотрим на тот перекрёсток, за который заходит выделение. Если нам очевидно, что за ним линия улицы меняет направление, переходим к *плану C*. Если нет, внимательно смотрим на точку перекрёстка, применяем L, замечаем, сдвинулась ли точка. Если точка сдвинулась, отменяем действие L и переходим к *плану C*.
- *Если оба конца цепочки выходят за перекрёстки*: если мы чувствуем себя очень внимательными и готовы следить за двумя точками сразу, действуем как в предыдущем пункте и при любом перемещении точек отменяем операцию и переходим к *плану C*. Или сразу к нему переходим.

*План C*, когда выделенная цепочка торчит за перекрёстки и ещё и не прямая:
- *Если выделение торчит не слишком далеко, и точек за перекрёстками в нём не слишком много*: переходим к выделению точек с помощью Select Way Nodes, кликаем с Ctrl по каждой лишней точке, пока их не останется, применяем L.
- Иначе придётся признать, что никакие хитрые средства редактора нам не помогли, и надо сбросить выделение, добавить к выделению одну за одной точки у нашего квартала и применить L.

Сделаем пару примечаний к нашим планам:
- В *плане A* мы могли выбрать две точки, применить Middle nodes, затем L. Но ведь есть команда, которая сразу выпрямляет участок линии между двумя заданными точками - это {% help "Plugin/UtilsPlugin2#MoreTools" %}Align way nodes{% endhelp %}. Мы можем использовать её, только она более глючная, хотя в обычных ситуациях её глючность не проявится.[^11-align]
- Пока в последнем пункте *плана A* мы добавляем линии и мы не вышли за пределы перекрёстков, мы можем последовательно применять к ним команду L, как было описано выше. Смысл в этом может быть такой: на только что добавленную линию мы смотрим, и пока мы смотрим, нам легче оценивать изменения, вносимые командой.
- В тех случаях, когда мы применяем команду L к выделенным линиям, мы всегда перед этим можем перейти к выделению точек с помощью Select Way Nodes. Зачем это может быть нужно, мы сказали ещё до планов: выстроить линии по прямой, даже если были сдвинуты их точки соединений друг с другом.
- Если дело дошло до *плана B*, гораздо выше становятся шансы того, что выделенные линии не были выстроены по прямой и не должны стать выстроенными. На самом деле так может быть и при *плане А*, но об этом ниже. Наиболее вероятная непрямая конфигурация улицы - прямые участки между перекрёстками и изгибы на перекрёстках. Сами изгибы могут быть весьма небольшие, так что глядя на форму линии их можно не заметить. Поэтому и предлагается следить за возможным перемещением точек перекрёстков при выпрямлении линий - если они там и так прямые, перемещения не будет. С другой стороны, можно представить себе такую ситуацию, когда перекрёсток и оба конца выделения находятся на одной прямой, но где-то между перекрёстком и концом за ним есть намеренно заданный изгиб линии. Тогда перекрёсток не переместится, а изгиб мы прибьём, что весьма нежелательно. Такая ситуация маловероятна, но чем дальше уходит выделение, тем больше шансов на неё нарваться. Значит, при далеко идущем выделении для безопасности вместо плана B можно переходить сразу к плану C.

[^11-align]: Чтобы глючность Align way nodes обнаружить, надо задавать вопросы, как выше мы это делали в примечании к Middle nodes. И если вы при этом ожидаете, что ответы на них для Align way nodes будут подобны, то вы ошибаетесь. Что сделает Align way nodes, если две выделенные точки входят в несколько подходящих линий? Она не сделает ничего. Что, если выделить две точки в замкнутой линии? Команда попробует выпрямить путь с наименьшим количеством точек, но на точке замыкания она может обломиться. То есть, к замкнутой линии её лучше не применять. Ещё можно ожидать сюрпризов при использовании команды после undo. Тут мы можем подумать, а не слишком ли мы придираемся к этим командам из плагина, ведь точно так же мы могли бы подразобрать и стандартную команду L при её применении к линиям? Могли бы, и обнаружили бы, что она работает более логично. Например, выпрямлять замкнутую линию L откажется, выдав соответствующее сообщение. Интереснее, конечно, как эта команда справится с выпрямлением двух линий с общей точкой посередине. Если такое выпрямление возможно, то справится. Если же оно невозможно... тут мы, видимо, разработчиков поймали.

Конечно, описывая здесь выпрямление участка улицы, мы предполагали, что он был прямым до всех наших действий, или что он должен быть прямым. Если весь целиком участок прямым быть не должен, в нём могут иметься отдельные отрезки, которые должны, и мы можем выпрямлять отдельно каждый из них. В этом случае нам, скорее всего, придётся вручную выделять необходимое множество точек. Если и такие отрезки обнаружить не удаётся, нам придётся разбираться отдельно с каждым небольшим фрагментом улицы между двумя соседними к сдвинутой нами точке. Тогда мы не будем откладывать исправления улицы до того момента, как мы исправим все проезды. Мы будем исправлять фрагмент сразу после действий над проездом, выделяя сдвинутую точку и двух её соседей и вызывая L, или просто решая, что и так сойдёт, и ничего не трогая.

### Сдвиг проездов вместе с кварталом { #move-driveways-with-block }

Второй момент: *что, если мы решили двигать проезды вместе с кварталом?* Тогда мы знаем, что улицу мы точно погнули, и её надо исправлять, как в первом моменте. Но если мы знаем, что легко можем выполнить такое исправление, почему мы не двигаем таким образом проезды всегда? Может быть, нам неудобно добавлять проезды к выделению квартала. Но ещё это не избавит нас от проблем, создаваемых прочими точками линии улицы на пути перемещения проезда и общими точками конца проезда с чем-либо помимо улицы. Проблемы с общими точками ещё и усугубляются, так как раньше мы в случае необходимости отвязывали проезд до того, как двигать его часть за пределами квартала, и избегали таким образом деформации линий, подходящих к улице с противоположной стороны.

Если бы мы хотели избежать усугубления проблем, нам следовало бы отвязать проезды от улиц до перемещения квартала. Это добавило бы ещё возни перед сдвигом квартала, и если выполнять отсоединения для каждого проезда отдельно, такой вариант получится не быстрее рассмотренного ранее исправления проездов после сдвига квартала. Даже если мы и отвяжем проезды, мы можем лишь поменять одни проблемы на другие. Раньше нам всегда было видно предыдущее взаимное положение соединений проездов и объектов рядом с ними на линии улицы, и мы могли иногда решать это положение сохранить, сдвигая объекты вместе с проездами. После отвязывания мы уже можем не заметить, как место соединения проезда с улицей переместилось с одной стороны объекта на другую, и тогда мы не сможем решить подвинуть объект.

Конечно, если перемещение по направлению вдоль улицы идёт лишь на небольшое расстояние, то и проблемы с общими и прочими точками на улице будут небольшие. При достаточно малом перемещении проблемы с прочими точками просто не возникнут, а общих точек часто просто нет. Тогда, вроде бы, и усугубляться нечему, но, с другой стороны, и преимуществ от отсоединения проездов, компенсирующих возню с отсоединением практически не будет.

Допустим, мы решили что такие мелочи, как возможные решения о сдвигах не связанных, но находящихся рядом с проездами точек на улице нас не волнуют, а проезды мы отвязать перед сдвигом квартала хотим. Как нам быстрее всего это сделать? Ранее мы отсоединяли проезд в случае необходимости одним из двух способов: исключением его конца из улицы, если с этим концом ничего другого не соединялось, и дублированием точки конца в прочих случаях. Чаще нам нужен именно первый способ, который реализовывался выделением точки конца и линии улицы и применением команды Alt+J. Теперь у нас несколько концов, а линия улицы, обычно, по прежнему одна. Точнее, она одна с одной стороны квартала, а сторон несколько, но пока допустим, что мы проделываем отсоединения проездов от улиц для каждой стороны отдельно. Работая с одной стороной и, соответственно, с одной линией улицы, мы можем воспользоваться особенностью команды Alt+J, позволяющей нам не выделять линию, если в неё входят несколько выделенных точек. То есть, нам достаточно выделить множество точек концов и вызвать Alt+J, а из какой линии их исключить, команда догадается сама.

Конечно, указанная особенность Alt+J сэкономит нам не слишком много времени, а если улица даже вдоль одной стороны квартала разделена на части, как рассматривалось чуть выше, вариант вызова команды с указанием точек из разных линий, но без указания линий не сработает совсем. Понятно, что мы могли бы выделять и меньшие наборы точек соединения улиц и проездов, соответствующие лишь одной линии улицы, но толк от такого подхода по сравнению с отсоединением каждой точки по отдельности уменьшается. Эти отдельные линии улицы нам надо для начала увидеть, что легче сделать, выделяя их, но мы ведь хотели воспользоваться особенностью команды, позволяющей линии не выделять. К тому же, нам надо было бы заранее знать, что все точки соединения выделять не следовало, а если мы уже взяли и все их выделили? Надо ли нам выделение точек сбросить, чтобы продолжать?

Обратим внимание на ещё одну особенность команды Alt+J, позволяющую игнорировать лишние точки. Из неё будет следовать то, что в описанной выше ситуации от выделения линий мы отказаться не сможем, зато уже выполненное выделение точек нам выбрасывать не понадобится. Мы даже можем предположить, что выделили мы точки соединения проездов с улицами не с одной стороны квартала, а со всех сторон сразу, когда линий улиц, конечно же, несколько. Теперь нам бы хотелось добавить к выделению и все линии улиц, чтобы команда Alt+J исключила все указанные точки из всех указанных линий. К сожалению, команда так не работает, линию указать можно только одну. Тогда мы можем действовать так: выделим одну из линий для исключения, применим Alt+J, уберём линию из выделения и добавим туда другую, применим Alt+J и так далее, пока не исключим все точки. Это сработает, потому что команда не будет обращать внимания на точки, не входящие в указанную линию.

Только что рассмотренное применение команды Alt+J ко всем точкам сразу со включением-исключением из выделение линий по одной подойдёт в качестве средства спасти уже выполненное выделение точек. Однако по прежнему непонятно, зачем выделение всех точек делать вообще. Мы знаем, что в целом это делать не слишком удобно, потому что отвязывать и даже двигать полностью вместе с кварталом проезды не слишком удобно. Но тут мы решили рассмотреть вариант с отвязыванием, так что эти неудобства мы в расчёт не принимаем. Альтернативой для нас по прежнему является отсоединение точек по отдельности. Проблема данной альтернативы в том, что нам недостаточно кликнуть по точке и вызвать команду, надо ещё выделять и линию. К сожалению, Alt+J, в отличие от G, не обращает внимания на то, в какой линии точка находится на конце, а в какой нет, и относиться по особому к концам линий проездов не может. Однако сами клики по точкам нам придётся выполнять и так, и так. Вот если бы было средство сразу выделить все точки соединения проездов с улицами...

Средство выделения всех пересечений проездов с улицами мы можем придумать, вспомнив про поиск и фильтры. Зная синтаксис выражений поиска, нетрудно догадаться, как выбрать точки посредством свойств их родителей, но этого будет недостаточно, поскольку у проездов из соседних кварталов свойства такие же. Значит, нам придётся учесть в выражении выбора принадлежность к нашему кварталу, что должно быть нетрудно сделать, так как мы уже нарисовали рамку для его выделения. То есть, мы хотим выражение для выделения, основанное на предыдущем выделении, что поиск позволяет сделать. Предыдущее выделение мы получим с помощью рамки, но применять к ней мы будем не команду All inside, которая не выделит элементы-линии проездов, выходящие за пределы квартала, а команду {% action "SelectIntersectingWays" %}Intersecting ways{% endaction %} (I). Последнюю команду мы [рассматривали в главе про выделение области](../6-select/#intersections-with-frame) как раз применительно к выбору таких линий-проездов, которые пересекают нашу рамку.

Итак, мы выбираем рамку, применяем I, а дальше остаётся запустить в поиске выражение для выбора точек, у которых в родителях есть и выбранная линия проезда, и линия улицы. Выражение может выглядеть как-то так: `type:node child(selected highway=service) child(highway=residential | highway=unclassified | highway=tertiary | highway=secondary | highway=primary)`. Более того, мы можем использовать его и в фильтрах. Фильтр может оказаться удобнее, потому что он сохраняется, отображается в окне сбоку, и его можно применить одним нажатием на кнопку в этом окне. Правда, тут мы натыкаемся на не вполне очевидные особенности работы фильтров. Как может работать фильтр с выражением, в котором присутствует условие выделения `selected`, ведь он влияет на отображаемые элементы, а отображаемость влияет на выделение? Тем не менее, он может, учитывая выборку перед своим применением.

Если мы будем использовать фильтр с указанным выражением, нам надо также не забыть его инвертировать, отметив чекбокс в колонке *I* окна фильтров. Для этого надо включить фильтр чекбоксом в колонке *E*, отметить чекбокс *I* и отключить фильтр. Теперь он готов к применению. Можно выделить рамку, выполнить команду выбора пересечений, включить фильтр, выбрать все оставшиеся в окне редактирования точки, например, с помощью Ctrl+A, и отключить фильтр. Если мы выбираем точки именно с помощью Ctrl+A, надо не забыть перед этим переключиться на окно редактирования, так как клик по окну фильтров активирует именно окно фильтров, в котором Ctrl+A задействовано по-своему. Теперь мы находимся в той ситуации, когда мы пытались применять Alt+J к точкам из нескольких линий, и мы можем таким же образом исключать точки из каждой линии по отдельности.

Проделав в JOSM эти манипуляции с поиском и фильтрами и написав этот рецепт, я подумал, а не легче ли вместо этого написать скрипт для CommandLine? И я его написал. Называется он HighwayDisconnect, что может поменяться, также могут поменяться его аргументы и особенности работы, поэтому мы не будем рассматривать его применение в этой записи. Способы отсоединения проездов от улиц мы тоже закончим рассматривать. Перейдём теперь к возможно существующим и пока не устранённым нами соединениям сдвигаемых целиком проездов с другими объектами.

Помимо линии улицы проезды будут соединяться и с линией тротуара. Разобраться с ней мы можем таким же образом как и с линией улицы, правда, нам придётся в меньшей степени ожидать, что она распилена на удобные для выпрямления части. Линия тротуара часто заворачивает на углах квартала, или наоборот идёт прямо мимо следующего или предыдущего квартала улицы. Но никакой возни с выпрямлением части линии тротуара не возникнет, если мы и её двигали вместе с кварталом, что логично было сделать, раз уж мы взялись двигать и проезды. Конечно, мы опять перемещаем проблемы в другие места, которыми теперь будут соединения тротуаров с пешеходными переходами. Но если этих мест меньше, то меньше и проблем, а переходов мы ждём по две штуки на угол квартала, то есть обычно их всего восемь. С восемью переходами мы как-нибудь разберёмся, хоть вручную их перерисуем.

Ещё мы можем вспомнить про возможные общие элементы-точки в местах пересечения линий проездов с прочими линиями типа "переездов" через трамвайные пути. Выше, когда мы не пытались двигать вместе с кварталом части проездов за его пределами, мы объявляли такие точки не слишком большой проблемой. Мы считали, что последующие за сдвигом квартала поправки проездов обычно не исказят объекты, делящие с проездами эти точки. Впрочем, мы также решили, что большинство из этих точек на самом деле не нужны, так что мы готовы их удалить в случае возникновения помех. Теперь такой случай практически гарантированно настал.

Так как мы перемещаем линии проездов целиком, мы перемещаем также и общие точки. Так как перемещаем мы всё это вместе с кварталом, направление перемещения вряд ли строго совпадает с направлением улицы, да и улиц вокруг квартала несколько, так что со всеми не совпадёшь даже если захочется. Значит, смещающиеся общие точки исказят форму своих объектов, чего мы не хотим. Если мы убедились в ненужности общих точек, то их удаление будет самым простым решением для сохранения формы объектов. Нам даже не обязательно удалять точки до сдвига квартала, так как их удаление после даст тот же самый результат. Главное - все эти точки заметить.

### Проезды не сквозь здания

Третий момент: *как быть с проездами, которые не проходят сквозь здания?* Если мы их двигали как во втором моменте, то нет разницы между ними и рассмотренными ранее проездами, сквозь здания проходящими. Если же мы собираемся как обычно поправить проезды после сдвига квартала, для быстрого проведения этих действий у нас может не оказаться некоторых элементов геометрии, на которые мы рассчитывали. Эти элементы - стены зданий и точки на месте их пересечения с проездами, то есть арки. Арки были нужны для того, чтобы отделять части проездов, перемещаемые полностью вместе с кварталом, а также для того, чтобы задавать фиксированные точки, относительно которых поворачиваются продолжения проездов на улице. Направление же поворота обычно определялось стенами зданий.

Иногда у нас имеются аналоги стен и арок, которыми мы можем так же воспользоваться. Если проезд проходит не сквозь здание, а сквозь забор, который перпендикулярен улице, ситуация совсем похожа на уже рассмотренную. Вместо стены здания у нас сам забор, вместо арки - точка его пересечения с проездом, на которой обычно обозначены ворота. Аналога тоннеля нет, и вместо операций по его исправлению ничего делать не нужно. Из внутренних правок остаётся лишь слегка подкорректировать геометрию проезда за забором, аналогично тому, как мы её подкорректировали бы за задней стеной здания. Понадобится это делать, только если мы сдвинули ворота отдельно от всего квартала, чего обычно мы не делаем.

Такие же аналогии можно провести для проезда, пересекающего любую линию рядом с краем квартала, примерно перпендикулярную улице. Если точка пересечения не обозначена, её можно временно поставить перед сдвигом квартала и удалить после всех поправок. Если же нет и линии, можно временно провести и её, хотя в действительности нам это делать не понадобится, потому что подходящая линия всегда есть в наших временных построениях. Нам может показаться, что этой линией является направляющая, по которой мы выравниваем передние стены зданий, но на самом деле она нам не совсем подходит. Точку пересечения мы хотим поставить *до* сдвига, а направляющая же нарисована относительно границ квартала *после* сдвига.

Получается, что установку точки пересечения проезда с направляющей придётся отложить до завершения сдвига квартала. Однако перед сдвигом нам всё равно нужна точка в линии проезда, которая бы находилась между границей квартала и несдвигаемыми точками на улице. Эта точка должна перемещаться вместе с кварталом, чтобы уходящая от неё вглубь квартала часть проезда не деформировалась и не сдвинулась относительно квартала. Мы можем поставить эту точку, например, на пересечение проезда и рамки для выбора элементов квартала. После выполнения сдвига квартала мы уже можем добавить в проезд ещё одну точку - теперь на пересечение с направляющей, к которой для целей поправки проезда мы сможем относиться как к передней стене. Точку пересечения с рамкой после этого можно удалить.

Часто можно обойтись совсем без использования какой-либо линии, выполняющей роль передней стены. Например, проезд может проходить ровно посередине между двумя зданиями. Тогда можно вставить в него временную точку между передними углами зданий и переместить её на середину с помощью команды Shift-B. Сделать это можно как до, так и после сдвига квартала. Дальше какой-либо из этих углов можно использовать вместе с временной точкой посередине как указатель направления для команды Q, применяемой к линии проезда.

Тут мы, правда, не договорили про ещё одну разницу между проездом через арку и тем, что у нас сейчас. Команда Q применяется к элементу-линии, и в случае с аркой у нас был отдельный элемент для торчащего за пределами квартала конца проезда. Теперь у нас такого элемента нет, потому что проезд не распилен на части в только что поставленной нами точке. Если нам это мешает, мы можем сами его распилить, а после применения Q обратно объединить. Или мы можем хотеть применить Q и к части проезда внутри квартала - это зависит от её формы и соединений. Или мы можем обойтись без Q - средств редактирования у нас достаточно.

### Тротуары

Четвёртый момент: *проезды пересекаются также с тротуарами, чем их линии отличаются от линий улиц?* Сами линии тротуаров нарисованы, обычно, кривее, что даёт возможность не беспокоиться о том, что мы их подпортим. Если же они нарисованы не криво, то идут они параллельно улице, и тогда мы их не испортим по тем же причинам, что и улицу. Препятствий для перемещения проезда на линии тротуара бывает гораздо меньше. Проезды с противоположной стороны улицы до тротуара не доходят, и точек объектов на нём практически не бывает. Иногда линия тротуара бывает распилена на части в связи, например, с различным покрытием, но это чаще встречается рядом с углами квартала, где проездов нет. Я не помню, чтобы мне при перемещении проезда хоть раз что-то помешало на самой линии тротуара, и отвязывать и перепривязывать к ней проезд мне по этой причине не приходилось. Только что сказанное касалось того варианта действий, при котором мы тротуары не перемещали вместе с кварталом.

Пятый момент: *что, если тротуары вокруг квартала мы сдвинули вместе с ним?* Если вдобавок к этому мы не двигали арки отдельно от квартала, линии проездов погнулись не между зданиями и тротуарами, а между тротуарами и улицами. Для нас это обычно удобнее, так как изгиб в этом случае менее крутой, а выпрямление проезда затронет тротуар в меньшей степени. Неудобнее то, что к изогнутым линиям теперь прибавятся пешеходные переходы. Зато переходов гораздо меньше, чем проездов, обычно их по паре штук на сторону квартала у его углов. Ориентир для исправления часто имеется, так как зебра бывает хорошо видна на спутниковых снимках.

Для исправления перехода можно подвинуть его точки в режиме X в соответствии со снимком. Есть и другой способ - провести заново поверх его изображения временную прямую линию, поставить точки её пересечения с улицей и тротуарами, на эти точки переместить точки ранее обозначенного перехода, после чего он станет совпадать с временной линией, которую теперь можно удалить. Этот способ нужен для того, чтобы переход стал точно прямым без использования на нём команды L, которая могла бы искривить улицу. Если тротуары строго параллельны улице, а переход строго ей перпендикулярен, можно его выпрямить как проезд командой Q. Однако переходы не всегда бывают перпендикулярны улице, из-за чего нам и может понадобиться способ со временной линией.

## Конец поправок

Справившись с проездами, мы можем считать, что с поправками к сдвигу квартала покончено. Тогда нам остаётся лишь удалить временные построения и выгрузить правки на сервер. Временными линиями, которые надо не забыть удалить, являются:
- рамка для выбора квартала;
- восстановленные углы;
- направляющие линии.

Ещё у нас могут оставаться временные точки, которые мы добавляли в проезды, не имеющие точек у края квартала. Такие точки мы можем решить и оставить, если они нужны нам для фиксации формы линии проезда. Итак, мы знаем, что нам надо удалить, чтобы покончить с нашим делом, но вместо этого мы можем не удержаться и захотеть ещё немного поредактировать данные перед выгрузкой, так как временные линии могут нам в этом помочь.

### Углы

Линии восстановленных углов должны нам напомнить о возможности перерисовать соответствующие срезанные или скруглённые углы зданий. Когда эти углы рисуются вручную, результат получается весьма корявый, и у нас, уже повозившихся с углами, может возникнуть желание их перерисовать. Перерисовка заключается в применении ко временной линии скрипта Fillet из стандартного набора CommandLine и в последующем подтягивании контура здания под результат работы скрипта. Скрипту надо передать линию восстановленного угла, угловую точку, радиус кривизны и количество отрезков в скруглении. Радиус можно попытаться измерить по снимку, часто это что-то вроде пары метров. Если угол круглый, скрипту можно разрешить автоматически определить количество отрезков. Если угол срезан по прямой, нужно запросить один отрезок.

После выполнения скрипта надо убедиться, что нас устраивает форма получившегося угла. Основная причина, по которой она может нам не подойти - неправильно оцененный нами радиус, в случае чего придётся отменить действие скрипта и попробовать другое значение. Но так, с отменами и подборами значений, нам не придётся возиться для срезанных по прямой углов. Для них корректировку формы можно осуществить в режиме XX, перетаскивая их единственный отрезок. Значит, и первый передаваемый скрипту радиус можно задать любым - ведь вместо его измерения по снимку можно с тем же снимком совместить отрезок угла перетаскиванием.

Если в данных угол не скруглён, а в реальности скруглён, то линию восстановления угла мы не добавляли. Вместо неё скрипт можно применить прямо к контуру здания, после чего его не потребуется подтягивать до временной линии. Это, конечно же, гораздо проще, если только на углу здания ничего не отмечено. Чем-то отмеченным обычно является вход, и нас интересует, куда он переместится после скругления. Нам хотелось бы, чтобы вход оказался посередине вновь нарисованного угла, но выйдет не так. Вход окажется на той точке, которую мы ранее назвали *предугловой*. Если нас не сильно интересует сохранение идентичности точки входа, тег {% tag "entrance=*" %} с неё можно убрать, и создать новую точку входа либо повесить его тег на более подходящую существующую.

Для того, чтобы переставить вход с предугловой точки на нужное место есть метод и получше. Для этого нам понадобится уже хорошо нам известная команда G. То, что она нам хорошо известна, было, конечно шуткой, потому что сейчас мы воспользуемся ещё одним, пока что не рассмотренным нами вариантом её вызова. Это применение команды к одной точке с тегами, входящей в одну линию. Результатом будет вытаскивание выбранной точки из линии, и включение в линию новой точки на том же месте. Очевидный вопрос при этом действии: куда должны деться теги точки? Правильного ответа редактор сам не знает, поэтому он нас об этом спросит в диалоговом окне. Нам надо ответить, что теги должны быть только на старой точке - это самый левый вариант, выбранный по умолчанию. Тут надо не запутаться: старая точка - это та, которая была вынута из линии и теперь готова к перемещению. До наших правок она была угловой, и мы её попытаемся сделать снова настолько угловой, насколько это возможно - если вход на самом деле находится ровно на углу. Теперь эту вынутую точку мы можем перетащить и вставить в нужное место перерисованного угла, возможно совместив с одной из только что созданных скриптом точек.[^11-save]

[^11-save]: История перетаскиваемой точки при этом должна сохраниться, несмотря на то, что у неё нет родителей, а у другой точки - есть. Так будет, потому что другая точка только что создана, и у неё нет своей истории.

Будет ли уже существовать более подходящая для входа точка, на которую можно перевесить теги или с которой можно объединить вынутый G вход, зависит от количества отрезков, использованных для рисования скруглённого угла. Если их чётное число, такая точка будет по середине угла. Если же их нечётное число, что получится в частности при срезании угла по прямой, посередине будет отрезок, в который надо будет вставить точку и переместить её на середину командой Shift-B. Подобным же образом мы можем действовать и при перерисовке уже имеющегося срезанного угла с отмеченным входом. Сразу после применения скрипта Fillet к линии восстановленного угла, мы найдём или создадим на ней точку для входа, с которой далее объединим точку входа на контуре здания.

Если входа или чего-либо ещё с тегами на углу здания нет, создавать точку посередине угла не нужно. Если Fillet применялась прямо к контуру здания, то больше не нужно делать ничего. Если она применялась ко временной линии, нужно подтянуть к ней все прочие точки контура независимо от того, есть вход или нет. При этом может понадобиться создать на контуре недостающие точки или, что бывает реже, удалить лишние. Добавлять точки можно как перетягиванием плюсов посередине отрезков в режиме S, так и вставкой в режиме A. Перетягивать плюсы может быть не слишком удобно, так как они не всегда отображаются и бывают далеко от цели. Вставка же в режиме A неудобна тем, что в нём же нельзя выполнять перетаскивание, и плюсы в нём не отображаются. Значит, придётся часто переключаться между режимами, что, конечно, легче делать нажатиями на соответствующие клавиши.

### Landuse

После завершения операций над углами квартала можно подкорректировать landuse в соответствии с новым положением границ квартала и, особенно, его углов. Для начала предположим, что квартал полностью покрыт одним, своим собственным landuse. Этот landuse мог существовать до нас, в случае чего мы могли использовать его как рамку для выбора всех внутренностей квартала. Но мы могли его так и не использовать и даже не перемещать вместе с кварталом, что может служить причиной нашего желания выполнить поправку. Например, теперь квартал стал заметно смещён относительно своего landuse или даже не полностью в него попадает, и landuse, очевидно, нуждается в корректировке. Если landuse до нас нарисован не был, мы могли его сделать из рамки, поставив на неё соответствующие теги. Поскольку мы не стремились и даже не имели возможности нарисовать её аккуратно до сдвига квартала, мы также можем хотеть её поправить.

Нашей целью будет перерисовать контур landuse в виде оболочки, натянутой на углы квартала так, что расстояние от контура до каждого из углов одинаковое. Сами углы квартала находятся либо на зданиях или прочих площадных объектах, при этом мы могли их только что перерисовать, либо на временных линиях, нарисованных для получения исходных точек преобразования. Угол квартала может не состоять из одной точки, а быть ломаной линией, которую мы хотим на определённом расстоянии повторить в контуре landuse. Повторять её легче всего в режиме параллельных линий, а определённость расстояния получится благодаря тому, что расстояние для параллельных линий ограничено шагами. Мы выберем расстояние в один шаг, который по умолчанию равен половине метра.

Наши первые действия будут таковы: для каждого контура объекта на углу квартала, содержащего его угол, проведём в режиме параллельных линий линию снаружи, отстоящую от исходного контура на один шаг. Понятно, что теги при этом нам копировать не нужно, так что проводить линии мы будем используя известные нам средства предосторожности, то есть нажатый Alt. Далее нам надо натянуть контур landuse на только что созданные линии обводки углов. Делать это можно примерно так же, как рассмотренное выше совмещение контуров зданий и результатов работы скрипта Fillet на временной линии. Возможно, сейчас мы заняты повторением только что аккуратно заданной нами формы угла здания на угле landuse, только вызывать Fillet нам уже не нужно. Если же угол не срезан и не скруглён, для него достаточно совместить одну точку landuse с одной точкой временной линии. После натягивания контура временные линии обводки объектов на углах квартала можно удалить.

Нашей конечной целью является контур landuse, состоящий из углов в виде точек или ломаных линий и соединяющих их прямых отрезков, идущих вдоль сторон квартала. В простейшем случае после натягивания на углы мы его уже получили, и дело сделано. Однако возможно, что в том, что должно быть прямым отрезком, присутствуют точки, делающие его непрямым. Эти точки нам надо просто удалить. Причиной их присутствия обычно является желание рисовавшего участника провести контур landuse достаточно близко к зданиям при том, что здания вдоль улицы нарисованы криво. Какая-то из точек контуров зданий могла слишком сильно выдаваться наружу, в сторону улицы, в результате чего участник был вынужден добавить соответствующую выдающуюся точку и в landuse. О том, чтобы у зданий ничего не торчало, мы уже позаботились, так что нам эта точка больше не нужна. Участник мог также и не заметить выдающейся точки у здания, зато её должны были заметить мы, если мы пользовались landuse в качестве рамки для выбора квартала. Тогда такую точку в landuse мы могли добавить сами перед выделением квартала, а теперь нам пора её удалить.

Мы рассмотрели один из способов поправки landuse. Однако он мог нам не подойти, так как у нас обнаружились другие взгляды на правильную форму landuse. Мы могли решить, что нас не устраивает контур landuse, повторяющий скругления, и мы хотим для него более простой формы. Тогда, вместо обводок объектов на углах квартала, мы можем обвести рамку из направляющих. Для каждой из направляющих надо провести снаружи квартала параллельную линию, отстоящую на один шаг. С точками пересечения полученных линий надо совместить углы контура landuse, и наша простая форма готова. Неудобством её будет то, что у скруглённых углов квартала достаточно большого радиуса landuse будет далеко торчать и пересекаться со скруглённой линией тротуара. Из-за таких пересечений использовать landuse как рамку для выбора квартала станет сложнее.

Раз уж мы вспомнили про тротуар, у нас может возникнуть идея подправить подобным образом и его. Например, если у нас уже есть landuse в виде обводки квартала на расстоянии полуметра, мы могли бы в режиме параллельных линий обвести landuse. Так мы можем получить новую линию вокруг квартала на расстоянии, допустим, одного метра, которую мы можем сделать новым тротуаром. В общем случае мы этого делать не станем так как тротуары с разных сторон квартала бывают разной ширины, и их линии логично проводить на разных расстояниях.

Если квартал покрыт не одним landuse, а несколькими, в самом натягивании их на углы ничего не меняется. На каждый из углов мы натянем контур того из landuse, к которому этот угол относится. Зато участки контуров между углами могут не стать прямыми, так как могут содержать точки соединения разных landuse. Они и раньше могли оказаться ломаными, но это бывало из-за лишних точек, которые достаточно удалить. Точки же соединения разных landuse удалять не следует. Нам придётся выстроить их по прямой с помощью команды L, выделив вместе с ними угловые или предугловые точки контуров landuse. Надо лишь проследить за тем, чтобы выравниваемые точки входили только в контуры landuse.

Как могут точки соприкосновения landuse входить и в другие объекты? Представим себе обычное соприкосновение двух landuse без данного явления. Найдём контур одного из landuse и станем двигаться по нему вдоль улицы к другому landuse. Мы дойдём до точки, от которой в две стороны вдоль улицы отходят отрезки контуров, принадлежащих только одному landuse, каждый - своему, а перпендикулярно улице по направлению к кварталу отходит отрезок, общий для контуров двух landuse. Отрезок этот в наших условиях очень короткий, потому что он ведёт к общему углу двух зданий или заборов, в которых физически проявляются различные landuse и их границы. Мы стремились, чтобы между линией landuse вдоль улицы и линией зданий было полметра, и после выпрямления участков landuse между углами квартала рассматриваемый здесь перпендикулярный отрезок приобретёт эту длину.

Некоторым участникам такой короткий отрезок кажется лишним. Действительно, если бы мы смотрели только на landuse, у нас было бы мало причин ставить так близко друг к другу точки, задающие их контуры. Но в осмовских данных есть не только landuse, и одна из точек короткого отрезка входит и в другие объекты. Эту точку удалить нельзя, значит, участнику, считающему отрезок лишним, придётся удалить другую - ту, в которую мы бы попали, двигаясь по контуру вдоль улицы. В результате пространство вдоль улицы между контурами landuse и линией зданий приобретает форму двух клиньев, сходящихся в одной точке. Форма эта не слишком удобна для работы, потому что расстояние между линией landuse и линией зданий по мере приближения к оставшейся точке стремится к нулю. Значит, никакого определённого расстояния между ними нет, и следовало бы снова подумать, почему оно просто не нулевое везде.

В данный момент для нас такая ситуация означает, что выстраивать по линии общую точку двух landuse и прочих объектов мы не можем. Такое выстраивание изменило бы форму прочих объектов, которую мы либо не трогали, либо только что откорректировали. Лучшее, что мы можем сделать - это восстановить ту точку короткого отрезка, которую кто-то посчитал лишней и удалил. Если нам лень извлекать её из истории редактирования контуров landuse, мы можем:
- вставить новую точку в контур одного из landuse рядом с общей;
- перетащить её примерно на то место, где она должна быть, то есть на перпендикуляр от общей точки к улице;
- вставить новую точку в контур другого landuse;
- объединить её с первой вставленной точкой.

Полученную точку уже можно выстраивать по одной линии вместе с угловыми или предугловыми точками контуров landuse.

Можно придумать вариации этих действий, не требующие ручного перетаскивания точек. Например, мы могли бы отклеить точку одного из landuse командой G, после чего добавить к выделению точки, необходимые для выравнивания по прямой желаемого края landuse и применить L. Так новая точка окажется точно в нужном месте, правда, предыдущая точка будет исключена из landuse, и её нужно будет снова туда добавить. Всё это, конечно, мелочи, которые не слишком важны и которые можно реализовать ещё десятком различных способов, до которых читатели могут догадаться самостоятельно.

На этом мы закончим рассматривать поправки к сдвинутому кварталу. Можно было бы придумать ещё много их разновидностей, но они окажутся не настолько важными, как рассмотренные в данной главе. В частности, мы не рассматривали никакие поправки, касающиеся только внутренностей квартала, хотя некоторые из них может тоже оказаться легче делать с использованием имеющихся у нас временных построений. В этой главе мы стремились в первую очередь описать действительно необходимые поправки, к которым можно отнести выпрямление стен зданий, перемещение арок вдоль этих стен и ориентацию перпендикулярно им проездов.

