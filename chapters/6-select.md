---
title: Выделение области сдвига
---

## Стандартные способы

Все знают, как в [JOSM](https://wiki.openstreetmap.org/wiki/RU:JOSM) выделить элемент. Надо перейти в режим выделения (нажав S), и щёлкнуть левой кнопкой мыши по изображению нужного элемента. Сложнее дело будет обстоять с выделением отношений и выбором одного из нескольких элементов, находящихся на одном и том же месте. Нас, к счастью, эти сложности обычно не касаются. Отношения нам не понадобится выделять вообще. Если исключить их из рассмотрения, то несколько элементов на одном месте - это несколько линий, имеющих общий отрезок. Для решения нашей задачи - перемещения квартала - мы, в принципе, можем обойтись и без выделения линий. Положение линий определяется положением их точек, перемещение линий - это перемещение их точек, а значит, мы могли бы ограничиться лишь выделением точек. Впрочем, позже, в [главе про landuse](../7-landuse/), мы коснёмся [выбора одной линии из нескольких](../7-landuse/#standard-select-one-of-multiple-ways), но это будет весьма специфическая ситуация, которую мы постараемся не создавать.

Несколько точек на одном месте теоретически возможны, но в готовых осмовских данных, которые мы получим при загрузке определённой области, такое встречается крайне редко. Правда, как выяснится далее, во временных данных, которые мы сами произведём в процессе работы, несколько точек на одном месте оказаться могут. Тем не менее, и сейчас, и потом, задача выбора отдельной точки из нескольких, находящихся на одном месте, перед нами стоять не будет. Вместо неё нам надо решать задачу выбора всех точек, находящихся в определённом месте. В данный момент нас интересует выделение всего, что находится в пределах квартала, и если из двух очень близко расположенных точек нам понадобится выделить одну, вместе с ней нас устроит выделить и другую.

### Последовательное добавление { #sequential-addition }

Один из способов выделения нескольких элементов - их последовательное добавление к выделенному множеству. Чтобы туда добавить элемент, надо кликнуть по нему, удерживая shift. Чтобы убрать из выделения лишний элемент, надо кликнуть по нему, удерживая ctrl. На самом деле ctrl можно использовать и для добавления элемента: если элемент не выделен, то он добавится в выделение, а если выделен, то уберётся. Рассмотренный ранее щелчок без shift или ctrl первым делом очистит множество от всех добавленных в него элементов. В случае, если это действие совершится незапланированно, оно может стать для нас неприятностью: мы лишимся всей проделанной для выделения квартала работы. Чтобы такое произошло, достаточно забыть нажать на shift или просто случайно кликнуть по области редактирования.

Что именно произойдёт при клике можно узнать из формы мышиного курсора. В режиме выделения курсор будет выглядеть как стрелка с пунктирным прямоугольником справа-снизу. Внутри прямоугольника слева будет символ предстоящей операции: плюс при добавлении чего-либо к множеству выделенных элементов, минус при исключении чего-либо из множества или пусто при замене множества на что-либо. Чем является это *что-либо*, можно определить по значку справа внутри прямоугольника. Там будет изображена точка для элемента-точки, отрезок для элемента-линии или пусто для пустого множества элементов. Из этого следует, например, что если прямоугольник совсем пустой, то клик приведёт к полной очистке множества выделения, с чем можно столкнуться при клике мимо изображений элементов без нажатых клавиш.

{% TODO %}картинка: курсоры в режиме выделения{% endTODO %}

Квартал может состоять из сотен элементов, из чего следует, что выделить его последовательным добавлением элементов будет затруднительно. Во-первых, кликать по каждому из них долго, во-вторых неудачный клик может сбросить выделение и заставить начать всё сначала, в-третьих нам будет трудновато кликать отдельно на расположенные очень близко друг к другу элементы, а на расположенные точно на одном месте кликать отдельно не получится вообще. Но даже и без последней трудности нам вряд ли захочется в течение нескольких минут следить за формой курсора или удерживать всё это время на всякий случай shift или ctrl. В принципе, у нас есть средство восстановить случайно сброшенное выделение, и позже мы его рассмотрим, но нам всё равно нужно как-то ускорить процесс выделения и уменьшить количество необходимых для этого операций.

Пока что единственным рассмотренным нами *способом оптимизации* является выделение линии вместо выделения отдельно каждой из её точек. Так выделять мы можем только те линии, которые мы намерены сдвинуть целиком, то есть у которых мы хотим подвинуть каждую их точку. Линии, у которых мы намерены двигать не все точки, тоже будут нам попадаться. Например, при наиболее распространённом способе работы ими будут линии проездов, соединяющие квартал и улицу. Значит, пользоваться таким *способом оптимизации* мы сможем не всегда. Однако даже если мы будем выделять линии каждый раз, когда эта возможность будет доступна, существенно процесс мы не ускорим. Нам всё равно придётся иметь дело с сотнями элементов, а, значит, нам нужны другие средства для их выделения. Если эти средства окажутся слишком грубыми, добавление и исключение отдельных элементов может быть использовано для поправки результата.

### Выделение прямоугольником

Итак, нам нужно средство выделить сразу много элементов, и оно в режиме выделения, вроде бы, есть. Это выделение прямоугольником. Чтобы им воспользоваться, надо поставить указатель мыши в один из углов прямоугольника, нажать левую кнопку, и, удерживая её, протащить указатель до другого угла. Тут можно столкнуться с последствиями того, что режим S, который мы пока называли режимом выделения, позволяет выполнять и другие операции, одной из которых является перемещение. Если под указатель во время нажатия кнопки подвернулось что-то, что JOSM считает возможным передвинуть, то это и произойдёт, так что готовьтесь это заметить и нажать undo. Ещё в режиме S доступна вставка точки в середину отрезка с её перетаскиванием, так что готовьтесь отменять и эту операцию.

Определить, что произойдёт при нажатии и перетаскивании до того, как нажатие совершено, снова поможет форма мышиного курсора. Для выделения прямоугольником курсор должен иметь уже знакомый нам вид стрелки с пунктирным прямоугольником, внутри которого не должно быть значка точки или линии. Отсутствие этих значков говорит о том, что под курсором нет элементов, которых мы могли бы случайно передвинуть или изменить. Значит, чтобы начать именно выделение прямоугольником, а не другую операцию, курсор перед перетаскиванием надо поставить в окне редактирования на место, не занятое изображениями элементов. Чтобы иметь возможность это сделать, надо, чтобы в окне такое пустое место присутствовало. Чтобы оно присутствовало, часто бывает нужно увеличивать карту, пока промежутки между элементами не станут достаточно большими. Однако, после такого увеличения на экран не поместится весь квартал, что станет одной из причин, по которой его не получится выделить целиком лишь одним прямоугольником.

Теперь настал подходящий момент рассмотреть, как можно выделить квартал прямоугольниками по частям. Эта операция аналогична его выделению по отдельным элементам. Нам точно так же доступны клавиши shift и ctrl для добавления и исключения теперь уже всего находящегося внутри прямоугольных областей. В логике работы клавиши ctrl имеется отличие: теперь она предназначена только для исключения элементов, а не для инверсии.[^6-shiftctrl] Нажимать же клавиши для достижения соответствующего эффекта можно в любой момент перед отпусканием кнопки мыши. На самом деле, это же относится и к операциям над отдельными элементами: значение имеет, какая клавиша нажата в момент отпускания кнопки, потому что именно тогда операция и выполняется, только при клике мы не замечаем разницы во времени между нажатием и отпусканием кнопки. С другой стороны, пока клавиша не будет нажата, курсор не примет отражающий предстоящую операцию вид.

[^6-shiftctrl]: Кстати, если удерживать одновременно и shift, и ctrl, получится совсем иная операция, про которую мы [вспомним через пару глав](../8-manual/#wrong-shape-and-size), хотя пользоваться ей мы не будем.

Итак, одна из проблем прямоугольного выделения следующая: в масштабе, когда на экран помещается весь квартал, между ним и окружающими его объектами недостаточно пустого места, чтобы начать построение прямоугольника выделения, да и чтобы закончить, не зацепив лишнего - тоже. Но и наличие пустого места нам не слишком бы помогло, ведь чтобы сразу выделить прямоугольником весь квартал, надо, чтобы квартал был тоже прямоугольным. Так бывает часто, но не всегда. Вдобавок к этому нужно, чтобы прямоугольная форма квартала была ориентирована так, чтобы его стороны совпадали с горизонтальными и вертикальными линиями на экране. Эти условия выполнятся, только если нам сильно повезёт, а, значит, имеет смысл поискать другие средства выделения.

{% TODO %}скриншот: Американский Псевдо-Санкт-Петербург, где нам бы сильно повезло{% endTODO %}

### Выделение лассо

В JOSM помимо режима S, в котором доступно *выделение прямоугольником*, есть похожий режим, в котором доступно *выделение лассо*. Называть мы его будем режимом SS, потому что при использовании клавиатуры для перехода в него нужно, после попадания в режим S с помощью нажатия на клавишу S, повторно нажать на S. Чтобы переключиться в него мышкой через {% help "EditToolbar" %}левый тулбар{% endhelp %}, нужно предварительно включить {% help "ExpertMode" %}режим эксперта{% endhelp %}, иначе соответствующая кнопка на тулбаре отображаться не будет. Режим эксперта лучше включить в любом случае, и в данной записи подразумевается, что так и было сделано. Включить этот режим можно в меню View. Заметим также, что термин *режим* применительно к режиму эксперта обозначает просто опцию JOSM, а не то, что мы называли и будем называть дальше режимом на протяжении данной записи, то есть *{% menu "Mode#Workingmode" %}рабочий режим{% endmenu %}*. Только что упомянутые S, SS, хорошо известный всем A, а также AA, X, XX и [рассмотренный ранее режим параллельных линий](../5-area/#parallel-mode) - это *рабочие режимы*.

При использовании лассо мы нажимаем левую кнопку на краю области выделения, а дальше перетаскиваем указатель, только теперь перетаскивание идёт не по любому пути к противоположному углу области, а вдоль её контура. Соответственно, форма области теперь произвольная, а не ограниченная прямоугольным видом. Когда кнопка отпускается, контур замыкается по прямой до точки, на которой кнопка была нажата. То есть, надо, удерживая кнопку, обвести нужную область, и её содержимое будет выделено. Точнее, так будет, если мы не изменим работу режима, удерживая клавишу-модификатор.

Так же, как и раньше, нам доступны клавиши shift и ctrl для добавления и исключения областей, хотя курсор при их нажатии не меняется. Так же, как и раньше у нас есть проблемы из-за того, что в режиме SS доступны операции перетаскивания и вставки точки, которые мы можем случайно выполнить вместо выделения. Теперь нет проблем, связанных с тем, что область выделения обязана иметь вид ориентированного прямоугольника, она может быть произвольной формы, зато её контур нужно провести вручную так, чтобы не дрогнула рука. В итоге всё равно придётся увеличить карту настолько, что квартал не поместится на экран. Значит, всё равно придётся выделять квартал по частям, рискуя потерять выделение посреди этого процесса. Должен быть метод получше, и искать нам его придётся за пределами стандартных средств JOSM.

### Некоторые особенности средств выделения

Прежде чем перейти к нестандартным средствам выделения, отметим, для чего ещё нам могут пригодиться только что рассмотренные стандартные. Ясно, что и прямоугольник, и лассо захватят все точки, оказавшиеся в области выделения, не разбирая, как близко друг к другу они находятся. Значит, если нам понадобится выделить сразу несколько точек, находящихся на одном и том же месте, мы можем захватить это место областью выделения в режиме S или SS. Позже мы будем пользоваться этим для объединения в одну точку нескольких, оказавшихся в процессе редактирования ровно на одном месте. То есть, мы будем заключать в прямоугольник или захватывать лассо то небольшое место где находится несколько точек так, чтобы туда не попало ничего лишнего.

Как мы знаем, в режимах S и SS можно выделять или исключать как точки, так и линии. Когда мы непосредственно кликали по изображениям элементов, это было очевидно: щёлкнули по точке - выделилась/убралась точка, щёлкнули по линии - выделилась/убралась линия. А на какие элементы среагируют прямоугольник и лассо? Реагируют они на те элементы, которые попали в область выделения целиком. То есть, если линия попадает в область полностью, будет выделена/исключена и она, и все её точки. Если линия попадает в область лишь частично, то сама она будет проигнорирована, хотя на попавшие точки операция среагирует. Точнее, утверждение про попадание линии целиком не совсем верно, хотя именно оно {% action "Select#Selectmultipleobjectsusingselectionrectangle" %}приводится в вики JOSM{% endaction %}. На самом деле прямоугольник и лассо реагируют на те линии, все элементы-точки которых попадают в область. Разницу между этими двумя принципами работы можно заметить только при использовании лассо.[^6-rectangle-vs-lasso]

[^6-rectangle-vs-lasso]: Да, про полное попадание линий говорится именно в разделе про выделение прямоугольником ("any ways which are **entirely within the rectangle** will be selected"), но на {% action "LassoMode" %}странице лассо{% endaction %} о других принципах работы ничего не сказано.

Пока что непонятно, зачем обращать внимание на указанные очевидные принципы работы операций и их незначительные особенности. Вроде бы логично, что они были реализованы именно так, а не иначе. Но иначе они реализованы быть могли, и такую операцию выделения мы рассмотрим уже в следующем разделе. Если же речь идёт не о выделении, а об исключении с помощью ctrl, очевидности в работе операций становится ещё меньше. Выделенная линия будет исключена только если операция на неё среагирует, то есть если все точки линии попадут в область операции. Значит, нельзя убрать из выделения линию, обводя лишь отдельные её части. Из этого же следует, что если мы исключаем обводкой с ctrl какой-либо области лишние элементы, которые мы не хотим затрагивать последующим сдвигом выделенного множества, то это ещё не гарантирует нам, что внутри обведённой области ничего не сдвинется. Все выделенные линии, входящие в неё лишь частично, останутся выделенными, а затем затронутыми последующим сдвигом. Значит, за исключениями лишних элементов придётся особенно следить. Ещё лучше было бы лишние элементы вообще не выделять. Свести к минимуму их выделения нам поможет способ из следующего раздела.

## Выделение внутри полигона

### Рисование рамки { #draw-frame }

Нестандартный метод выделения, который лучше подходит для решения нашей задачи, такой: нарисовать вокруг нужной области замкнутую линию, затем воспользоваться командой выделения внутренней области линии (*Selection > All inside*). Нестандартным этот метод является в том смысле, что для того, чтобы команда выделения была доступна, нужно установить плагин [utilsplugin2](https://josm.openstreetmap.de/wiki/Help/Plugin/UtilsPlugin2). Под рисуемой вокруг линией имеется в виду обычный осмовский элемент, только никакого значения с точки зрения осмовских данных у него нет. Перед выгрузкой отредактированных данных эту линию придётся удалить. Если на неё не ставить никаких тегов, то не забыть удалить её поможет предупреждение от JOSM. То есть, мы хотим нарисовать вокруг квартала рамку - замкнутую линию, границу области выделения, а затем, применением одной команды выделить всё внутри неё. Это в большинстве случаев будет сделать гораздо проще, чем пытаться выделять квартал средствами режимов S и SS.

Поскольку рисуемая нами рамка является элементом данных, она не исчезнет от внезапного клика или нажатия клавиши. Её можно, конечно, случайно удалить, но undo поможет это исправить. Можно каким угодно способом подправлять уже нарисованную линию рамки: перетаскивать её точки, добавлять новые, удалять ненужные. При рисовании рамки нам не надо, чтобы она проходила через уже существующие точки. И уж тем более нам не надо, чтобы добавляемые нами точки рамки оказались вставленными в настоящие линии данных. Если уже загруженные данные нам мешают, подворачиваясь под те места, в которые мы хотим поставить точки рамки, рисовать её можно на другом, специально для этого созданном слое редактирования.

{% action "NewLayer" %}Создать новый пустой слой{% endaction %} можно через меню *File > New Layer*. После этого в окне слоёв можно переключаться между старым слоем и новым. Разумеется, нам нужно проследить за тем, какой слой включен, прежде чем рисовать. При рисовании ошибиться с выбором слоя не так сложно, потому что мы при этом смотрим на его содержимое. Легче ошибиться при другой операции, когда на содержимое смотреть не надо - при скачивании данных. Поскольку мы создавали новый слой для того, чтобы нам не мешали рисовать существующие данные, нам бы не хотелось в него данные загружать. При этом, уже состоявшуюся операцию скачивания невозможно отменить с помощью undo.

Отделаться от случайно скачанных в слой для рисования рамки данных легче всего, создав ещё один слой, скопировав туда рамку и удалив слой с лишними данными.[^6-purge] Чтобы скопировать линию в другой слой, её надо выделить и выполнить операцию {% action "MergeSelection" %}*Edit > Merge selection*{% endaction %}. Это не единственный способ копирования данных между слоями, желаемого результата можно достичь и по-другому, только обычный copy-paste не подойдёт, так как при нём не сохраняется абсолютное положение элементов. По окончании рисования рамки её можно перенести на слой с основными данными либо так же с помощью merge selection, либо с помощью слияния слоя целиком через {% dialog "LayerList" %}окно слоёв{% enddialog %}.

[^6-purge]: Если бы случайно скачанных данных было мало, что обычно не так, от них легче бы было отделаться операцией purge. Работает purge отдельно по слоям, то есть, данные можно выкинуть из одного слоя, оставив их в другом, если там имелась их копия. Как ни странно, purge можно отменить с помощью undo.

При работе с несколькими слоями надо помнить, что буфер отмены является общим для всех них. Если мы нажимам undo, но при этом не видно, чтобы что-нибудь происходило, возможно, данные меняются в другом слое. Если мы, попав в такую ситуацию, хотим изменений именно в текущем слое, то следующим нашим действием должно быть либо redo для повторного выполнения невидимых изменений, либо выяснение того, что именно отменилось. Соответственно, лучше не слишком часто чередовать правки в разных слоях. Для нашей текущей задачи нам надо нарисовать только одну замкнутую линию, так что вряд ли посреди этого действия нам захочется прерваться на рисование чего-то другого в другом слое. Однако позже нам могут понадобиться и более сложные операции, требующие модификации данных на разных слоях в течение большего периода времени.

Если нам пока не хочется возиться со слоями, но и случайно вставить точку рамки в существующий элемент мы тоже не хотим, нам доступен и более простой способ действий. Речь идёт о рисовании, {% action "Draw#Ctrlmodifier" %}удерживая ctrl{% endaction %}. Так каждый клик будет создавать новую точку для рисуемой линии, и линия не пройдёт через уже существующие точки. Также создаваемые точки не будут вставлены в существующие линии, через них пройдёт только рисуемая. Исключением является возможность замкнуть рисуемую линию через свою же точку, для чего надо достаточно близко от неё кликнуть. Реализовано это не очень удобно, потому что редактор никак не подсказывает, достаточно ли близко расположен курсор, и, соответственно, произойдёт ли замыкание или будет добавлена ещё одна точка. Нам же замкнуть линию как раз понадобится. Есть и другое неудобство, из-за которого мы предпочли рассмотреть сначала вариант с созданием слоя. Раз нам другие данные мешают, расположены элементы достаточно плотно. При плотном расположении нам сложнее разглядеть рисуемую линию на одном слое вместе с реальными данными. На своём же слое линию видно было бы чётко, так как данные с прочих слоёв были бы затенены.

### Применение существующей линии { #use-existing-way }

Вместо рисования временной линии рамки можно воспользоваться и существующей линией, если найдётся подходящая. Мы могли заметить, что рисование рамки похоже на создание landuse для квартала. Такой landuse с подходящими границами мог быть уже нарисован до нас, и тогда нам ничего нового рисовать не надо. Или его может не быть, тогда вместо временной линии рамки его можно создать, если для этого есть необходимая информация. Окажутся ли подходящими границы существующего landuse или того landuse, который стоит нарисовать, зависит как от выбора области сдвига, так и от принятых традиций и целей рисования самого landuse. При выборе области нам надо решить, включать ли в неё тротуар и то, что рядом с ним. При рисовании landuse нам надо решить примерно то же самое о включении в landuse. Дальнейшие рассуждения про landuse приводятся в [следующей главе](../7-landuse/), которую можно пропустить, если вы решите не иметь дел с этим объектом.

Стоит обратить внимание на то, что команда All inside при своём применении не заменяет выбранное множество элементов, а добавляет к нему новые. Это значит, что уже выделенная замкнутая линия, которую мы указываем команде, останется выделенной и после её применения. Значит, если мы не хотим эту линию сдвигать, нам надо самостоятельно исключить её из выборки. Когда такой линией является временная рамка, нам всё равно, что с ней произойдёт, потому что мы её потом удалим. Если же мы используем в качестве границы области сдвига настоящую линию типа landuse, нам надо решить, исключать её или нет после применения команды. Если эта линия описывает контуры квартала в том виде, в котором он пребывает до нашего сдвига, мы, скорее всего, хотим сдвинуть и её. Тогда исключать из выделения эту линию нам не надо. Исключить линию в случае необходимости можно с помощью ctrl-клика.

В качестве границы области сдвига нам также может подойти линия тротуара, идущая вокруг квартала. На определённом этапе эволюции данных прямые линии тротуаров вдоль улиц могут "загибаться" вокруг кварталов. Если оказалось, что тротуар вокруг того, что мы хотим сдвинуть, отмечен одной замкнутой линией, то она нам подойдёт так же, как подошёл бы и landuse. В таком случае мы обычно хотим сдвинуть тротуар вместе с кварталом, так что его выделение нас устраивает, и исключать после применения All inside мы его не будем. Если же тротуар нарисован не относительно положения квартала в текущих данных, а, например, относительно улицы, его уже лучше исключить. Для landuse такая необходимость возникает реже.

Обычно же на тротуар как на средство выделения квартала приходится рассчитывать в меньшей степени, чем на landuse. Эволюция данных могла не только до него не дойти, но и зайти дальше, чем нам нужно, или вообще пройти мимо. Нам нужен тротуар именно в виде одной замкнутой линии, иначе описываемой далее командой воспользоваться не удастся. Чтобы такая линия появилась, нужно объединение в неё отрезков тротуаров вдоль отдельных улиц. Осмеры могут этого делать не захотеть, потому что им лень, или они не видят для этого достаточных причин. Могут даже появиться причины этого не делать: у отдельных участков тротуара вокруг квартала могут быть разные свойства типа ширины или поверхности, которые хочется передать с помощью соответствующих тегов. Разрезанный для таких целей на отрезки тротуар для выделения квартала уже не подойдёт, так что если нет и подходящего landuse, границу области выделения придётся рисовать самостоятельно.

После того, как граница области выделения нарисована и помещена в один слой с редактируемыми данными или подобрана из уже существующих элементов, надо выделить её и воспользоваться командой All inside. Помимо All inside мы можем захотеть применить и ещё одну подобную ей команду, которую мы вскоре рассмотрим. Затем, если мы решили линию границы оставить на месте, её следует исключить из выделения. Дальше, если выделение было выполнено правильно, можно переходить к следующему шагу, то есть к сдвигу. Перед этим правильность выделения лучше проверить. Какого рода ошибки нас могут ожидать? Понятно, что это будут либо включения лишнего, либо невключения нужного. Вызваны они могут быть указанными ниже причинами.

## Неправильное выделение

### Неправильная граница { #wrong-frame }

Основной причиной неправильного выделения является неправильное проведение рамки-границы области. Если нарисовать её слишком близко к зданиям, то можно не заметить, что какие-то их точки оказались за пределами области. Это может случиться и с уже существующим landuse: чем ближе к зданиям его предпочёл нарисовать его автор, тем больше шансов, что некоторые точки торчат за его пределами. Торчать они могут всего на несколько сантиметров, что окажется незаметным как для рисовавшего landuse, так и для нас. Решение этой проблемы понятно: подправить рамку или landuse так, чтобы здания захватывались полностью и повторить выделение. В ряде случаев landuse подправлять не следует, о чём подробнее написано в [следующей главе](../7-landuse/). Тогда может оказаться необходимым вообще его проигнорировать, и нарисовать рамку вручную.

Конечно, чтобы подправить область выделения, нам надо заметить те выходы элементов за её пределы, которые не слишком заметны. Нам поможет то, что после выполненной операции выделения их становится легче обнаружить. Здесь мы можем также увидеть и обещанное ранее отличие в реализации команды выделения внутренностей полигона от прямоугольника и лассо. Если прямоугольник и лассо решали выделить элемент линии, на выделение её точек это никак не влияло: к выделению добавлялась и линия и все её точки. По-другому же операция выделения могла бы действовать так: при выделении элемента-линии входящие в неё точки не выделять. Именно так и действует команда выделения внутренностей полигона.

Из всего этого следует, что если мы не видим выделенной какую-то линию, она не попала в нашу область выделения-сдвига целиком. Отсутствие выделения у линии заметить легче, чем то, что какая-то её точка немного торчит. Кроме того, если мы заметим, что выделились входящие в какую-либо линию точки, это будет означать, что не выделилась сама линия, и так мы тоже узнаем о торчащих точках. Значит, после выполнения команды выделения мы можем пройтись взглядом вдоль границ квартала в поисках отсутствия выделения линий и присутствия выделения точек. При обнаружении этого мы должны поискать рядом невыделенные линии или точки, которых мы хотели бы видеть выделенными. Эти элементы нам надо либо добавить к выделению вручную, либо изменить нашу рамку, чтобы она их захватывала.

Ещё одной из причин неправильного выделения станет намеренное рисование или использование существующей рамки так, что она чего-то не захватывает или захватывает лишнее. Например, вокруг квартала нарисован landuse и тротуар, тротуар находится снаружи landuse, по каким-то причинам не годится в качестве рамки, но его хочется сдвинуть вместе со всем остальным. Ясно, что тут легче выделить квартал по landuse, а потом добавить к выделению тротуар.

### Пересечения с границей { #intersections-with-frame }

Иногда рамку нужной формы рисовать неудобно. Например, если мы решили включить в сдвигаемое проезды, выходящие на улицу, то рамку придётся рисовать так, чтобы она захватывала их точки пересечения с улицей. Однако при этом надо не захватить точки проездов с противоположной стороны улицы, для чего придётся заниматься слаломом при проведении границы области, оставляя точки пересечения одних проездов с одной стороны рамки, а других - с другой. Ясно, что легче провести рамку без учёта проездов, а проезды добавить потом. Обычно же их просто не добавляют в выделение и не пытаются двигать целиком вместе с кварталом, вместо этого их геометрию корректируют уже после сдвига.

Впрочем, отказ от сдвигов концов проездов вместе с кварталом объясняется, скорее, не трудоёмкостью их выделения, а другими причинами, о которых мы узнаем позже. Выделить же проезды с помощью рамки, которая их целиком не включает, на самом деле просто. Для этого потребуется другая команда, выделяющая линии, пересекающие указанную - {% action "SelectIntersectingWays" %}Intersecting ways{% endaction %} (I). Выходящие на улицу концы проездов как раз такими линиями и являются. Конечно, они нужны нам в выделении вместе с внутренностями рамки, так что к выделению внутренностей их надо добавить, или наоборот внутренности надо добавить к выделению пересечений. Сделать нетрудно и то, и то, потому что Intersecting ways, как и All inside, именно *добавляет* подходящие элементы к существующему выделению, а не *заменяет* его.

Сомнения у нас может вызвать то, что выделение также является и *аргументом* команд. По идее, мы хотим применить обе команды к рамке, но вызов первой команды расширяет выделение, и вторую команду мы применяем уже и расширению тоже. Не помешает ли это её работе? Обычно нет. Если мы вызываем сначала All inside, а затем Intersecting ways, то первая команда ничего за пределами рамки не выделит, а внутри выделит всё, кроме неполностью входящих внутрь линий. Эти неполностью входящие линии - как раз те, которые пересекаются с рамкой и были бы добавлены без предварительного вызова All inside. Конечно, они также могут пересекаться и с только что выделенными элементами внутри, но для нас это значения не имеет. Также и элементы внутри могут пересекаться друг с другом, и нам это не важно, потому что они и так уже выделены.

Если мы применяем сначала Intersecting ways, а затем All inside, результат работы второй команды могут изменить только добавления первой командой замкнутых линий. Любые незамкнутые линии All inside игнорирует, именно поэтому мы её и не могли применить к тротуару вокруг квартала, составленному из нескольких отдельных линий. Мы ожидаем, что в качестве линий пересечений добавятся только незамкнутые концы проездов, хотя ещё, в зависимости от места проведения рамки, добавиться могут и линии пешеходных переходов, тоже незамкнутые. Переходы мы можем тоже как хотеть, так и не хотеть двигать вместе с кварталом, и если мы их двигать не хотим, рамку логично провести между тротуаром и зданиями, где она переходы не пересечёт.

Когда мы проводим рамку самостоятельно, мы, очевидно, обращаем внимание на то, где она идёт на протяжении всей своей длины. Если мы хотим рамку между тротуаром и зданиями, мы постараемся провести её так, чтобы она действительно везде шла между тротуаром и зданиями. Другое дело, если мы берём уже готовую линию, например, landuse, которая, как нам кажется, идёт где надо. Мы можем не заметить тех мест, где она проходит вовсе не между линиями, а пересекает их. Про возможные пересечения рамки со зданиями мы уже написали чуть выше. Теперь нам надо обратить внимание на возможные пересечения с тротуаром.

Наиболее вероятные места возникновения пересечений с тротуаром - углы квартала, где линии могут быть по-разному срезаны. Например, на протяжении сторон квартала линия landuse проходит между тротуаром и зданиями, и она не срезана на углах. Линия же тротуара там срезана, из-за чего она пересекает линию landuse. Последствия этого таковы: применение Intersecting ways к landuse выделит тротуар, так что наши ожидания на счёт того, что выделятся только концы проездов, не оправдаются. Вдобавок к этому линия тротуара может быть замкнута, что может повлиять на последующий вызов All inside. Зато, если линия тротуара действительно идёт вокруг всего квартала, её непреднамеренное выделение легко заметить. Если нам не лень, мы можем подправить форму landuse так, чтобы его контур не пересекал линию тротуара.

С рамкой, которая должна захватить пересечением только концы проездов, нас может ждать ещё один сюрприз. Собственно, почему мы говорим именно про концы проездов на улице? Потому что они обычно выполнены в виде отдельных линий. Линии часто встречающейся разновидности проездов, проходящих сквозь здания, делятся на пересечениях со зданиями, следовательно, концы таких проездов на улице являются отдельными элементами. Сейчас для нас такое деление не имеет значения, потому что мы не пытаемся выбрать конец проезда отдельно от его остальных частей, проходящих внутри квартала. Это деление нам понадобится позже, и позже мы его и рассмотрим. Там же мы рассмотрим и возможные деления конца проезда на улице, а они для нас имеют значение уже сейчас.

Итак, мы провели рамку между тротуаром и зданиями, которая пересекает концы проездов, и применили к ней Intersecting ways. Мы ожидаем выделения линий проездов от зданий до середины улицы, но вместо этого можем обнаружить, что выделяются только части проездов между зданиями и тротуарами. Это значит, что линии проездов были разделены и на пересечении с тротуаром. Тогда нам для каждого из таких проездов нужно выделить две линии с двух сторон от линии тротуара. Пересечением с одной рамкой это делать нелогично, поэтому мы можем дорисовать вторую рамку с другой стороны от тротуара, и применять Intersecting ways сразу к ним обеим. Так мы, правда, захватим и переходы, но поскольку их бывает немного, то не так трудно их вручную исключить из выделения. Или для них можно включить фильтр; к рассмотрению фильтров мы сейчас перейдём.

Наконец, снова напомним, что обычно концы проездов мы включать в область сдвига не стремимся, так что применять Intersecting ways и рисовать вторые рамки нам обычно не нужно.

### Другие плоскости, поиск и фильтры { #other-layers }

Иногда рамку вообще невозможно провести так, чтобы в неё входило то и только то, что нужно. К этим случаям относятся такие, когда через квартал проходит что-то находящееся совсем в другой плоскости, что двигать вместе со всем остальным не имеет смысла. Например, это может быть тоннель метро. Часто он никак не связан с тем, что находится на поверхности в интересующем нас месте, но проходит он прямо через элементы, которые мы хотим сдвинуть. Решение проблемы, казалось бы, простое: надо в режиме S кликнуть по нему, удерживая ctrl, и он уберётся из выборки. Однако, это, скорее всего, не сработает. Дело в том, что тоннели метро длинные, и их линии целиком в область выделения не попадают. Следовательно, сами такие линии выделены не будут, вместо них в выделение попадут некоторые их точки. В такой ситуации ctrl+клик по линии тоннеля *добавит* линию в выделение, и никак не повлияет на выделение точек. Повторный ctrl+клик уберёт линию и опять никак не повлияет на выделение точек, то есть вернёт исходную ситуацию. Для того, чтобы убрать из выделения лишнее, ctrl+кликать придётся на каждую выделившуюся точку тоннеля, а их может быть много, и они могут быть незаметны.

Тут мы вспомним, что в JOSM есть весьма {% action "Search" %}мощный инструмент для поиска и выбора{% endaction %}, который может также изменять выбранный набор элементов. Допустим, что мы хотим убрать из выделения тоннели, а на тоннелях стоят теги {% tag "layer" %} с отрицательным значением. Конечно же, мы можем исключить из выбранного набора элементов лишние по этим тегам. Для этого нам надо открыть диалог поиска (*Edit > Search...* в меню или ctrl+f), выбрать режим *Selection settings > Remove from selection*, задать строку поиска `layer<0` и выполнить поиск. И, конечно же, это не сработает по тем же причинам, по которым не сработало кликать по линии тоннеля. Тег layer стоит на линии, а на точках, через которые она проходит, его нет.

Исключить из выделения точки тоннеля можно, задав другую строку поиска. Чтобы убрать элементы, входящие в другие элементы с заданными тегами, следует воспользоваться оператором child. Строка поиска для элементов, входящих в что-либо с отрицательным значением layer выглядит так: `child layer<0`. Ещё лучше использовать такое выражение: `layer<0 | child layer<0`. Оно также затронет и сами элементы с тегом, что пригодится, если в область выделения целиком попали короткие тоннели типа участков проходов к платформам. В ряде случаев может не хватить и такого выражения. Допустим, что мы хотим исключить платформу метро. Она нарисована мультиполигоном, на котором стоит тег layer. В мультиполигон входят линии, в линии входят точки, и нам в выделение попались точки. `child layer<0` затронет только непосредственных потомков мультиполигона платформы, которыми в рассматриваемом случае являются линии. Чтобы добраться до точек, понадобится выбрать потомков следующего уровня, что можно сделать выражением `child child layer<0`. Полное же выражение для носителей тега и потомков первого и второго уровней выглядит так: `layer<0 | child layer<0 | child child layer<0`.

Нам также доступен ещё один способ исключения тоннелей или чего-либо другого, для чего можно придумать строку поиска. Это {% dialog "Filter" %}фильтры{% enddialog %}, окно для работы с которыми можно активировать из меню *Windows > Filter*. В появившемся справа окне надо нажать кнопку Add, и мы попадём в диалог, похожий на диалог поиска. Всё, что будет соответствовать введённой строке поиска, будет неактивно и невыбираемо, в том числе с помощью команды All inside. В строке поиска нам могло бы быть достаточно написать `layer<0`, так как точки, входящие в отфильтрованные линии тоже будут неактивны. Правда, это касается не всех точек, а только тех, на которых нет *интересных* с точки зрения JOSM тегов. К *интересным* тегам не относятся, например, {% tag "note=*" %} и {% tag "fixme=*" %}.[^6-uninteresting] Такие теги как {% tag "name=*" %}, {% tag "railway=station" %} и прочее, что можно встретить на точках станций метро, *интересными* являются. Возможно, на эти точки тоже стоило бы поставить тег {% tag "layer=*" %}, но надо быть готовым к тому, что его там не окажется, и тогда фильтра по строке `layer<0` не хватит.

[^6-uninteresting]: Полный список *неинтересных* тегов незадокументирован, так что узнавать его придётся из исходников JOSM. Сейчас он возвращается функцией `org.openstreetmap.josm.data.osm.AbstractPrimitive.getUninterestingKeys()`.

Чтобы избежать проблем с неотфильтрованными элементами, мы опять можем использовать строку `layer<0 | child layer<0 | child child layer<0`, как мы делали при поиске. Зато при работе с фильтрами нам её не понадобится вводить снова, когда нужно будет снова исключить тоннели. Созданный нами фильтр останется в окне работы с фильтрами, а включать и отключать его можно с помощью самого левого чекбокса, отображающегося слева от заданной нами строки поиска. Итого, чтобы исключить тоннели, нам перед использованием команды All inside надо включить наш фильтр, после чего применение этой команды не выберет ни линии тоннеля, ни входящих в неё точек. На самом деле, мы можем включить фильтр и *после* All inside, потому что всё, что отбрасывает фильтр, также убирается и из множества выбранных элементов.

Работоспособность поиска и фильтров зависит от того, сможем ли мы подобрать строку поиска, которая захватит только лишние для нас элементы. Ситуации, когда не подойдёт ни одна из рассмотренных выше строк всё равно возможны, так что кликать по отдельным элементам для их исключения иногда придётся. Может быть, убрать из выделения надо не метро, а что-то другое, для чего выражение поиска придумать сложнее. Даже если мы имеем дело с метро, рассмотренный метод может не помочь. Например, вход в метро может тоже находиться в пределах сдвигаемой области и при этом не быть под землёй, но соединяться с тем, что под землёй линиями-проходами. Тогда придётся самостоятельно решать, что имеет смысл двигать, а что нет, и выбирать вручную соответствующие элементы.

### Последние проверки

Наконец, когда мы сделали всё для того, чтобы выделено было то и только то, что нужно, можно визуально оценить правильность выделения. Для этого надо сначала сделать так, чтобы в окне редактирования было видно всё множество выделенных элементов. Затем эти элементы надо временно передвинуть в произвольном направлении на достаточно заметное расстояние. Теперь должно быть видно, что переместится в итоге нашего последующего, уже точного сдвига. Если трудно разобрать, что сдвинулось, можно увеличивать интересующие места, особенно те, где проходит метро или что-то подобное, и/или последовательно делать undo/redo только что выполненного сдвига. В конце оценки временный сдвиг следует отменить. Если были обнаружены неточности, их следует исправить, а затем повторить визуальную оценку.

Если сказанное выше кажется вам очевидным, то это очень хорошо. Результатами ваших правок не будут зубцы и изгибы в линиях, вызванные забытыми точками. Если они попадутся вам в текущих данных, проверьте историю редактирования соседних точек, и вы, возможно, обнаружите в ней сдвиг, выполненный менее аккуратным коллегой.

## Восстановление выделения

Ещё в [самом начале главы](#sequential-addition) мы сказали, что существует средство восстановить случайно сброшенное выделение. Сразу рассматривать его мы не стали, потому что оно, как и выделение внутри замкнутой линии, является нестандартным и тоже требует плагин utilsplugin2. Теперь же, поскольку нам пора заканчивать главу про выделения, мы это средство рассмотрим. Им является команда {% action "UndoSelection" %}Undo selection{% endaction %} из меню Selection.

Сразу надо заметить, что эта команда работает странновато. В каких-то случаях она у меня она не срабатывала вообще, хотя воспроизвести я их не могу. Возможно, это были баги в определённых версиях JOSM или плагина. Как именно она должна работать в её документации описано не до конца, с чем мы нередко будем встречаться и для других операций редактирования. Также возможно создать ситуацию, в которой команда просто не сможет сработать. Тем не менее, несмотря на всё это нет причин отказываться от попытки использовать эту команду, если выделение было случайно сброшено. Сразу после того, как выделение оказалось испорченным, вызовем Undo selection - возможно, нам повезёт, и выделение вернётся.

Первое, о чём мы можем подумать - это как не испортить выделение самой командой Undo selection. Она меняет выделение, значит она может изменить правильное выделение на неправильное. Для обычного undo, отменяющего изменения данных, существует redo, позволяющий повторить отменённые операции. Однако команды Redo selection нет, значит вернуться к отменённому выделению нельзя... или можно? В документации сказано, что Undo selection можно применять последовательно, но не сказано, куда эта последовательность ведёт. Если бы эта команда работала как обычный undo, она бы шла назад по последовательности различных выделений, у которой есть начало. Дойдя до начала, команда больше ничего не могла бы изменить. Если мы будем повторять вызов команды, мы заметим нечто другое. Сначала мы действительно будем идти назад по последовательности выделений, но ни к какому началу, дальше которого отменять нельзя, мы не придём. Выделение будет продолжать меняться, возвращаясь к ранее активным вариантам. Тогда уже становится трудно предугадать, что именно мы получим в результате следующего вызова. Значит, лишний раз лучше эту команду не выполнять.

Попробуем сломать последовательность выделений. Нельзя выделить то, чего нет, так что удалим какой-нибудь ранее выделенный элемент. Конечно, вернуться к его выделению команда не сможет. Видимо, ей придётся снова выбрать существовавшее ранее множество без данного элемента. А если элемент был единственный во множестве? Видимо, команда должна этот шаг в истории пропустить. А если мы перед отменой изменения выделения отменим и удаление? Похоже, что команда всё равно не сможет вернуться к выделению восстановленного таким образом элемента. Есть история изменения данных и история изменения выделений, первая может быть определена независимо от второй, а вторая независимо от первой - не может. Значит, команда, пытающаяся работать только с историей выделений, не сможет всегда давать ожидаемый результат, если только не указать, как эта история будет пересматриваться в связи с изменениями данных, чего разработчики не делают.

Ещё у нас может быть несколько слоёв. Как мы знаем, обычный undo работает со всеми слоями сразу и может отменить действия в неактивном слое. А как работает Undo selection? Вроде бы эта команда работает только с активным слоем, но гарантировать этого я не буду. Я не слишком уверен в том, что именно произойдёт, если использовать её после переключения слоёв. С другой стороны, мы вряд ли окажемся в такой ситуации, когда применение Undo selection надо будет отложить до переключения на другой слой. Так что, хотя точные сведения о команде мы сможем получить только из её исходников, выяснять непонятные подробности её работы для обычного её применения нам не понадобится.
