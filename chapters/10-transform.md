---
title: Собственно сдвиг по направляющим
---

В данный момент у нас должен иметься набор из нескольких пар контрольных точек, по которым скрипты перемещения смогут выполнить свою работу. Скриптов этих несколько, для разного количества углов квартала. Для четырёхугольных кварталов предназначен скрипт Transform4, для менее распространённых треугольных - более простой Transform3, а что делать в других случаях мы рассмотрим в другой записи. Хотя то, что мы собираемся проделать с кварталом, мы называем "сдвигом" или "перемещением", с помощью этих скриптов мы можем масштабировать, поворачивать и перекашивать данные. Основной желаемой для нас операцией является именно перемещение квартала, но часто его стороны бывает нужно немного повернуть, сдвинуть или раздвинуть, для чего нам и приходится использовать более общую операцию, чем просто сдвиг.

## Использование скриптов

Рассматриваемые скрипты преобразуют тот набор данных, который передаётся им в качестве первого аргумента. Если какие-то данные уже выделены до запуска скрипта, они и считаются этим первым аргументом, и так и удобнее поступить: сначала выделить преобразуемые данные, затем запустить скрипт, после чего передать ему оставшиеся аргументы - пары контрольных точек.

Выделение преобразуемых данных, то есть квартала, мы уже рассматривали ранее. Но даже если мы его выполнили ранее, рисование направляющих и точек это выделение, скорее всего, не пережило, и нам его надо повторить. Конечно, если мы заранее знали, что захотим использовать сдвиг по направляющим, выделять квартал мы и не начинали, и тогда мы только сейчас начнём делать то, что было [описано несколькими главами ранее](../6-select/).

Допустим, что преобразуемые данные выделены. Следующим шагом будет запуск скрипта Transform3 или Transform4, в зависимости от количества углов квартала. Теперь скрипту надо передать пары точек исходная-целевая, как это было описано ранее для [скрипта Move](../9-guides/#move-script). Тогда у нас была только одна пара, а сейчас их несколько. Мы подвинем карту в окне редактирования так, чтобы был виден один из углов квартала и его исходная и целевая точки. Сначала, в ответ на запрос "Original point 1:", мы выберем исходную точку, затем, в ответ на "Transformed point 1:" мы выберем целевую. После этого мы перейдём к следующему углу и повторим выбор пары точек, потом перейдём к следующему за этим углу и так далее, пока углы не кончатся.

Тут надо пояснить, что такое "следующий" угол. Для Transform3 следующий угол это любой из оставшихся. Для Transform4 это уже не так. Углы надо перебирать в порядке обхода квартала либо по часовой стрелке, либо против. Представьте себе, что квартал имеет форму ромба и ориентирован так, что у него есть северный, южный, западный и восточный углы. В качестве первого передаваемого угла вы можете взять любой. Допустим, вы выбрали северный. Тогда после северного вы можете выбрать в качестве следующего западный или восточный, но не южный. Допустим, вы выбрали западный. Тогда вам остаётся передать южный, а затем восточный угол, именно в таком порядке. То есть, вы передадите скрипту восемь точек в такой последовательности: исходная северная, целевая северная, исходная западная, целевая западная, исходная южная, целевая южная, исходная восточная, целевая восточная. Если бы после северного угла вы решили перейти к восточному, то за ним нужно было бы перейти к южному, а затем к западному. В последовательности отличной от обхода квартала вокруг аргументы скрипту передать теоретически можно, но тогда результат его работы может оказаться далёким от желаемого.

Ещё надо заметить, что Transform4 рассчитан на преобразование областей формы не слишком отличающейся от прямоугольника. Слишком отличающейся формой будет, например, невыпуклый четырёхугольник. Если вы воспользуетесь скриптом на таком исходном или целевом четырёхугольнике, некоторые из точек, бывших внутри него, могут оказаться снаружи. Но даже и для областей такой формы, на которую рассчитан рассматриваемый скрипт, результат может оказаться не совсем таким, как вы хотите. Так может случиться, потому что желаемый результат это не совсем определённое понятие. Например, если внутри квартала было прямоугольное здание, после преобразования оно не обязательно останется прямоугольным. То же самое можно сказать и о более простом Transform3.

Чтобы сохранить прямоугольники и, в более общем случае, углы между геометрическими примитивами, нам потребовался бы гипотетический скрипт Transform2, выполняющий преобразование по двум парам точек. Выше мы от использования такого скрипта отказались, потому что для этого нам понадобиться действовать иначе, чем описано в этой записи. Здесь мы выполняем преобразование по углам квартала, которых как минимум три. Тем не менее, при предполагаемом здесь использовании Transform4 форма отдельных зданий внутри квартала должна не слишком сильно искажаться, потому что мы не слишком сильно меняем форму самого квартала. Речь обычно идёт о том, чтобы чуть-чуть повернуть его стороны, чтобы они соответствовали направлениям улиц. В крайнем случае, если результат работы скрипта совсем неудовлетворительный, придётся делать undo и двигать всё вручную. При этом не вся проделанная ранее работа была проведена зря, потому что нарисованные направляющие должны помочь делу.

## Линейное преобразование для треугольника

Вам может быть интересно, что именно делают рассматриваемые в этой главе скрипты, ведь неплохо бы это узнать, прежде чем ими пользоваться. Легче сначала объяснить работу скрипта Transform3. Он делает линейное (аффинное) преобразование подобно тому, как его делает плагин PicLayer для совмещения изображения с картой. Плагин позволяет сделать это, задав три пары точек. В каждой паре одна из точек ставится на изображение, а вторая - на карту. Плагин делает над изображением такое линейное преобразование, чтобы каждая указанная на изображении точка переместилась на соответствующую ей точку карты. Скрипт Transform3 тоже принимает три пары точек. Первая точка пары задаётся относительно уже имеющихся, но неправильно расположенных данных, а вторая - относительно правильного положения.

### Матрица преобразования

Что из себя представляет линейное преобразование? Его часто объясняют, как умножение вектора для каждой преобразуемой точки на [матрицу преобразования](https://ru.wikipedia.org/wiki/Матрица_перехода). Преобразуемыми точками в нашем случае будут те элементы, которые были выделены перед запуском скрипта. Если в выделение входили линии, преобразование выполняется над всеми их точками. Матрица преобразования определяется передаваемыми далее парами контрольных точек. После умножения вектора на матрицу получается новый вектор, определяющий, куда надо переместить преобразуемую точку.

Это объяснение может казаться простым для тех, кто его даёт, особенно если они математики. Но оно может показаться не совсем простым для всех остальных. Какой по вашему мнению вектор соответствует точке? У точки две координаты, значит, вы можете подумать, что вектор должен быть двухмерный. В результате мы должны получить тоже точку, значит результатом умножения двумерного вектора на матрицу должен быть тоже двумерный вектор. Если вы хоть немного представляете себе, что такое умножение вектора на матрицу, то вы решите, что матрица должна быть размера 2 × 2.

Тут выясняется, что такой матрицы из четырёх чисел недостаточно, чтобы передать всю информацию о преобразовании. Вы можете убедиться в этом так. Представьте себе, что исходная точка имеет координаты (0,0). Мы можем умножать её вектор на какую угодно матрицу, и в результате будет всегда получаться (0,0). Значит, эту точку нельзя сдвинуть вообще, чего не может быть, так как при нашем преобразовании мы можем задать её в качестве исходной точки и указать для неё целевую точку в любом месте. Оказывается, что матрица нам нужна размера 3 × 3, хотя не все её числа задаются параметрами нашего преобразования. Раз матрица такого размера, то и векторы точек должны быть трёхмерные. Откуда у точек третье измерение, если они на плоскости? Я не зря ранее назвал преобразование также *аффинным*, из чего и следует наличие третьей координаты. Эта координата всегда будет равна 1, и нужна она только для того, чтобы математически оформить преобразование как умножение на матрицу нужного размера.

Самая большая проблема - объяснить, как построить матрицу. Если вы станете искать информацию о линейных преобразованиях, когда речь зайдёт о построении конкретных матриц, вам дадут [несколько примеров стандартных преобразований](https://commons.wikimedia.org/wiki/File:2D_affine_transformation_matrix.svg). Вы будете знать, как построить, например, матрицу сдвига на определённый вектор или матрицу поворота на определённый угол вокруг начала координат. Вам также скажут, что последовательность операций можно объединить в одну перемножением их матриц, в результате чего из приведённых примеров вы сможете построить матрицу для поворота на определённый угол вокруг определённой точки. Однако для решения нашей задачи нам всё это не подойдёт, потому что начинаем мы не со стандартных преобразований, которые можно было бы найти в таблице, подобной приведённой из Викисклада.

Из чего нам собрать желаемое преобразование? Мы соберём его из двух преобразований между разными системами координат. Каждое из этих преобразований можно было бы записать в виде матрицы, а матрицы перемножить, получив в результате одну матрицу для всего преобразования. Для простоты объяснения мы перемножать матрицы не будем, а просто выполним преобразования между системами координат одно за другим. Мы даже не будем строить сами матрицы, и вообще забудем про них. Мы предположим, что у нас уже реализована операция преобразования координат между разными системами, которая сработает, если мы можем описать одну систему в координатах другой. Описанием системы будет указание точки начала координат и двух векторов координатных осей. Такой подход нам пригодится, потому что мы расширим его на случай нелинейного преобразования, которое умножением вектора на матрицу не описать. Заодно и точки, и векторы мы можем снова рассматривать как двумерные.

### Системы координат

Итак, опишем последовательность действий для нашего линейного преобразования, заданного через три пары контрольных точек. У преобразуемой точки её координаты в *глобальной* системе мы выразим в координатах *исходной* системы, определяемой первыми точками из пар исходная-целевая. Дальше мы сохраним координаты, но подменим систему на *целевую*, определяемую уже вторыми точками из пар исходная-целевая. Теперь уже из новой системы мы перейдём обратно к глобальной, что задаст новое положение преобразуемой точки.

Теперь нам остаётся разобраться, чем являются упомянутые системы координат. Их у нас было три: *глобальная*, *исходная* и *целевая*. Под глобальной мы подразумеваем ту систему, которая нашего преобразования не касается. Можно подумать, что эта система с координатами (долгота,широта), но это не так. Широта и долгота - это координаты на сфере, а точнее, на эллипсоиде вращения. Нам же нужны координаты на плоскости. Как мы можем получить координаты для плоскости, если земля не плоская? Примерно так же, как получаются двумерные изображения-тайлы. Понятно, что при этом будут искажения, а тогда можем ли мы быть уверены, что искажения не повредят нашим преобразованиям? Особых проблем из-за этого быть не должно, так как в том масштабе, в котором мы работаем - несколько сотен метров - искажения незначительны.

В общем, координаты нашей глобальной системы хоть и не являются широтой-долготой, но получены из них весьма простым преобразованием. Нам даже не надо знать, что именно это за преобразование, важно, что оно выполняется после чтения точек, и обратное ему преобразование выполняется перед их записью. Вы можете себе представить плоскую карту в том виде, в котором она отображается на [сайте осма](https://www.openstreetmap.org/), провести по ней две любые координатные оси и считать, что это и есть глобальная система. На самом деле оси не совсем произвольные, потому что для некоторых операций имеет значение угол между ними, относительный масштаб вдоль них, а иногда нужна и возможность получить абсолютный масштаб для определённого места. Однако эти дополнительные ограничения нас не интересуют, потому что скрипты Transform3 и Transform4 таких операций не совершают.

### Исходная система координат { #linear-original-coords }

{% TODO %}рисунок: исходная и целевая системы{% endTODO %}

Перейдём к исходной системе. У нас есть три исходные точки. Назначим первую из них началом системы, то есть будем считать, что её координаты (0,0). Возьмём вторую точку, и проведём через неё координатную ось от первой. Будем считать, что координаты второй точки (1,0). Остаётся третья точка, и через неё мы тоже проведём ось от первой точки. Координатами третьей точки будут (0,1). В полученной системе мы можем выразить координаты всех преобразуемых точек.

Например, пусть первая и вторая точки находятся на углах нашего пока что треугольного квартала. Тогда координаты входа с улицы в какое-нибудь из зданий на стороне между этими углами можно описать в виде пары чисел (*u*,*v*), про конкретные значения которых мы можем кое-что сказать. *u* примет значение между 0 и 1, и чем ближе вход к первому углу, тем ближе значение к 0, а чем ближе он ко второму, тем ближе значение к 1. *v* будет числом, близким к 0, и если вход расположен точно на одной прямой между углами, *v* будет равен 0, но ожидать подобной точности для исходных данных не следует. Мы можем хотеть её достичь в результате наших правок, но это дело исправлений после сдвига, и скрипты преобразований нам в этом не помогут. Если и третья исходная точка расположена на углу квартала, не занятом первой и второй, то для аналогичного входа на стороне между первой и третьей точкой, к нулю будет близка уже координата *u*. Между второй и третьей точками подобной близости к нулю уже не следует ожидать ни от одной из координат.

Если рассматривать квартал как ровно треугольный, по координатам точки можно сказать, внутри ли она квартала или вне его. Если одна из координат отрицательная или больше единицы, то точка определённо находится вне. Однако, если обе координаты находятся между нулём и единицей, то точка не обязательно находится внутри квартала. Для нахождения внутри также должно выполняться следующее условие: сумма координат не должна превышать единицу. При этом самому скрипту не важно, внутри или снаружи находится преобразуемая точка, и значения координат могут быть хоть минус сто. С другой стороны, при предполагаемом здесь использовании скрипта большинство преобразуемых точек будут находиться внутри треугольника или очень близко к его границе, так что значений координат минус сто быть не должно.

### Целевая система координат

Целевая система строится таким же образом, как и исходная, только вместо исходных точек берутся соответствующие им целевые. Если у нас нарисованы прямые направляющие, можно представить себе, что две из них являются координатными осями. Координаты у всех преобразуемых данных остаются такими же, какими они были в исходной системе. Поскольку оси теперь расположены по-другому, формально перемещение данных происходит в этот момент, хотя никаких вычислений в этот момент мы не совершаем.

После подмены исходной системы координат на целевую остаётся перейти обратно к глобальной системе и записать результат. Все вычисления при этом скрыты в преобразованиях систем: в переходе от глобальной к исходной и от целевой к глобальной, если не считать неспецифичных для наших скриптов переходов между глобальной системой и широтой-долготой. Проще математические операции от этого по сравнению с умножением трёхмерного вектора на матрицу не стали, но зато мы отодвинули сложности подальше от того места, которое нам надо понимать. Собственно, с точки зрения количества выполняемых операций, всё стало сложнее, потому что мы не объединили два перехода между системами в одну операцию с помощью перемножения матриц. Мы можем себе позволить такую неэффективность, потому что преобразовывать нам понадобится обычно не более тысячи точек.

## Проблемы с четырёхугольником

Скрипт Transform3 очень простой, но вряд ли мы будем им часто пользоваться для решения нашей задачи по перемещению квартала. Дело, конечно же, в том, что большинство кварталов не треугольные. Для рассматриваемых нами условий наиболее типичны четырёхугольные кварталы. Поскольку Transform3 не проверяет, находятся ли отдельные точки внутри или снаружи треугольника, мы можем использовать его для преобразования области любой формы или даже не области, а произвольного набора элементов. Значит, мы, в принципе, могли бы воспользоваться им и для перемещения четырёхугольного квартала.

Проблема в том, что нас может не устроить результат применения Transform3 к нетреугольной области, так как мы хотим от него определённой предсказуемости. Предсказуемость нам нужна в первую очередь для элементов рядом с углами квартала, во вторую - для элементов рядом со сторонами квартала, а от преобразований остальных элементов мы хотим соответствия преобразованиям над элементами, упомянутыми ранее. Из этого следуют и построения, выполняемые нами до запуска скрипта: обязательное обозначение контрольных точек на углах квартала и желательное - направляющих линий по сторонам. Скрипту Transform3 мы можем передать информацию только о трёх углах из четырёх, и что произойдёт с оставшимся углом, а заодно и с примыкающими к нему сторонами, будет не совсем понятно.

Рассматриваемая здесь непредсказуемость подобна той, которая возникает при использовании плагина PicLayer в аналогичной ситуации. Пытаясь совместить четырёхугольное изображение с четырёхугольным местом, но имея возможность указать лишь три пары точек, мы зафиксируем три угла. Где при этом окажется четвёртый - не совсем понятно. Понятно, что он будет недалеко от цели, но он не попадёт в неё с той точностью, с которой мы установили остальные углы. Напрямую подвинуть этот угол мы не можем, а можем только повлиять на его положение, двигая остальные углы. Каким именно окажется влияние, и как добиться нужного - это дополнительная задача, которую мы вряд ли хотим решать.

Оказавшись при линейном преобразовании в такой же ситуации с незафиксированным углом, захотим ли мы, чтобы на него повлиять, как-то сдвигать три зафиксированных угла? Нет, мы этого не захотим в ещё большей степени. Исходные и целевые точки мы задавали по конкретным принципам, и если мы от них отойдём, то мы зря старались, когда выполняли предыдущие построения. Проигнорировать незафиксированный угол мы тоже не можем, потому что из-за этого поменяется направление прилегающих к нему сторон. Это значит, что мы не воспользуемся двумя из четырёх нарисованных нами направляющих. Кроме того, уже имевшееся в данных направление сторон квартала могло быть в достаточной степени правильным, а мы его своими действиями ухудшим.

Чтобы не сделать хуже, нужно преобразование, которое учтёт все четыре угла, что и делает Transform4. Чтобы поставить четыре точки в четыре заданных места, линейного преобразования в общем случае недостаточно. Соответственно, объяснить действия нашего скрипта как умножение векторов на матрицу мы не сможем. Зато у нас по прежнему будут исходная и целевая системы координат, только построены они будут не по парам пересекающихся осей. Принцип их построения связан с тем, что мы хотим зафиксировать оставшийся угол и сохранить направления прилегающих к нему сторон, чтобы они соответствовали своим направляющим линиям.

Представим себе наш четырёхугольник, в котором мы, как и ранее, назначили один из углов началом системы координат. Далее, как и ранее мы рассмотрим две прилегающие к нему стороны. Мы скажем, что при движении вдоль одной из сторон первая координата должна расти от 0 до 1, а вторая - оставаться равной 0. Тогда мы, как и раньше, дойдём до противоположного конца стороны, и у угла, расположенного там будут координаты (1,0). То же самое мы проделаем с другой прилегающей к началу стороной, и координаты ещё одного угла окажутся (0,1). Пока всё совпадает с тем, что мы делали ранее для Transform3, только мы не говорим про то, где у нас первая точка, где вторая и где третья. Точек у нас четыре, и передаём мы их в порядке обхода вокруг квартала, потому что так удобнее их вводить. Если началом координат мы назначим на первую точку, а направление возрастания первой координаты проведём через вторую, то вторая координата будет возрастать уже в сторону четвёртой точки. Ещё можно заметить, что мы не говорим про координатные оси, и скоро станет понятно, почему.

Итак, у нас осталась ещё одна точка на углу, противоположном по диагонали от начала координат. Ясно, что мы хотели бы, чтобы её координаты были (1,1), чего мы и добьёмся. Также ясно, что если строить систему координат, как и раньше, координаты этой точки будут вовсе не обязательно (1,1). Первое, что нам может прийти в голову для устранения этого несоответствия - это [триангуляция](https://ru.wikipedia.org/wiki/Задача_о_триангуляции_многоугольника). Четырёхугольник - это два треугольника. Мы могли бы распилить его по линии, проходящей через точки (1,0) и (0,1), и в каждой половине иметь свои координатные оси. В треугольнике с точкой (0,0) мы построили бы систему координат как и раньше, а для треугольника с точкой (1,1) мы бы сделали свою систему с осями, идущими уже по его сторонам. В итоге мы бы задействовали для построения осей все стороны четырёхугольника: две стороны для одной системы координат, две другие - для другой.

{% TODO %}схема: Разбиение четырёхугольника на два треугольника со своими системами координат, а также разбиение пространства вокруг. Мы этим приёмом пользоваться не будем.{% endTODO %}

Можно заметить, что при таком подходе оси второй системы пересекаются в точке (1,1), а не в привычном для этого начале координат. Это не слишком большая проблема, можно, например, считать, что оси пересекаются в (0,0), а потом прибавить к каждой координате 1. Куда более неприятно то, что теперь нам надо решать, к какой системе относится каждая преобразуемая точка. То есть, нам надо выяснять, внутри которого треугольника оказалась точка. При Transform3 мы не проверяли, что находится внутри треугольника, а что вне. Так мы поступали, потому что хотели обрабатывать и те точки, которые находятся снаружи. Этого же мы хотим и теперь - обрабатывать и те точки, которые снаружи четырёхугольника, а такие точки не попадают ни в один из треугольников, на которые мы поделили четырёхугольник.

Мы всё ещё не добрались до главной неприятности триангуляции, потому что задача, к какой системе координат отнести точку, тоже легко решаема. Мы действительно не будем проверять, в какой треугольник попадает точка, поскольку она может не попадать ни в какой. Вместо этого мы разделим плоскость на две части, одну часть отнесём к одной системе координат, другую - к другой. Проще всего поделить плоскость по прямой, на которой лежит граница между треугольниками, то есть той, которая проходит через точки (1,0) и (0,1). Технически это легко осуществить, поскольку эта прямая соответствует стороне первого треугольника, по которой не проходят оси. Если его рассматривать так же, как это было сделано в разделе про линейное преобразование, то можно взять оттуда и [условие нахождения за этой стороной](#linear-original-coords) - то самое, где проверялась сумма координат. Это же условие годится и для всей прямой. Тогда алгоритм определения системы координат и самих координат можно реализовать так: вычисляем координаты в первой системе, проверяем их сумму, если сумма не превышает 1, то эта система и эти координаты нам подходят, иначе нам подойдут координаты из второй системы.

В чём же заключается проблема, из-за которой мы всего этого делать не станем? Проблема в том, какое в итоге преобразование у нас получится, каким из желаемых свойств оно будет удовлетворять. Мы отказались от Transform3 для четырёхугольной области, потому что хотели, чтобы линии, идущие по границе, оставались на границе, и линии, примерно параллельные границе, находящиеся рядом с границей, оставались примерно параллельными и рядом. Исходящее из разбиения четырёхугольника на два треугольника выполнение одного из двух линейных преобразований этим свойствам обычно удовлетворяет. Но это были свойства лишь для приграничных частей пространства. Для всего пространства, как в глубине четырёхугольника, так и за его пределами, желаемые свойства можно сформулировать так:

1. Как и раньше, если прямая шла по границе, то она должна остаться на границе. Проще было бы сделать это утверждение про точки, про прямые мы говорим, потому что про них же мы говорим и в остальных свойствах. Точнее, мы говорим про отрезки прямых, потому что именно из них состоят осмовские элементы-линии.
2. Как и раньше, только теперь применительно ко всему пространству, если одна прямая расположена рядом с другой прямой и примерно параллельна ей, примерная параллельность должна сохраниться.
3. Прямая не должна изгибаться слишком резко в окрестности какой-либо точки. Осмовский отрезок из двух точек, конечно, всегда будет прямым, как бы мы не двигали его концы, а других элементов-точек в нём нет. Значит, говорим мы не о нём, а о линии, состоящей из последовательности прямых отрезков, которые все вместе примерно расположены на прямой. В итоге, если получится так, что этой прямой придётся изогнуться, весь изгиб не должен концентрироваться в одной точке бывшей прямой.

Строго говоря, это не исчерпывающий набор свойств, но для дальнейших рассуждений нам хватит и его. Да и сформулированы свойства не строго. Например, зачем в свойстве 2 употребляется слово "примерно"? Затем, что точно удовлетворить ему вместе со свойством 1 невозможно. Представим себе квадрат с горизонтальными и вертикальными сторонами. Будем проводить через него горизонтальные линии, так, чтобы он весь оказался ими покрыт. Понятно, что буквально покрыть квадрат мы не можем, потому что у квадрата площадь есть, а у линии её нет, к тому же линии мы используем прямые, а не хитрые [space filling](https://ru.wikipedia.org/wiki/Кривая_Пеано). Нам нужно, чтобы между линиями было достаточно небольшое расстояние, то есть чтобы они были рядом, как это излагается в свойстве 2. Мы можем всегда этого добиться, независимо от того, какое именно расстояние мы считаем достаточно близким, потому что между двумя недостаточно близкими линиями мы всегда можем дорисовать ещё одну. Ещё сделаем так, чтобы по горизонтальным сторонам квадрата тоже проходили линии, которые были бы достаточно близко к каким-то из покрывающих линий. В итоге получится последовательность линий, первая из которых проходит через одну сторону квадрата, последняя - через противоположную сторону, и каждая из линий находится рядом с предыдущей и с последующей.

{% TODO %}схема: квадрат с покрывающими линиями и его деформация{% endTODO %}

Теперь мы деформируем квадрат, приподняв один из его верхних углов. Верхняя сторона бывшего квадрата уже не будет горизонтальной. Как наше преобразование должно поступить с покрывающими линиями, если мы потребуем сохранения точной параллельности? Если идти снизу, то нижняя линия должна остаться горизонтальной, так как она лежит на горизонтальной стороне. Следующая линия над ней тоже должна остаться горизонтальной, потому что она близко. Следующая линия - тоже, и так далее, пока мы не дойдём до линии на верхней стороне. Эта линия должна быть одновременно и горизонтальной, потому что она рядом с предыдущей горизонтальной линией, и негоризонтальной, потому что она лежит на негоризонтальной стороне. Понятно, что это невозможно, и чтобы получить что-то возможное, мы и расслабляем наше требование к параллельности. Разрешив линиям быть лишь примерно параллельными, мы сможем их постепенно поворачивать при движении от нижней к верхней стороне бывшего квадрата.

Ещё можно сопоставить свойства 2 и 3. Если в общем случае мы не требуем, чтобы прямая осталась прямой, как мы можем рассуждать о параллельности линий? Делать мы это можем так же, как и при рассмотрении режима параллельных линий в [JOSM](https://wiki.openstreetmap.org/wiki/RU:JOSM). Вместо точной параллельности мы бы потребовали постоянное расстояние между линиями. Поскольку параллельность у нас примерная, мы потребуем не слишком резко меняющееся расстояние. По идее мы должны потребовать ещё и непересечение наших примерно параллельных линий, то есть того, чтобы расстояние между ними не становилось равным нулю. В предназначенных для использования наших скриптов условиях так и будет, а что это за условия, мы рассмотрим попозже.

Так мы решили проблему с формулировкой свойств. Теперь перейдём к проблеме преобразования с разбиением плоскости на две части, которое этим свойствам удовлетворять не будет. Дело в свойстве 3, вместо которого мы хотели бы видеть что-то типа "линии должны оставаться прямыми", но нам снова пришлось довольствоваться лишь "примерной" прямотой. Точно сохранить прямоту нам в общем случае не удастся, какое бы мы преобразование ни придумали. Но для нашего разбиения мы не получим и "примерной прямоты" в сформулированном в свойстве 3 виде. Линия границы разбиения станет линией излома. Все изгибы пересекающих излом линий сконцентрируются в точке пересечения с ним, а это как раз то, чего мы не хотим. В создавшейся ситуации нет ничего удивительного, ведь всё, что находится с одной стороны от излома, мы сдвигаем так, а всё, что с другой с другой, - этак.

Проиллюстрировать излом мы можем на том же квадрате, у которого мы приподнимаем угол. Пусть для определённости это будет правый верхний угол. Разделим квадрат на треугольники по линии, проходящей через те углы, которые остаются на месте, то есть левый верхний и правый нижний. Далее проведём горизонтальную линию от середины левой стороны квадрата до середины правой. Что с ней произойдёт после преобразования? Если это осмовская линия, определяемая теми элементами-точками, которые были нами указаны, а указали мы только начало и конец, то всё будет в порядке. Линия по прежнему будет идти от середины левой стороны до середины правой, только теперь середина правой будет приподнята так, что наклон линии будет средним между наклоном верхней и нижней сторон бывшего квадрата.[^10-tan] Так будет, потому что при линейном преобразовании треугольников точки, лежащие на серединах их сторон, останутся на серединах.

[^10-tan]: В данном случае средним будет тангенс угла наклона, а не сам угол, но нас это должно устраивать.

{% TODO %}рисунок: излом в квадрате{% endTODO %}

Выше всё для нас прошло без проблем, потому что мы имели дело не с геометрической линией, состоящей из бесконечного количества точек, а с осмовской, состоящей из двух. В осмовской линии бесконечного количества точек быть не может, но и двумя она ограничиваться не обязана. В нашем примере нам достаточно будет вставить в линию ещё одну точку, чтобы всё испортить. Вставим мы её в центре квадрата, там, где пересекаются его диагонали. Одна из диагоналей окажется для нас вполне осязаемой, так как по ней проходит граница частей плоскости с разными преобразованиями. Итак, посередине этой диагонали у нас теперь тоже точка, а диагональ входит в оба треугольника, из чего следует, что после преобразования точка останется посередине диагонали. Диагональ мы выбрали ту, концы которой не перемещаются, значит не перемещается и её середина, и вставленная точка. Тогда преобразованная линия будет выглядеть так: от середины левой стороны до бывшей середины квадрата будет идти горизонтальный отрезок, а дальше оттуда линия повернёт наверх, к середине правой стороны. Прямой линия больше не будет.

Может быть, мы выбрали неправильную диагональ, чтобы разрезать квадрат? Чтобы мы могли её выбрать, надо иметь возможность передавать этот выбор скрипту. Например, это можно сделать, условившись, что диагональ проходит через вторую и третью контрольные точки. Хотя мы уже говорили, между какими по порядку точками проводятся координатные оси, делали мы это только для объяснения принципов работы скриптов. На результат их работы порядок передачи контрольных точек не влияет, за исключением того, что для Transform4 точки надо передавать в порядке обхода вокруг, но с какого угла начинать - не важно. Раз это неважно, мы уже поняли, что выбор диагонали реализован не был. Толку от этого выбора всё равно было бы мало. Можете убедиться в этом самостоятельно, проверив, как будет выглядеть преобразованная линия, проходящая через середину растягиваемой диагонали.

Возможно, несмотря на то, что линия становится непрямой, мы зря беспокоимся. Как мы помним, сохранения прямоты мы в общем случае не требуем, так что проблема пока не видна. Чтобы она проявилась, нам надо добавить в линию несколько точек по обе стороны от середины. Желаемым результатом преобразования будет выстраивание их в более-менее плавную кривую. Однако этого не последует. Точки с одной стороны от середины будут лежать на одной прямой, точки с другой стороны - на другой прямой, а по середине будет резкий поворот. Никакой плавной кривой у нас так не получится.

Для желаемого результата нам придётся выполнять преобразование как-то по-другому, что мы и сделаем. При этом преобразуемую линию мы даже сможем сохранить прямой. Чтобы этого добиться, привязывать линию к середине одной из диагоналей четырёхугольника не следует. В этом месте нам придётся отказаться от триангуляции. Придётся ли отказаться от линейных преобразований, мы пока не знаем. От чего мы отказываться не будем, так это от идеи привязать точку посередине преобразуемой линии к середине какой-то другой линии, так, чтобы точка осталась на этой же середине и после преобразования. Для выбора этой другой линии есть один очевидный вариант.

Стороны квадрата, на которых находятся крайние точки преобразуемой линии, были и останутся после преобразования вертикальными. Тогда и через точку в центре квадрата мы проведём вертикальную линию. Длина её отрезков от нижней стороны квадрата до пересечения с преобразуемой линией и от пересечения до верхней стороны одинакова. Одинаковой она будет и после рассматриваемой здесь деформации квадрата, на которую мы наложим желаемый результат. Нам остаётся только придумать преобразование, которое достигнет этого результата. Основываться оно будет как раз на расположении точек на линиях, проведённых в направлениях, соответствующих сторонам четырёхугольника.

В преобразуемую линию можно было бы добавить сколько угодно точек и не обязательно посередине. Но также, как и для точки посередине, для каждой из добавленных точек можно провести проходящую через неё вертикальную линию, причём точка будет делить пополам отрезок своей вертикальной линии от нижней стороны четырёхугольника до верхней. Это будет верно как до преобразования, так и после, если, опять же, считать, что преобразование дало желаемый результат - прямую от середины левой стороны четырёхугольника до середины правой. Мы даже можем сказать, что желаемый результат - это такая линия, которая делит пополам любой вертикальный отрезок от нижней до верхней стороны четырёхугольника. Так мы получили определение преобразования для данного частного случая, который мы легко смогли бы реализовать. Для общего случая преобразование будет, конечно, посложнее.

{% TODO %}рисунок: преобразованная линия идёт через середины вертикалей{% endTODO %}

Теперь представим себе, что точки в преобразуемую линию мы добавили через одинаковые промежутки, а затем провели через эти точки вертикальные линии. На что похожи эти линии? На линии координатной сетки для исходной и целевой систем координат. Пока что все линии параллельны, и одну из них мы можем назначить осью, то есть линией, соответствующей значению координаты 0. Это будет линия, проходящая через левую сторону четырёхугольника. Линия через правую сторону будет соответствовать значению координаты 1. Обе линии также соответствуют тем координатам, которые мы решили дать углам, точнее, первым координатам из пар.

Нужно, чтобы были линии, соответствующие и вторым координатам, а также набор промежуточных линий между ними. Этот набор вместе с предыдущим набором вертикальных линий и станет сеткой координат. Правда, мы сможем провести его в виде горизонтальных линий только для исходного квадрата. Что получится, если попытаться это сделать для деформированного квадрата, мы уже видели. Но и как именно провести оставшиеся линии сетки мы тоже отчасти видели. Две из них, соответствующие значениям координат 0 и 1, следуют из желаемых координат углов. Ими будут нижняя и верхняя сторона четырёхугольника. Преобразуемая линия из только что рассмотренного примера - логичный кандидат для линии с координатой 0.5. Эта линия проходит через точку на *половине* высоты левой стороны, и через точку на *половине* высоты правой. Точно так же мы можем провести линию для координаты 0.25 на *четверти* высоты с обеих сторон. Нетрудно догадаться, как провести линию и для любого другого значения координаты, в том числе выходящего за пределы [0, 1].

Итак, мы получили координатную сетку нашей системы. При этом нам пришлось разрешить линиям, соответствующим одной координате, не быть параллельными. Как мы тогда сможем говорить про координатные оси? Где в нашем примере, будет ось, соответствующая второй координате, линии которой после преобразования перестают быть горизонтальными? Про оси нам придётся тоже забыть, мы будем описывать системы координат без них. Тогда почему мы не избавились от них раньше, как от матриц? Раньше, то есть для Transform3 они нам были нужны. Как мы договорились, у нас уже имелись реализованные преобразования *в* и *из* системы координат, которые описывались осями. Теперь мы воспользоваться ими не сможем, и нам придётся реализовать свои преобразования для новой системы. Сначала, конечно, надо описать систему для общего случая.

## Нелинейное преобразование для четырёхугольника

Как построить координатную сетку для произвольного четырёхугольника, вы, скорее всего, уже догадались. Линии координатной сетки мы будем проводить через соответствующие точки *противоположных* сторон четырёхугольника. У нас есть два четырёхугольника - исходный и целевой - со своими системами, которые строятся одинаковым образом, поэтому в данном разделе мы будем считать, что существует только один из них. Тогда наша задача сводится к тому, чтобы построить преобразования в между глобальной системой координат и системой координат одного произвольного четырёхугольника. Координаты в системе четырёхугольника мы будем обозначать символами (*u*,*v*).

Начинаем мы с того, что фиксируем координаты контрольных точек, переданных пользователем скрипта. Мы получили от пользователя их координаты в глобальной системе. В системе четырёхугольника мы даём им координаты (0,0), (0,1), (1,1) и (1,0) в порядке обхода четырёхугольника вокруг. Нам нужны координаты остальных точек внутри четырёхугольника и рядом с ним, но до этого мы доберёмся чуть позже. Сначала нам легче рассмотреть обратную задачу: как, зная координаты точки в системе четырёхугольника, получить её глобальные координаты. Для её решения мы и представляем себе сетку координат, двигаясь вдоль линий которой мы придём в нужную точку.

Рассматривая далее линии сетки, мы можем говорить, что мы их "рисуем" или "проводим", но имеем в виду мы при этом, что проводим мы их мысленно. Реально при работе скрипта в осмовские данные мы эти линии не добавляем даже в качестве временных. Впрочем, четыре линии, соответствующие сетке для целевой системы мы уже добавили в виде направляющих. Также заметим, что все координатные линии являются прямыми неограниченной длины, но мы иногда будем говорить о них как об отрезках внутри четырёхугольника. Тогда надо понимать, что координатными линиями являются и продолжения этих отрезков.

Проведём сначала линии, соответствующие постоянному значению первой координаты (*u*) системы четырёхугольника. Эти линии были вертикальными в рассматриваемом ранее примере, но в общем случае они могут идти в любом направлении и не быть параллельными друг другу. Каждую из этих линий можно провести, соединив две точки на сторонах, которые в примере были нижней и верхней. В общем случае, поскольку четырёхугольник может быть ориентирован как угодно, у него не будет нижней и верхней стороны. В качестве нижней стороны будет выступать сторона, соединяющая углы (0,0) и (1,0) в координатах четырёхугольника, а в качестве верхней - соединяющая углы (0,1) и (1,1). Итак, для координатной линии, соответствующей координате u, нам нужны две точки на сторонах четырёхугольника: (u,0) и (u,1). Эти точки делят свои стороны в пропорции u : 1-u. В примере мы начали с того, что нашли линию, соответствующую u=0.5, проходящую через точки, делящие стороны пополам. Так мы получим множество линий, соответствующих различным значениям u.

Аналогично получим и линии, соответствующие постоянному значению второй координаты (*v*). Эти линии в примере были горизонтальными до деформации квадрата, а после неё горизонтальной осталась только та, которая соответствовала нижней стороне квадрата. В общем случае они тоже горизонтальными и параллельными друг другу быть не обязаны. Линии должны соединять точки на "левой" и "правой" стороне. Для каждой линии координаты v на "левой" стороне это точка (0,v), а на "правой" - (1,v). Обе эти точки делят свои стороны в пропорции v : 1-v.

Итак, чтобы попасть в точку с заданными координатами (u,v), можно, начав из точки (0,0), двигаться вдоль линии v=0, идущей по "нижней" стороне четырёхугольника, до пересечения с линией u. Дальше, по линии u надо дойти до линии v, где и будет искомая точка. С точки зрения реализации вычислений, "попасть" означает "получить координаты в глобальной системе". Для всех выражений типа "делит в пропорции" и "двигаться до пересечения" можно дать конкретные формулы, в глобальных координатах. Формулы эти не слишком сложны, и состоят они только из сложений, вычитаний и умножений чисел. В результате для координат точки получится такая формула:

<p class="notice">
Тут должна быть формула, которую надо перенести с бумаги, предварительно найдя эту бумагу.
</p>

Можно заметить, что в ней присутствуют произведения координат u и v, что делает формулу относительно них нелинейной. Эта нелинейность создаёт дополнительные проблемы для выполнения обратной операции - нахождения координат (u,v) по глобальным координатам. Проблемы эти на самом деле не слишком большие, и их решение с точки зрения реализации скрипта занимает десять строк кода вместо двух, если бы нелинейности не было. Тем не менее, часто приходится сталкиваться со средствами, такими как PicLayer, которые дальше линейного преобразования не идут.

Поскольку в этой записи мы избегаем чисто математических объяснений, оставляя их для возможной другой, попробуем и здесь объяснить проблемы с обратной операцией, не ссылаясь на произведение координат. В случае с линейным преобразованием по трём парам точек таких проблем не будет. Для получения глобальных координат из (u,v) мы могли начать из движение из точки (u,v)=(0,0), пройти на расстояние u в направлении первой оси, затем пройти на расстояние v вдоль второй, то есть точно так же двигаться вдоль координатных линий, как было описано выше для линий прямоугольника. Обратная задача решается так: мы начинаем движение из точки с известными нам глобальными координатами и идём в направлении второй оси до пересечения с первой осью. Пройденное рами расстояние будет значением v, а оставшееся - значением u. Математически "идти по прямой до пересечения с другой прямой" - это решить систему линейных уравнений.

Сделаем пару примечаний к приведённым выше рассуждениям. Расстояния, когда речь идёт о координатах (u,v), нам нужны в масштабе соответствующих осям векторов. То есть, расстояние 1 - это длина соответствующей стороны треугольника. Движения по координатным линиям описывались так, что мы сначала шли в одном направлении, а затем в другом, например, сначала в u, затем в v. Мы можем поступить и наоборот, и двигаться сначала в другом направлении, например, сначала в v, а затем в u. Результат должен получиться такой же.

Как видно, в линейном случае для обратной задачи мы сделали почти то же самое - прошли по координатным линиям, только в обратном направлении, от точки, а не к ней. В чём проблема сделать то же самое для нелинейного случая? Проблема в том, что нам неизвестно это обратное направление. У нас нет оси, параллельно которой идут все координатные линии. Почему проблемы не было, когда мы шли к точке? Тогда направление было известно. Известно оно было, потому что мы двигались от границы четырёхугольника, через которую определены все координатные линии.

{% TODO %}почему не найти линию через точку, делящую обе стороны четырёхугольника в одинаковой пропорции?{% endTODO %}

Как уже было сказано, описанная проблема не слишком серьёзная, и её решение реализовано в скрипте Transform4. Какое именно у неё решение, как получить матрицы для линейных преобразований, как реализовать скрипт Transform2 и как вообще писать скрипты для CommandLine - всё это хорошие темы для ещё одной записи. В этой записи мы больше не будем беспокоиться о том, как работает скрипт Transform4, когда он используется при предназначенных для него условиях. Но нам придётся обратить внимание на сами эти условия.

## Условия использования преобразования четырёхугольника

Основным условием можно назвать то, что Transform4 рассчитан на работу с четырёхугольниками, *не слишком отличающимися от прямоугольников*. Дело в том, что для нас важно наличие у четырёхугольника противоположных сторон, и чем больше их направление совпадает, тем меньше возможно неприятностей при выполнении преобразования. Противоположность нам нужна для описанного выше способа построения координатной сетки, который заключался в соединении соответствующих точек противоположных сторон четырёхугольника и их продолжений за его пределы. Мы бы хотели видеть пространство внутри четырёхугольника и рядом с ним покрытым координатной сеткой с четырёхугольными ячейками. Когда мы рассматриваем обыкновенные четырёхугольники, те, которые которые обычно приходят нам в голову, и в форме которых обычно бывают кварталы, сетка такой и получается. Но, поскольку четырёхугольник мы можем задать любой или задать его неправильно, то и сетка может получиться весьма отличающейся от ожидаемой.

Мы уже приводили невыпуклый прямоугольник в качестве примера формы, *слишком отличающейся от прямоугольной*. Какие стороны являются противоположными у невыпуклого четырёхугольника в форме буквы V? Противоположность сторон скрипт определяет из порядка передачи контрольных точек. То есть, противоположными он посчитает стороны от 1-й контрольной точки до 2-й и от 3-й до 4-й, точнее, от 4-й до 3-й, потому что направление вдоль сторон имеет значение. Значение оно имеет в том смысле, что одной паре концов сторон соответствует значение координаты 0, а другой - значение 1. В рассмотренной паре сторон точки 1 и 4 соответствуют значению координаты 0, а точки 2 и 3 - значению 1. Это касалось одной пары взаимно противоположных сторон, помимо которой есть и другая - от 1-й до 4-й точки и от 2-й до 3-й.

{% TODO %}картинка: четырёхугольник в форме V с координатной сеткой{% endTODO %}

Значит, для V-образного четырёхугольника противоположными являются нижняя сторона левой половины и верхняя сторона правой. Можно заметить, что нам не придётся далеко продолжать эти прямые, чтобы дойти до точки их пересечения, так что их направление весьма не совпадает. Такое сильное несовпадение направлений типично для невыпуклого четырёхугольника, хотя можно попытаться построить невыпуклый четырёхугольник и без него. Например, можно сколь угодно сильно вытянуть букву V по вертикали, так чтобы все её стороны стали почти параллельны. Тут мы, правда, не учтём того, что имеет значение и направление движения вдоль сторон, из-за которого выше нам пришлось делать уточнение, что сторона идёт от 4-й точки до 3-й.

Рисование координатных линий можно представить себе следующим образом. У нас есть пара точек, каждая из которых движется по плоскости в своём направлении и со своей скоростью, и через определённые интервалы времени проводятся соединяющие их линии. Первая точка стартует из угла 1 и движется в направлении угла 2, вторая стартует из угла 4 и движется к углу 3. Движутся они с такой скоростью, чтобы оказаться в углах 2 и 3 одновременно. Если продлить этот процесс, как вперёд, так и назад по времени, вся плоскость окажется покрыта линиями, соответствующими первой координате... или нет?

Когда мы представляем себе типичный прямоугольник, кажется, что так и будет. Для прямоугольника или другого параллелограмма картина выглядит идеально. Обе точки из пары движутся в одном направлении с одинаковой скоростью, из чего получаются параллельные координатные линии, покрывающие всё пространство. Если же наш четырёхугольник не столь идеален, то точки из пары уже не движутся одинаково, и проводимые через них линии будут, скорее всего, не параллельны. Непараллельные прямые где-то пересекаются, и в этом месте координатная сетка будет выглядеть странно. Однако, пока это место далеко от преобразуемых данных, оно нам не помешает. Чем ближе наш четырёхугольник к параллелограмму, тем проблемное место дальше.

Теперь вернёмся к V-образному четырёхугольнику. Ясно, что он весьма далёк от параллелограмма, и точки из пары будут перемещаться в разных направлениях. Одна из точек будет двигаться право-вниз, а другая - вправо-вверх. Как при этом будет выглядеть семейство их координатных линий, можно увидеть на рисунке. То, что линии, проведённые через точки *в пределах* сторон проходят между этими точками *за пределами* четырёхугольника - далеко не самая большая проблема, хотя уже это обещает нам нежелательный результат преобразования. Здесь он будет выражен в том, что преобразуемые данные могут переместиться из пределов заданной границы наружу.

Мы видим и ожидаемые пересечения координатных линий, и не где-то вдали, а там, где проигнорировать мы их не сможем. Собственно, мы их видим практически везде внутри четырёхугольника, и не только внутри. Теперь представим себе процесс нахождения (u,v)-координат для находящихся там точек. Его мы описывали как движение вдоль координатной линии к контуру четырёхугольника. Если в какой-то точке линия, соответствующая первой или второй координате, не единственная, вдоль которой из них надо двигаться? Получается, что в этом случае (u,v) координаты однозначно не определены.

Мы также видим дугу, у которой координатные линии уплотняются. Это предвещает нам проблемы с точностью определения координат. Но гораздо хуже то, что мы видим за этой дугой. Мы видим, что координатные линии не проходят там вообще. Если это правда, то для находящихся в ней точек задача получения их (u,v)-координат не имеет решения. Тогда рассматриваемое здесь преобразование неприменимо для этих точек, и результаты работы скрипта Transform4 не определены. Но, может быть, нам только кажется, что область без координатных линий существует, потому что мы нарисовали не все линии? Нет, нам это не кажется, и при желании мы бы могли построить пример, для которого это легко доказать. Для этого нам понадобилось бы деформировать нашу букву V, чтобы "противоположные" стороны её четырёхугольника стали перпендикулярными. Мы можем догадаться, что наконец-то произведение координат в формулах проявило себя в полной мере, то есть как квадратное уравнение, которое может иметь два решения или не иметь ни одного.

Все эти рассуждения про координатные линии позволяют нам уточнить, какие именно четырёхугольники подходят для скрипта Transform4. Раньше мы говорили, что это четырёхугольники, достаточно близкие к прямоугольнику. Лучше было бы сказать вместо этого "достаточно близкие к параллелограмму". Достаточно близкие - это те, у которых линии, являющиеся продолжениями противоположных сторон, пересекаются достаточно далеко. Пересекаются достаточно далеко - значит пересекаются там, где нет преобразуемых данных.

[Простой](https://ru.wikipedia.org/wiki/Простой_многоугольник) невыпуклый четырёхугольник - это ещё не самый странный вид четырёхугольника, который можно попытаться передать скрипту. Четырёхугольник может быть и непростым, то есть таким, у которого стороны пересекаются. Если раньше мы опасались пересечения продолжений сторон, то в данном случае нам их не надо продолжать, чтобы найти проблему. Хорошо, что при правильных действиях эта проблема не возникнет. Непростой четырёхугольник не соответствует никакой реальной форме квартала, так что сознательно передавать мы его не будем. Несознательно же его задать можно, если передать скрипту контрольные точки в неправильном порядке, например, поменяв местами у выпуклого четырёхугольника два смежных угла.

На практике проблемы с пересекающимися или отсутствующими координатными линиями обычно не возникают, потому что большинство четырёхугольных кварталов выпуклые, а большинство невыпуклых кварталов имеют более четырёх углов, и с ними приходится разбираться по-другому. Если же нам действительно попадётся квартал в форме буквы V, мы можем использовать Transform3 на его [треугольной оболочке](https://ru.wikipedia.org/wiki/Выпуклая_оболочка). При этом, правда, мы не воспользуемся одной из контрольных точек, а, значит, мы не контролируем направление его "внутренних" сторон, находящихся внутри оболочки.

Если нас такое развитие событий не устраивает, мы можем воспользоваться скриптом Transform3 и по-другому. Для этого подумаем, какие стороны V-образного четырёхугольника мы бы сами посчитали противоположными. Скорее всего, мы бы решили, что это смежные стороны, особенно обе стороны левой и обе стороны правой половины "буквы". Координатные линии мы бы хотели проводить между ними. Между смежными сторонами линии проводит Transform3, потому что в треугольнике все стороны смежные. Чтобы добиться желаемого, нам нужно сделать то, от чего мы отказались, когда работали с обычными четырёхугольниками, то есть триангуляцию. Transform3 надо применить отдельно к левой и к правой половине "буквы" V.

Теперь обозначим ещё одну причину, по которой мы хотели получить координатную сетку без серьёзных искажений. Вспомним свойство 3, которому должно удовлетворять выполняемое преобразование. В нём гарантировалось отсутствие резких изгибов у образов прямых линий, и мы сожалели, что не можем просто сохранить их прямыми. Вспомним свойство 1, из которого следует, что некоторые прямые всё-таки сохраняются, а именно те, которые идут по сторонам четырёхугольника. Кроме них также есть и другие сохраняющиеся прямые. Вспомним пример с деформацией квадрата, через который мы подошли к определению координатной сетки. Мы решили задать сетку и, соответственно, преобразование так, чтобы линия, соединяющая середины вертикальных сторон, осталась прямой. Потом оказалось, что она является координатной линией, так же, как и стороны четырёхугольника. Координатные линии мы определили как прямые, так что очевидно, что *любая прямая, проходящая по координатным линиям прямой и останется*. Для нашего примера с квадратом прямой останется любая вертикальная или горизонтальная линия. Линии же в других направлениях прямыми могут не остаться.

В качестве другого направления можно назвать диагональ четырёхугольника. В нашем примере с квадратом с диагоналями мы имели дело ещё до того, как начали придумывать используемое нами преобразование. Перед этим мы делили квадрат на два треугольника и выполняли над каждым из них линейное преобразование. Эти преобразования сохраняли прямыми все стороны треугольников, одной из которых являлась диагональ. Получается, что у нас уже было преобразование, которое могло делать то, чего не может Transform4. Сохранением прямоты диагонали мы пожертвовали ради *более важных направлений*, по которым идут линии координатной сетки. Кроме того, старое преобразование оставило бы прямой только одну из диагоналей. Другая диагональ согнулась бы, как и любая линия, проходящая из зоны действия одного линейного преобразования в зону действия другого.

Чтобы жертва была не напрасной, направления координатных линий действительно должны быть более важными. Если мы даже не можем себе представить, в каких частях плоскости координатных линий не окажется вообще, в их направлениях вряд ли много важности. То же можно сказать и про места с пересечениями линий одной координаты. Если наши исходные данные находятся в таких местах, мы можем сразу заканчивать все рассуждения, потому что преобразование не определено. Но есть и вариант, когда в местах странностей координатной сетки данные окажутся лишь после преобразования, которое тогда будет хоть и не обратимо, но определено. Из-за этого мы ранее в свойстве 2 не гарантировали того, что параллельные линии не преобразуются в пересекающиеся. Если исходным четырёхугольником был параллелограмм, его координатные линии были параллельны, но после преобразования в четырёхугольник общего вида они где-то пересекутся. Нам бы хотелось, чтобы это место было подальше.

К сожалению, нам придётся отложить дальнейший разбор преобразований для другой записи. Он нас может и совсем не интересовать, а довести правки до готового к выгрузке вида нам надо. Для этого нам придётся вручную поправить результаты автоматического сдвига, да и ручного - тоже. К этим поправкам мы и перейдём в [следующей главе](../11-cleanup/).
